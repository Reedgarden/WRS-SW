/*
 * White Rabbit Switch Management
 * Copyright (C) 2010, CERN.
 *
 * Version:     wrsw_snmpd v1.0
 *
 * Authors:     Juan Luis Manas (juan.manas@integrasys.es)
 *
 * Description: Handles requests for ieee8021QBridgeFdbTable table.
 *              Provides configuration information and basic control
 *              on the RTU filtering database.
 *              Note: this file originally auto-generated by mib2c using
 *              : mib2c.raw-table.conf 17436 2009-03-31 15:12:19Z dts12 $
 *
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version
 * 2 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "ieee8021QBridgeFdbTable.h"

#include "rtu_fd_proxy.h"

/* column number definitions for table ieee8021QBridgeFdbTable */
#define COLUMN_IEEE8021QBRIDGEFDBCOMPONENTID		    1
#define COLUMN_IEEE8021QBRIDGEFDBID		                2
#define COLUMN_IEEE8021QBRIDGEFDBDYNAMICCOUNT		    3
#define COLUMN_IEEE8021QBRIDGEFDBLEARNEDENTRYDISCARDS	4
#define COLUMN_IEEE8021QBRIDGEFDBAGINGTIME		        5

#define DEFAULT_COMPONENT_ID                            1
#define MIN_FDB_AGING_TIME                              10
#define MAX_FDB_AGING_TIME                              1000000


/**
 * Update the requested OID to match this instance
 */
static void update_oid(
    netsnmp_request_info           *req,
    netsnmp_handler_registration   *reginfo,
    int                            column,
    netsnmp_variable_list          *indexes)
{
    oid    build_space[MAX_OID_LEN];
    size_t build_space_len = 0;
    size_t index_oid_len = 0;

    memcpy(build_space, reginfo->rootoid,   /* registered oid */
                        reginfo->rootoid_len * sizeof(oid));
    build_space_len = reginfo->rootoid_len;
    build_space[build_space_len++] = 1;         /* entry */
    build_space[build_space_len++] = column;    /* column */
    build_oid_noalloc(build_space + build_space_len,
                      MAX_OID_LEN - build_space_len, &index_oid_len,
                      NULL, 0, indexes);
    snmp_set_var_objid(req->requestvb, build_space,
                       build_space_len + index_oid_len);
}

static int get_column(netsnmp_request_info *req, int colnum, u_long cid, u_long fid)
{
    u_long   count;       // ieee8021QBridgeFdbDynamicCount
    uint32_t discards;    // ieee8021QBridgeFdbLearnedEntryDiscards
    long     age;         // ieee8021QBridgeFdbAgingTime

    if (cid != DEFAULT_COMPONENT_ID)
        return SNMP_NOSUCHINSTANCE;

    if (fid >= NUM_FIDS)
        return SNMP_NOSUCHINSTANCE;

    errno = 0;
    switch (colnum) {
    case COLUMN_IEEE8021QBRIDGEFDBDYNAMICCOUNT:
        count = rtu_fdb_proxy_get_num_dynamic_entries(fid);
        if (errno)
            return SNMP_ERR_GENERR;
        snmp_set_var_typed_integer(req->requestvb, ASN_GAUGE, count);
        break;
    case COLUMN_IEEE8021QBRIDGEFDBLEARNEDENTRYDISCARDS:
        discards = rtu_fdb_proxy_get_num_learned_entry_discards(fid);
        if (errno)
            return SNMP_ERR_GENERR;
        snmp_set_var_typed_integer(req->requestvb, ASN_COUNTER64, (uint64_t)discards);
        break;
    case COLUMN_IEEE8021QBRIDGEFDBAGINGTIME:
        age = rtu_fd_proxy_get_aging_time(fid);
        if (errno)
            return SNMP_ERR_GENERR;
        snmp_set_var_typed_integer(req->requestvb, ASN_INTEGER, age);
        break;
    default:
        return SNMP_NOSUCHOBJECT;
    }
    return 0;
}

static int get(netsnmp_request_info *req)
{
    netsnmp_table_request_info  *tinfo;

    tinfo = netsnmp_extract_table_info(req);
    return get_column(
        req,
        tinfo->colnum,
        *(tinfo->indexes->val.integer),                  // cid
        *(tinfo->indexes->next_variable->val.integer)    // fid
    );
}

static int get_next(netsnmp_request_info *req,
    netsnmp_handler_registration *reginfo)
{
    netsnmp_table_request_info  *tinfo;

    u_long cid;         // ieee8021QBridgeFdbComponentId
    u_long fid;         // ieee8021QBridgeFdbId

    tinfo = netsnmp_extract_table_info(req);
    // Get indexes for entry
    cid = *(tinfo->indexes->val.integer);
    if (cid != DEFAULT_COMPONENT_ID)
        return SNMP_NOSUCHINSTANCE;

    fid = *(tinfo->indexes->next_variable->val.integer);
    if (fid >= NUM_FIDS)
        return SNMP_NOSUCHINSTANCE;

    // Get index for next entry
    errno = 0;
    fid = rtu_fdb_proxy_get_next_fid(fid);
    if (errno)
        return SNMP_ERR_GENERR;
    if (fid >= NUM_FIDS)
        return SNMP_ENDOFMIBVIEW;   // inform the handler that it should
                                    // start with next column object
    // Update indexes
    *(tinfo->indexes->next_variable->val.integer) = fid;

    // Update OID
    update_oid(req, reginfo, tinfo->colnum, tinfo->indexes);

    // return next entry column value
    return get_column(req, tinfo->colnum, cid, fid);
}

static int set_reserve1(netsnmp_request_info *req)
{
    int ret;
    netsnmp_table_request_info *tinfo;

    u_long cid;         // ieee8021QBridgeFdbComponentId
    u_long fid;         // ieee8021QBridgeFdbId

    tinfo = netsnmp_extract_table_info(req);
    // Check indexes
    cid = *(tinfo->indexes->val.integer);
    if (cid != DEFAULT_COMPONENT_ID)
        return SNMP_NOSUCHINSTANCE;

    fid = *(tinfo->indexes->next_variable->val.integer);
    if (fid >= NUM_FIDS)
        return SNMP_NOSUCHINSTANCE;

    // Check column value
    switch (tinfo->colnum) {
    case COLUMN_IEEE8021QBRIDGEFDBAGINGTIME:
        ret = netsnmp_check_vb_int_range(req->requestvb,
            MIN_FDB_AGING_TIME, MAX_FDB_AGING_TIME);
        if (ret != SNMP_ERR_NOERROR)
            return ret;
        break;
    default:
        return SNMP_ERR_NOTWRITABLE;
    }
    return 0;
}

static int set_commit(netsnmp_request_info *req)
{
    netsnmp_table_request_info *tinfo;
    u_long age;
    u_long fid;         // ieee8021QBridgeFdbId
    int err;

    tinfo = netsnmp_extract_table_info(req);
    fid = *(tinfo->indexes->next_variable->val.integer);
    switch (tinfo->colnum) {
    case COLUMN_IEEE8021QBRIDGEFDBAGINGTIME:
        age = *req->requestvb->val.integer;
        // At this point values are already checked so fdb method will
        // not fail.
        // mini-ipc should also not fail... otherwise we have a problem,
        // ...but exactly the same problem that would exist in case we
        // implement the two phase commit, as undoing also requires
        // mini-ipc calls.
        errno = 0;
        err = rtu_fdb_proxy_set_aging_time(fid, age);
        if (err || errno)
            return SNMP_ERR_GENERR;
        break;
    }
    return 0;
}

/** handles requests for the ieee8021QBridgeFdbTable table */
static int ieee8021QBridgeFdbTable_handler(
    netsnmp_mib_handler             *handler,
    netsnmp_handler_registration    *reginfo,
    netsnmp_agent_request_info      *reqinfo,
    netsnmp_request_info            *requests)
{
    netsnmp_request_info *req;
    int err;

    switch (reqinfo->mode) {
    case MODE_GET:
        for (req = requests; req; req = req->next) {
            err = get(req);
            if (err)
                netsnmp_set_request_error(reqinfo, req, err);
        }
        break;
    case MODE_GETNEXT:
        for (req = requests; req; req = req->next) {
            err = get_next(req, reginfo);
            if (err)
                netsnmp_set_request_error(reqinfo, req, err);
        }
        break;
    case MODE_SET_RESERVE1:
        for (req=requests; req; req=req->next) {
            err = set_reserve1(req);
            if (err) {
                netsnmp_set_request_error(reqinfo, req, err);
                return SNMP_ERR_NOERROR;
            }
        }
        break;
    case MODE_SET_RESERVE2:
        break;
    case MODE_SET_FREE:
        break;
    case MODE_SET_ACTION:
        break;
    case MODE_SET_UNDO:
        break;
    case MODE_SET_COMMIT:
        for (req = requests; req; req = req->next) {
            err = set_commit(req);
            if (err)
                netsnmp_set_request_error(reqinfo, req, err);
        }
        break;
    }
    return SNMP_ERR_NOERROR;
}

/** Initialize the ieee8021QBridgeFdbTable table by defining its contents and how it's structured */
static void initialize_table_ieee8021QBridgeFdbTable(void)
{
    const oid ieee8021QBridgeFdbTable_oid[] = {1,3,111,2,802,1,1,4,1,2,1};
    netsnmp_handler_registration    *reg;
    netsnmp_table_registration_info *tinfo;

    reg = netsnmp_create_handler_registration(
              "ieee8021QBridgeFdbTable",     ieee8021QBridgeFdbTable_handler,
              (oid *)ieee8021QBridgeFdbTable_oid, OID_LENGTH(ieee8021QBridgeFdbTable_oid),
              HANDLER_CAN_RWRITE
              );

    tinfo = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    netsnmp_table_helper_add_indexes(tinfo,
        ASN_UNSIGNED,  /* index: ieee8021QBridgeFdbComponentId */
        ASN_UNSIGNED,  /* index: ieee8021QBridgeFdbId */
        0);

    tinfo->min_column = COLUMN_IEEE8021QBRIDGEFDBDYNAMICCOUNT;
    tinfo->max_column = COLUMN_IEEE8021QBRIDGEFDBAGINGTIME;

    netsnmp_register_table(reg, tinfo);
}

/** Initializes the ieee8021QBridgeFdbTable module */
void init_ieee8021QBridgeFdbTable(void)
{
    initialize_table_ieee8021QBridgeFdbTable();
    rtu_fdb_proxy_create("wrsw_snmpd");
}
