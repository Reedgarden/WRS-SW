/*
 * White Rabbit RTU (Routing Table Unit)
 * Copyright (C) 2010, CERN.
 *
 * Version:     wrsw_snmpd v1.0
 *
 * Authors:     Juan Luis Manas (juan.manas@integrasys.es)
 *
 * Description: Handles requests for ieee8021QBridgeTpFdbTable table.
 *              Provides the list of unicast entries currently stored
 *              in the RTU filtering database.
 *              Note: this file originally auto-generated by mib2c using
 *              : mib2c.raw-table.conf 17436 2009-03-31 15:12:19Z dts12 $
 *
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version
 * 2 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "ieee8021QBridgeTpFdbTable.h"

#include "rtu_fd_proxy.h"
#include "rtu_fd.h"

/* column number definitions for table ieee8021QBridgeTpFdbTable */
#define COLUMN_IEEE8021QBRIDGETPFDBADDRESS      1
#define COLUMN_IEEE8021QBRIDGETPFDBPORT         2
#define COLUMN_IEEE8021QBRIDGETPFDBSTATUS       3

#define DEFAULT_COMPONENT_ID                    1

enum fdb_entry_status {
	other           = 1,
	Invalid         = 2,
	Learned         = 3,
	Self            = 4,
	Mgmt            = 5
};

// Row entry
struct ieee8021QBridgeTpFdbTable_entry {
    // indexes
    u_long  cid;
    uint8_t fid;
    uint8_t mac[ETH_ALEN];
    // Columns
    uint32_t port_map;
    enum fdb_entry_status status;
};

/**
 * Update the requested OID to match this instance
 */
static void update_oid(
    netsnmp_request_info           *req,
    netsnmp_handler_registration   *reginfo,
    int                            column,
    netsnmp_variable_list          *indexes)
{
    oid    build_space[MAX_OID_LEN];
    size_t build_space_len = 0;
    size_t index_oid_len = 0;

    memcpy(build_space, reginfo->rootoid,   /* registered oid */
                        reginfo->rootoid_len * sizeof(oid));
    build_space_len = reginfo->rootoid_len;
    build_space[build_space_len++] = 1;         /* entry */
    build_space[build_space_len++] = column;    /* column */
    build_oid_noalloc(build_space + build_space_len,
                      MAX_OID_LEN - build_space_len, &index_oid_len,
                      NULL, 0, indexes);
    snmp_set_var_objid(req->requestvb, build_space,
                       build_space_len + index_oid_len);
}

/**
 * Cache entry in agent memory. The ent parameter must have its indexes already
 * set by callee. The method fills the rest of parameters with data from
 * actual FDB.
 */
static int cache_entry(struct ieee8021QBridgeTpFdbTable_entry *ent)
{
    int found;
    int type;

    errno = 0;
    found = rtu_fdb_proxy_read_entry(ent->mac, ent->fid,
        &(ent->port_map), &type);
    ent->status = (type == STATIC) ? Mgmt:Learned;
    if (errno)
        return SNMP_ERR_GENERR;
    if (!found)
        return SNMP_NOSUCHINSTANCE;
    return SNMP_ERR_NOERROR;
}

/**
 * Get indexes for an entry.
 * @param tinfo table information that contains the indexes (in raw format)
 * @param ent (OUT) used to return the retrieved indexes
 * @return SNMP_ERR_NOERROR if indexes are valid. SNMP_NOSUCHINSTANCE in case
 * any of the indexes is not valid.
 */
static int get_indexes(netsnmp_table_request_info *tinfo,
    struct ieee8021QBridgeTpFdbTable_entry *ent)
{
    netsnmp_variable_list *idx = tinfo->indexes;

    ent->cid = *(idx->val.integer);
    idx = idx->next_variable;
    ent->fid = *(idx->val.integer);
    idx = idx->next_variable;
    memcpy(ent->mac, idx->val.string, idx->val_len);
    if ((ent->cid != DEFAULT_COMPONENT_ID) || (ent->fid >= NUM_FIDS))
        return SNMP_NOSUCHINSTANCE;
    return SNMP_ERR_NOERROR;
}

/**
 * @param ent should contain appropriate entry indexes
 */
static int get_column(
    netsnmp_request_info *req,
    int colnum,
    struct ieee8021QBridgeTpFdbTable_entry *ent)
{
    int ret;

    switch (colnum) {
    case COLUMN_IEEE8021QBRIDGETPFDBPORT:
        ret = cache_entry(ent);
        if (ret != SNMP_ERR_NOERROR)
            return ret;
        snmp_set_var_typed_integer(req->requestvb, ASN_UNSIGNED,
            ent->port_map);
        break;
    case COLUMN_IEEE8021QBRIDGETPFDBSTATUS:
        ret = cache_entry(ent);
        if (ret != SNMP_ERR_NOERROR)
            return ret;
        snmp_set_var_typed_integer(req->requestvb, ASN_INTEGER,
            ent->status);
        break;
    default:
        return SNMP_NOSUCHOBJECT;
    }
    return 0;
}

static int get(netsnmp_request_info *req)
{
    int err;
    struct ieee8021QBridgeTpFdbTable_entry ent;
    netsnmp_table_request_info *tinfo;

    tinfo = netsnmp_extract_table_info(req);
    // Get indexes for entry
    err = get_indexes(tinfo, &ent);
    if (err != SNMP_ERR_NOERROR)
        return err;
    // Get column value
    return get_column(req, tinfo->colnum, &ent);
}

static int get_next(netsnmp_request_info *req,
    netsnmp_handler_registration *reginfo)
{
    int ret, found, type;
    netsnmp_variable_list *idx;
    netsnmp_table_request_info *tinfo;
    struct ieee8021QBridgeTpFdbTable_entry ent;

    tinfo = netsnmp_extract_table_info(req);
    // Get indexes for entry
    ret = get_indexes(tinfo, &ent);
    if (ret != SNMP_ERR_NOERROR)
        return ret;
    // Get indexes for next entry
    do {
        errno = 0;
        found = rtu_fdb_proxy_read_next_entry(&(ent.mac), &(ent.fid),
            &(ent.port_map), &type);
        if (errno)
            return SNMP_ERR_GENERR;
        if (!found)
            return SNMP_ENDOFMIBVIEW;
    } while (mac_multicast(ent.mac));       // Make sure entry is unicast
    // Update indexes (no need to update cid, as it does not change)
    idx = tinfo->indexes->next_variable;
    *(idx->val.integer) = ent.fid;
    idx = idx->next_variable;
    memcpy(idx->val.string, ent.mac, ETH_ALEN);
    // Update OID
    update_oid(req, reginfo, tinfo->colnum, tinfo->indexes);
    // Get next entry column value
    return get_column(req, tinfo->colnum, &ent);
}



/**
 * Handles requests for the ieee8021QBridgeTpFdbTable table
 */
static int ieee8021QBridgeTpFdbTable_handler(
    netsnmp_mib_handler               *handler,
    netsnmp_handler_registration      *reginfo,
    netsnmp_agent_request_info        *reqinfo,
    netsnmp_request_info              *requests)
{
    int err;
    netsnmp_request_info *req;

    switch (reqinfo->mode) {
    case MODE_GET:
        for (req = requests; req; req = req->next) {
            err = get(req);
            if (err)
                netsnmp_set_request_error(reqinfo, req, err);
        }
        break;
    case MODE_GETNEXT:
        for (req = requests; req; req = req->next) {
            err = get_next(req, reginfo);
            if (err)
                netsnmp_set_request_error(reqinfo, req, err);
        }
        break;
    }
    return SNMP_ERR_NOERROR;
}

/**
 * Initialize the ieee8021QBridgeTpFdbTable table by defining its
 * contents and how it's structured
 */
static void initialize_table_ieee8021QBridgeTpFdbTable(void)
{
    const oid ieee8021QBridgeTpFdbTable_oid[] = {1,3,111,2,802,1,1,4,1,2,2};
    netsnmp_handler_registration    *reg;
    netsnmp_table_registration_info *tinfo;

    reg = netsnmp_create_handler_registration(
              "ieee8021QBridgeTpFdbTable",     ieee8021QBridgeTpFdbTable_handler,
              ieee8021QBridgeTpFdbTable_oid, OID_LENGTH(ieee8021QBridgeTpFdbTable_oid),
              HANDLER_CAN_RONLY
              );

    tinfo = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    netsnmp_table_helper_add_indexes(tinfo,
                           ASN_UNSIGNED,  /* index: ComponentId */
                           ASN_UNSIGNED,  /* index: FdbId */
                           ASN_OCTET_STR, /* index: Address */
                           0);

    tinfo->min_column = COLUMN_IEEE8021QBRIDGETPFDBPORT;
    tinfo->max_column = COLUMN_IEEE8021QBRIDGETPFDBSTATUS;

    netsnmp_register_table(reg, tinfo);
}

/**
 * Initializes the ieee8021QBridgeTpFdbTable module
 */
void init_ieee8021QBridgeTpFdbTable(void)
{
    initialize_table_ieee8021QBridgeTpFdbTable();
    rtu_fdb_proxy_create("wrsw_snmpd");
}
