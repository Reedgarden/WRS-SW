/*
 * Note: this file originally auto-generated by mib2c using
 *  : mib2c.raw-table.conf 17436 2009-03-31 15:12:19Z dts12 $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "ieee8021QBridgeVlanStaticTable.h"


/* column number definitions for table ieee8021QBridgeVlanStaticTable */
#define COLUMN_IEEE8021QBRIDGEVLANSTATICCOMPONENTID		1
#define COLUMN_IEEE8021QBRIDGEVLANSTATICVLANINDEX		2
#define COLUMN_IEEE8021QBRIDGEVLANSTATICNAME		3
#define COLUMN_IEEE8021QBRIDGEVLANSTATICEGRESSPORTS		4
#define COLUMN_IEEE8021QBRIDGEVLANFORBIDDENEGRESSPORTS		5
#define COLUMN_IEEE8021QBRIDGEVLANSTATICUNTAGGEDPORTS		6
#define COLUMN_IEEE8021QBRIDGEVLANSTATICROWSTATUS		7

    /* Typical data structure for a row entry */
struct ieee8021QBridgeVlanStaticTable_entry {
    /* Index values */
    u_long ieee8021QBridgeVlanStaticComponentId;
    u_long ieee8021QBridgeVlanStaticVlanIndex;

    /* Column values */
    char ieee8021QBridgeVlanStaticName[NNN];
    size_t ieee8021QBridgeVlanStaticName_len;
    char old_ieee8021QBridgeVlanStaticName[NNN];
    size_t old_ieee8021QBridgeVlanStaticName_len;
    char ieee8021QBridgeVlanStaticEgressPorts[NNN];
    size_t ieee8021QBridgeVlanStaticEgressPorts_len;
    char old_ieee8021QBridgeVlanStaticEgressPorts[NNN];
    size_t old_ieee8021QBridgeVlanStaticEgressPorts_len;
    char ieee8021QBridgeVlanForbiddenEgressPorts[NNN];
    size_t ieee8021QBridgeVlanForbiddenEgressPorts_len;
    char old_ieee8021QBridgeVlanForbiddenEgressPorts[NNN];
    size_t old_ieee8021QBridgeVlanForbiddenEgressPorts_len;
    char ieee8021QBridgeVlanStaticUntaggedPorts[NNN];
    size_t ieee8021QBridgeVlanStaticUntaggedPorts_len;
    char old_ieee8021QBridgeVlanStaticUntaggedPorts[NNN];
    size_t old_ieee8021QBridgeVlanStaticUntaggedPorts_len;
    long ieee8021QBridgeVlanStaticRowStatus;

    int   valid;
};

/* create a new row in the table */
static struct ieee8021QBridgeVlanStaticTable_entry *
ieee8021QBridgeVlanStaticTable_createEntry( int dummy
                 , u_long  ieee8021QBridgeVlanStaticComponentId
                 , u_long  ieee8021QBridgeVlanStaticVlanIndex
                ) {
    struct ieee8021QBridgeVlanStaticTable_entry *entry;

    entry = SNMP_MALLOC_TYPEDEF(struct ieee8021QBridgeVlanStaticTable_entry);
    if (!entry)
        return NULL;

    /* XXX - insert entry into local data structure */
    return entry;
}

/* remove a row from the table */
static void
ieee8021QBridgeVlanStaticTable_removeEntry(struct ieee8021QBridgeVlanStaticTable_entry *entry) {
    if (!entry)
        return;    /* Nothing to remove */

    /* XXX - remove entry from local data structure */

    if (entry)
        SNMP_FREE( entry );   /* XXX - release any other internal resources */
}


/** determine the appropriate row for an exact request */
static struct ieee8021QBridgeVlanStaticTable_entry *
ieee8021QBridgeVlanStaticTable_get_entry( netsnmp_variable_list *indexes ) {
    struct ieee8021QBridgeVlanStaticTable_entry *row = NULL;

    /* XXX - Use the 'indexes' parameter to retrieve the data
       structure for the requested row, and return this. */
    return row;
}

/** determine the appropriate row for an fuzzy request */
static struct ieee8021QBridgeVlanStaticTable_entry *
ieee8021QBridgeVlanStaticTable_get_next_entry( netsnmp_handler_registration *reginfo,
                     netsnmp_request_info         *request,
                     int                           column,
                     netsnmp_variable_list        *indexes ) {
    struct ieee8021QBridgeVlanStaticTable_entry *row = NULL;
    oid             build_space[MAX_OID_LEN];
    size_t          build_space_len = 0;
    size_t          index_oid_len = 0;

    /* XXX - Use the 'indexes' parameter to identify the
             next row in the table.... */

    /* XXX   .... update the 'indexes' parameter with the
             appropriate index values ... */

    /* ... and update the requested OID to match this instance */
    memcpy(build_space, reginfo->rootoid,   /* registered oid */
                        reginfo->rootoid_len * sizeof(oid));
    build_space_len = reginfo->rootoid_len;
    build_space[build_space_len++] = 1;  /* entry */
    build_space[build_space_len++] = column; /* column */
    build_oid_noalloc(build_space + build_space_len,
                      MAX_OID_LEN - build_space_len, &index_oid_len,
                      NULL, 0, indexes);
    snmp_set_var_objid(request->requestvb, build_space,
                       build_space_len + index_oid_len);

    /*  Finally, return the data structure for this row */
    return row;
}


/** handles requests for the ieee8021QBridgeVlanStaticTable table */
static int
ieee8021QBridgeVlanStaticTable_handler(
    netsnmp_mib_handler               *handler,
    netsnmp_handler_registration      *reginfo,
    netsnmp_agent_request_info        *reqinfo,
    netsnmp_request_info              *requests) {

    netsnmp_request_info       *request;
    netsnmp_table_request_info *table_info;
    struct ieee8021QBridgeVlanStaticTable_entry          *table_entry;
    int                         ret;

    switch (reqinfo->mode) {
        /*
         * Read-support
         */
    case MODE_GET:
        for (request=requests; request; request=request->next) {
            table_info  =     netsnmp_extract_table_info( request);
            table_entry =     ieee8021QBridgeVlanStaticTable_get_entry( table_info->indexes );
    
            switch (table_info->colnum) {
            case COLUMN_IEEE8021QBRIDGEVLANSTATICNAME:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                          table_entry->ieee8021QBridgeVlanStaticName,
                                          table_entry->ieee8021QBridgeVlanStaticName_len);
                break;
            case COLUMN_IEEE8021QBRIDGEVLANSTATICEGRESSPORTS:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                          table_entry->ieee8021QBridgeVlanStaticEgressPorts,
                                          table_entry->ieee8021QBridgeVlanStaticEgressPorts_len);
                break;
            case COLUMN_IEEE8021QBRIDGEVLANFORBIDDENEGRESSPORTS:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                          table_entry->ieee8021QBridgeVlanForbiddenEgressPorts,
                                          table_entry->ieee8021QBridgeVlanForbiddenEgressPorts_len);
                break;
            case COLUMN_IEEE8021QBRIDGEVLANSTATICUNTAGGEDPORTS:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                          table_entry->ieee8021QBridgeVlanStaticUntaggedPorts,
                                          table_entry->ieee8021QBridgeVlanStaticUntaggedPorts_len);
                break;
            case COLUMN_IEEE8021QBRIDGEVLANSTATICROWSTATUS:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->ieee8021QBridgeVlanStaticRowStatus);
                break;
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHOBJECT);
                break;
            }
        }
        break;

    case MODE_GETNEXT:
        for (request=requests; request; request=request->next) {
            table_info  =     netsnmp_extract_table_info( request);
            table_entry =     ieee8021QBridgeVlanStaticTable_get_next_entry( reginfo, request,
                                   table_info->colnum, table_info->indexes );
    
            switch (table_info->colnum) {
            case COLUMN_IEEE8021QBRIDGEVLANSTATICNAME:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                          table_entry->ieee8021QBridgeVlanStaticName,
                                          table_entry->ieee8021QBridgeVlanStaticName_len);
                break;
            case COLUMN_IEEE8021QBRIDGEVLANSTATICEGRESSPORTS:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                          table_entry->ieee8021QBridgeVlanStaticEgressPorts,
                                          table_entry->ieee8021QBridgeVlanStaticEgressPorts_len);
                break;
            case COLUMN_IEEE8021QBRIDGEVLANFORBIDDENEGRESSPORTS:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                          table_entry->ieee8021QBridgeVlanForbiddenEgressPorts,
                                          table_entry->ieee8021QBridgeVlanForbiddenEgressPorts_len);
                break;
            case COLUMN_IEEE8021QBRIDGEVLANSTATICUNTAGGEDPORTS:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_value( request->requestvb, ASN_OCTET_STR,
                                          table_entry->ieee8021QBridgeVlanStaticUntaggedPorts,
                                          table_entry->ieee8021QBridgeVlanStaticUntaggedPorts_len);
                break;
            case COLUMN_IEEE8021QBRIDGEVLANSTATICROWSTATUS:
                if ( !table_entry ) {
                    netsnmp_set_request_error(reqinfo, request,
                                              SNMP_NOSUCHINSTANCE);
                    continue;
                }
                snmp_set_var_typed_integer( request->requestvb, ASN_INTEGER,
                                            table_entry->ieee8021QBridgeVlanStaticRowStatus);
                break;
            default:
                netsnmp_set_request_error(reqinfo, request,
                                          SNMP_NOSUCHOBJECT);
                break;
            }
        }
        break;

        /*
         * Write-support
         */
    case MODE_SET_RESERVE1:
        for (request=requests; request; request=request->next) {
            table_info  =     netsnmp_extract_table_info( request);
            table_entry =     ieee8021QBridgeVlanStaticTable_get_entry( table_info->indexes );
    
            switch (table_info->colnum) {
            case COLUMN_IEEE8021QBRIDGEVLANSTATICNAME:
	        /* or possibly 'netsnmp_check_vb_type_and_size' */
                ret = netsnmp_check_vb_type_and_max_size(
                          request->requestvb, ASN_OCTET_STR, sizeof(table_entry->ieee8021QBridgeVlanStaticName));
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_IEEE8021QBRIDGEVLANSTATICEGRESSPORTS:
	        /* or possibly 'netsnmp_check_vb_type_and_size' */
                ret = netsnmp_check_vb_type_and_max_size(
                          request->requestvb, ASN_OCTET_STR, sizeof(table_entry->ieee8021QBridgeVlanStaticEgressPorts));
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_IEEE8021QBRIDGEVLANFORBIDDENEGRESSPORTS:
	        /* or possibly 'netsnmp_check_vb_type_and_size' */
                ret = netsnmp_check_vb_type_and_max_size(
                          request->requestvb, ASN_OCTET_STR, sizeof(table_entry->ieee8021QBridgeVlanForbiddenEgressPorts));
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_IEEE8021QBRIDGEVLANSTATICUNTAGGEDPORTS:
	        /* or possibly 'netsnmp_check_vb_type_and_size' */
                ret = netsnmp_check_vb_type_and_max_size(
                          request->requestvb, ASN_OCTET_STR, sizeof(table_entry->ieee8021QBridgeVlanStaticUntaggedPorts));
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
            case COLUMN_IEEE8021QBRIDGEVLANSTATICROWSTATUS:
                ret = netsnmp_check_vb_rowstatus(request->requestvb,
                         (table_entry ? RS_ACTIVE : RS_NONEXISTENT ));
                if ( ret != SNMP_ERR_NOERROR ) {
                    netsnmp_set_request_error( reqinfo, request, ret );
                    return SNMP_ERR_NOERROR;
                }
                break;
            default:
                netsnmp_set_request_error( reqinfo, request,
                                           SNMP_ERR_NOTWRITABLE );
                return SNMP_ERR_NOERROR;
            }
        }
        break;

    case MODE_SET_RESERVE2:
        for (request=requests; request; request=request->next) {
            table_info = netsnmp_extract_table_info( request);
            table_entry =     ieee8021QBridgeVlanStaticTable_get_entry( table_info->indexes );
    
            switch (table_info->colnum) {
            case COLUMN_IEEE8021QBRIDGEVLANSTATICROWSTATUS:
                switch (*request->requestvb->val.integer) {
                case RS_CREATEANDGO:
                case RS_CREATEANDWAIT:
                    table_entry = ieee8021QBridgeVlanStaticTable_createEntry( 0
                        , *table_info->indexes->val.integer
                        , *table_info->indexes->val.integer
                        );
                    if ( !table_entry ) {
                        netsnmp_set_request_error( reqinfo, request,
                                                   SNMP_ERR_RESOURCEUNAVAILABLE );
                        return SNMP_ERR_NOERROR;
                    }
                }
            }
        }
        break;

    case MODE_SET_FREE:
        for (request=requests; request; request=request->next) {
            table_info  =     netsnmp_extract_table_info( request);
            table_entry =     ieee8021QBridgeVlanStaticTable_get_entry( table_info->indexes );
    
            switch (table_info->colnum) {
            case COLUMN_IEEE8021QBRIDGEVLANSTATICROWSTATUS:
                switch (*request->requestvb->val.integer) {
                case RS_CREATEANDGO:
                case RS_CREATEANDWAIT:
                    if (table_entry && !table_entry->valid) {
                        ieee8021QBridgeVlanStaticTable_removeEntry(table_entry);
                    }
                }
            }
        }
        break;

    case MODE_SET_ACTION:
        for (request=requests; request; request=request->next) {
            table_info  =     netsnmp_extract_table_info( request);
            table_entry =     ieee8021QBridgeVlanStaticTable_get_entry( table_info->indexes );
    
            switch (table_info->colnum) {
            case COLUMN_IEEE8021QBRIDGEVLANSTATICNAME:
                memcpy( table_entry->old_ieee8021QBridgeVlanStaticName,
                        table_entry->ieee8021QBridgeVlanStaticName,
                        sizeof(table_entry->ieee8021QBridgeVlanStaticName));
                table_entry->old_ieee8021QBridgeVlanStaticName_len =
                        table_entry->ieee8021QBridgeVlanStaticName_len;
                memset( table_entry->ieee8021QBridgeVlanStaticName, 0,
                        sizeof(table_entry->ieee8021QBridgeVlanStaticName));
                memcpy( table_entry->ieee8021QBridgeVlanStaticName,
                        request->requestvb->val.string,
                        request->requestvb->val_len);
                table_entry->ieee8021QBridgeVlanStaticName_len =
                        request->requestvb->val_len;
                break;
            case COLUMN_IEEE8021QBRIDGEVLANSTATICEGRESSPORTS:
                memcpy( table_entry->old_ieee8021QBridgeVlanStaticEgressPorts,
                        table_entry->ieee8021QBridgeVlanStaticEgressPorts,
                        sizeof(table_entry->ieee8021QBridgeVlanStaticEgressPorts));
                table_entry->old_ieee8021QBridgeVlanStaticEgressPorts_len =
                        table_entry->ieee8021QBridgeVlanStaticEgressPorts_len;
                memset( table_entry->ieee8021QBridgeVlanStaticEgressPorts, 0,
                        sizeof(table_entry->ieee8021QBridgeVlanStaticEgressPorts));
                memcpy( table_entry->ieee8021QBridgeVlanStaticEgressPorts,
                        request->requestvb->val.string,
                        request->requestvb->val_len);
                table_entry->ieee8021QBridgeVlanStaticEgressPorts_len =
                        request->requestvb->val_len;
                break;
            case COLUMN_IEEE8021QBRIDGEVLANFORBIDDENEGRESSPORTS:
                memcpy( table_entry->old_ieee8021QBridgeVlanForbiddenEgressPorts,
                        table_entry->ieee8021QBridgeVlanForbiddenEgressPorts,
                        sizeof(table_entry->ieee8021QBridgeVlanForbiddenEgressPorts));
                table_entry->old_ieee8021QBridgeVlanForbiddenEgressPorts_len =
                        table_entry->ieee8021QBridgeVlanForbiddenEgressPorts_len;
                memset( table_entry->ieee8021QBridgeVlanForbiddenEgressPorts, 0,
                        sizeof(table_entry->ieee8021QBridgeVlanForbiddenEgressPorts));
                memcpy( table_entry->ieee8021QBridgeVlanForbiddenEgressPorts,
                        request->requestvb->val.string,
                        request->requestvb->val_len);
                table_entry->ieee8021QBridgeVlanForbiddenEgressPorts_len =
                        request->requestvb->val_len;
                break;
            case COLUMN_IEEE8021QBRIDGEVLANSTATICUNTAGGEDPORTS:
                memcpy( table_entry->old_ieee8021QBridgeVlanStaticUntaggedPorts,
                        table_entry->ieee8021QBridgeVlanStaticUntaggedPorts,
                        sizeof(table_entry->ieee8021QBridgeVlanStaticUntaggedPorts));
                table_entry->old_ieee8021QBridgeVlanStaticUntaggedPorts_len =
                        table_entry->ieee8021QBridgeVlanStaticUntaggedPorts_len;
                memset( table_entry->ieee8021QBridgeVlanStaticUntaggedPorts, 0,
                        sizeof(table_entry->ieee8021QBridgeVlanStaticUntaggedPorts));
                memcpy( table_entry->ieee8021QBridgeVlanStaticUntaggedPorts,
                        request->requestvb->val.string,
                        request->requestvb->val_len);
                table_entry->ieee8021QBridgeVlanStaticUntaggedPorts_len =
                        request->requestvb->val_len;
                break;
            }
        }
        /* Check the internal consistency of an active row */
        for (request=requests; request; request=request->next) {
            table_info  =     netsnmp_extract_table_info( request);
            table_entry =     ieee8021QBridgeVlanStaticTable_get_entry( table_info->indexes );
    
            switch (table_info->colnum) {
            case COLUMN_IEEE8021QBRIDGEVLANSTATICROWSTATUS:
                switch (*request->requestvb->val.integer) {
                case RS_ACTIVE:
                case RS_CREATEANDGO:
                    if (/* XXX */) {
                        netsnmp_set_request_error( reqinfo, request,
                                                   SNMP_ERR_INCONSISTENTVALUE );
                        return SNMP_ERR_NOERROR;
                    }
                }
            }
        }
        break;

    case MODE_SET_UNDO:
        for (request=requests; request; request=request->next) {
            table_info  =     netsnmp_extract_table_info( request);
            table_entry =     ieee8021QBridgeVlanStaticTable_get_entry( table_info->indexes );
    
            switch (table_info->colnum) {
            case COLUMN_IEEE8021QBRIDGEVLANSTATICNAME:
                memcpy( table_entry->ieee8021QBridgeVlanStaticName,
                        table_entry->old_ieee8021QBridgeVlanStaticName,
                        sizeof(table_entry->ieee8021QBridgeVlanStaticName));
                memset( table_entry->old_ieee8021QBridgeVlanStaticName, 0,
                        sizeof(table_entry->ieee8021QBridgeVlanStaticName));
                table_entry->ieee8021QBridgeVlanStaticName_len =
                        table_entry->old_ieee8021QBridgeVlanStaticName_len;
                break;
            case COLUMN_IEEE8021QBRIDGEVLANSTATICEGRESSPORTS:
                memcpy( table_entry->ieee8021QBridgeVlanStaticEgressPorts,
                        table_entry->old_ieee8021QBridgeVlanStaticEgressPorts,
                        sizeof(table_entry->ieee8021QBridgeVlanStaticEgressPorts));
                memset( table_entry->old_ieee8021QBridgeVlanStaticEgressPorts, 0,
                        sizeof(table_entry->ieee8021QBridgeVlanStaticEgressPorts));
                table_entry->ieee8021QBridgeVlanStaticEgressPorts_len =
                        table_entry->old_ieee8021QBridgeVlanStaticEgressPorts_len;
                break;
            case COLUMN_IEEE8021QBRIDGEVLANFORBIDDENEGRESSPORTS:
                memcpy( table_entry->ieee8021QBridgeVlanForbiddenEgressPorts,
                        table_entry->old_ieee8021QBridgeVlanForbiddenEgressPorts,
                        sizeof(table_entry->ieee8021QBridgeVlanForbiddenEgressPorts));
                memset( table_entry->old_ieee8021QBridgeVlanForbiddenEgressPorts, 0,
                        sizeof(table_entry->ieee8021QBridgeVlanForbiddenEgressPorts));
                table_entry->ieee8021QBridgeVlanForbiddenEgressPorts_len =
                        table_entry->old_ieee8021QBridgeVlanForbiddenEgressPorts_len;
                break;
            case COLUMN_IEEE8021QBRIDGEVLANSTATICUNTAGGEDPORTS:
                memcpy( table_entry->ieee8021QBridgeVlanStaticUntaggedPorts,
                        table_entry->old_ieee8021QBridgeVlanStaticUntaggedPorts,
                        sizeof(table_entry->ieee8021QBridgeVlanStaticUntaggedPorts));
                memset( table_entry->old_ieee8021QBridgeVlanStaticUntaggedPorts, 0,
                        sizeof(table_entry->ieee8021QBridgeVlanStaticUntaggedPorts));
                table_entry->ieee8021QBridgeVlanStaticUntaggedPorts_len =
                        table_entry->old_ieee8021QBridgeVlanStaticUntaggedPorts_len;
                break;
            case COLUMN_IEEE8021QBRIDGEVLANSTATICROWSTATUS:
                switch (*request->requestvb->val.integer) {
                case RS_CREATEANDGO:
                case RS_CREATEANDWAIT:
                    if (table_entry && !table_entry->valid) {
                        ieee8021QBridgeVlanStaticTable_removeEntry(table_entry);
                    }
                }
                break;
            }
        }
        break;

    case MODE_SET_COMMIT:
        for (request=requests; request; request=request->next) {
            table_info  =     netsnmp_extract_table_info(    request);
            table_entry =     ieee8021QBridgeVlanStaticTable_get_entry( table_info->indexes );
    
            switch (table_info->colnum) {
            case COLUMN_IEEE8021QBRIDGEVLANSTATICROWSTATUS:
                switch (*request->requestvb->val.integer) {
                case RS_CREATEANDGO:
                    table_entry->valid = 1;
                    /* Fall-through */
                case RS_ACTIVE:
                    table_entry->ieee8021QBridgeVlanStaticRowStatus = RS_ACTIVE;
                    break;

                case RS_CREATEANDWAIT:
                    table_entry->valid = 1;
                    /* Fall-through */
                case RS_NOTINSERVICE:
                    table_entry->ieee8021QBridgeVlanStaticRowStatus = RS_NOTINSERVICE;
                    break;

                case RS_DESTROY:
                    ieee8021QBridgeVlanStaticTable_removeEntry(table_entry);
                }
            }
        }
        break;
    }
    return SNMP_ERR_NOERROR;
}

/** Initialize the ieee8021QBridgeVlanStaticTable table by defining its contents and how it's structured */
static void
initialize_table_ieee8021QBridgeVlanStaticTable(void)
{
    const oid ieee8021QBridgeVlanStaticTable_oid[] = {1,3,111,2,802,1,1,4,1,4,3};
    netsnmp_handler_registration    *reg;
    netsnmp_table_registration_info *table_info;

    reg = netsnmp_create_handler_registration(
              "ieee8021QBridgeVlanStaticTable",     ieee8021QBridgeVlanStaticTable_handler,
              ieee8021QBridgeVlanStaticTable_oid, OID_LENGTH(ieee8021QBridgeVlanStaticTable_oid),
              HANDLER_CAN_RWRITE
              );

    table_info = SNMP_MALLOC_TYPEDEF( netsnmp_table_registration_info );
    netsnmp_table_helper_add_indexes(table_info,
                           ASN_UNSIGNED,  /* index: ieee8021QBridgeVlanStaticComponentId */
                           ASN_UNSIGNED,  /* index: ieee8021QBridgeVlanStaticVlanIndex */
                           0);

    table_info->min_column = COLUMN_IEEE8021QBRIDGEVLANSTATICNAME;
    table_info->max_column = COLUMN_IEEE8021QBRIDGEVLANSTATICROWSTATUS;

    netsnmp_register_table( reg, table_info );

    /* Initialise the contents of the table here */
}

/** Initializes the ieee8021QBridgeVlanStaticTable module */
void
init_ieee8021QBridgeVlanStaticTable(void)
{
  /* here we initialize all the tables we're planning on supporting */
    initialize_table_ieee8021QBridgeVlanStaticTable();
}
