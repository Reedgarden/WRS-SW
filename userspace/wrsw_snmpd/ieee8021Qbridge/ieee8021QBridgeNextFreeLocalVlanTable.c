/*
 * White Rabbit Switch Management
 * Copyright (C) 2010, CERN.
 *
 * Version:     wrsw_snmpd v1.0
 *
 * Authors:     Juan Luis Manas (juan.manas@integrasys.es)
 *
 * Description: Handles requests for ieee8021QBridgeNextFreeLocalVlanTable table.
 *              Used to report next free VLAN index
 *              Note: this file originally auto-generated by mib2c using
 *              : mib2c.raw-table.conf 17436 2009-03-31 15:12:19Z dts12 $
 *
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version
 * 2 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

#include "ieee8021QBridgeNextFreeLocalVlanTable.h"

/* column number definitions for table ieee8021QBridgeNextFreeLocalVlanTable */
#define COLUMN_IEEE8021QBRIDGENEXTFREELOCALVLANCOMPONENTID		1
#define COLUMN_IEEE8021QBRIDGENEXTFREELOCALVLANINDEX		    2

#define DEFAULT_COMPONENT_ID                                    1

static int get(netsnmp_request_info *req)
{
    int cid;
    netsnmp_table_request_info *tinfo;
    netsnmp_variable_list *idx;

    // Get indexes
    tinfo = netsnmp_extract_table_info(req);
    idx = tinfo->indexes;
    cid = *(idx->val.integer);

    snmp_log(LOG_DEBUG,
        "ieee8021QBridgeNextFreeLocalVlanTable: get cid=%d column=%d.\n",
        cid, tinfo->colnum);

    if (cid != DEFAULT_COMPONENT_ID)
        return SNMP_NOSUCHINSTANCE;
    // Get column value
    switch (tinfo->colnum) {
    case COLUMN_IEEE8021QBRIDGENEXTFREELOCALVLANINDEX:
        // Creating a new local VLAN is not supported (next free index = 0)
        snmp_set_var_typed_integer( req->requestvb, ASN_UNSIGNED, 0);
        break;
    default:
        return SNMP_NOSUCHOBJECT;
    }
    return 0;
}

/**
 * Handles requests for the ieee8021QBridgeNextFreeLocalVlanTable table
 */
static int ieee8021QBridgeNextFreeLocalVlanTable_handler(
    netsnmp_mib_handler               *handler,
    netsnmp_handler_registration      *reginfo,
    netsnmp_agent_request_info        *reqinfo,
    netsnmp_request_info              *requests)
{
    int err;
    netsnmp_request_info       *req;

    switch (reqinfo->mode) {
    case MODE_GET:
        for (req = requests; req; req = req->next) {
            err = get(req);
            if (err)
                netsnmp_set_request_error(reqinfo, req, err);
        }
        break;
    case MODE_GETNEXT:
        // Single bridge means single row...
        for (req = requests; req; req = req->next)
            netsnmp_set_request_error(reqinfo, req, SNMP_ENDOFMIBVIEW);
        break;
    }
    return SNMP_ERR_NOERROR;
}

/**
 * Initialize the ieee8021QBridgeNextFreeLocalVlanTable table by defining its
 * contents and how it's structured
 */
static void initialize_table_ieee8021QBridgeNextFreeLocalVlanTable(void)
{
    const oid ieee8021QBridgeNextFreeLocalVlanTable_oid[] = {1,3,111,2,802,1,1,4,1,4,4};
    netsnmp_handler_registration    *reg;
    netsnmp_table_registration_info *tinfo;

    reg = netsnmp_create_handler_registration(
              "ieee8021QBridgeNextFreeLocalVlanTable",
              ieee8021QBridgeNextFreeLocalVlanTable_handler,
              (oid *)ieee8021QBridgeNextFreeLocalVlanTable_oid,
              OID_LENGTH(ieee8021QBridgeNextFreeLocalVlanTable_oid),
              HANDLER_CAN_RONLY);

    tinfo = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
    netsnmp_table_helper_add_indexes(
        tinfo,
        ASN_UNSIGNED,  /* index: ComponentId */
        0);

    tinfo->min_column = COLUMN_IEEE8021QBRIDGENEXTFREELOCALVLANINDEX;
    tinfo->max_column = COLUMN_IEEE8021QBRIDGENEXTFREELOCALVLANINDEX;

    netsnmp_register_table(reg, tinfo);
}

/**
 * Initializes the ieee8021QBridgeNextFreeLocalVlanTable module
 */
void init_ieee8021QBridgeNextFreeLocalVlanTable(void)
{
    initialize_table_ieee8021QBridgeNextFreeLocalVlanTable();
    snmp_log(LOG_INFO,"ieee8021QBridgeNextFreeLocalVlanTable: initialised\n");
}
