/*
 * White Rabbit Switch Management
 * Copyright (C) 2010, CERN.
 *
 * Version:     wrsw_snmpd v1.0
 *
 * Authors:     Juan Luis Manas (juan.manas@integrasys.es)
 *
 * Description: Handles requests for ieee8021QBridgeTable table.
 *              Provides generic information about a VLAN-aware bridge.
 *              Note: this file originally auto-generated by mib2c using
 *              : mib2c.raw-table.conf 17436 2009-03-31 15:12:19Z dts12 $
 *
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version
 * 2 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

#include "ieee8021QBridgeTable.h"
#include "rtu_fd_proxy.h"
#include "mvrp_proxy.h"
#include "utils.h"

#define MIBMOD  "8021Q"

/* column number definitions for table ieee8021QBridgeTable */
#define COLUMN_IEEE8021QBRIDGECOMPONENTID		    1
#define COLUMN_IEEE8021QBRIDGEVLANVERSIONNUMBER		2
#define COLUMN_IEEE8021QBRIDGEMAXVLANID		        3
#define COLUMN_IEEE8021QBRIDGEMAXSUPPORTEDVLANS		4
#define COLUMN_IEEE8021QBRIDGENUMVLANS		        5
#define COLUMN_IEEE8021QBRIDGEMVRPENABLEDSTATUS		6

static int get_column(netsnmp_variable_list *vb, int colnum)
{
    long ver;       // ieee8021QBridgeVlanVersionNumber;
    long mvid;      // ieee8021QBridgeMaxVlanId;
    u_long mvlans;  // ieee8021QBridgeMaxSupportedVlans;
    u_long vlans;   // ieee8021QBridgeNumVlans;
    int enabled;    // ieee8021QBridgeMvrpEnabledStatus;

    errno = 0;
    switch (colnum) {
    case COLUMN_IEEE8021QBRIDGEVLANVERSIONNUMBER:
        // TODO get value from STP daemon. Meanwhile, value 1 means Single STP
        ver = 1;
        snmp_set_var_typed_integer(vb, ASN_INTEGER, ver);
        break;
    case COLUMN_IEEE8021QBRIDGEMAXVLANID:
        mvid = rtu_fdb_proxy_get_max_vid();
        if (errno)
            goto minipc_err;
        snmp_set_var_typed_integer(vb, ASN_INTEGER, mvid);
        break;
    case COLUMN_IEEE8021QBRIDGEMAXSUPPORTEDVLANS:
        mvlans = rtu_fdb_proxy_get_max_supported_vlans();
        if (errno)
            goto minipc_err;
        snmp_set_var_typed_integer(vb, ASN_UNSIGNED, mvlans);
        break;
    case COLUMN_IEEE8021QBRIDGENUMVLANS:
        vlans = rtu_fdb_proxy_get_num_vlans();
        if (errno)
            goto minipc_err;
        snmp_set_var_typed_integer(vb, ASN_GAUGE, vlans);
        break;
    case COLUMN_IEEE8021QBRIDGEMVRPENABLEDSTATUS:
        enabled = mvrp_proxy_is_enabled();
        if (errno)
            goto minipc_err;
        snmp_set_var_typed_integer(vb, ASN_INTEGER, enabled ? TV_TRUE:TV_FALSE);
        break;
    default:
        return SNMP_NOSUCHOBJECT;
    }
    return SNMP_ERR_NOERROR;

minipc_err:
    snmp_log(LOG_ERR, "%s(%s): mini-ipc error [%s]\n", __FILE__, __func__,
        strerror(errno));
    return SNMP_ERR_GENERR;
}


static int get(netsnmp_request_info *req)
{
    netsnmp_table_request_info  *tinfo;
    u_long cid;     // ieee8021QBridgeComponentId

    // Get indexes from request
    tinfo = netsnmp_extract_table_info(req);
    if (!tinfo || !tinfo->indexes)
        return SNMP_ERR_GENERR;

    cid = *tinfo->indexes->val.integer;

    DEBUGMSGTL((MIBMOD, "cid=%d column=%d\n", cid, tinfo->colnum));

    if (cid != DEFAULT_COMPONENT_ID)
        return SNMP_NOSUCHINSTANCE;

    // return entry column value
    return get_column(req->requestvb, tinfo->colnum);
}

static int get_next(netsnmp_request_info         *req,
                    netsnmp_handler_registration *reginfo)
{
    int err;
    u_long cid;
    int oid_len, rootoid_len;
    netsnmp_table_request_info  *tinfo = netsnmp_extract_table_info(req);

    // Get indexes from request - in case OID contains them!.
    // Otherwise use default values for first row.
    oid_len     = req->requestvb->name_length;
    rootoid_len = reginfo->rootoid_len;

    if (oid_len > rootoid_len) {
        if (!tinfo || !tinfo->indexes)
            return SNMP_ERR_GENERR;
        cid = *tinfo->indexes->val.integer;
    } else {
        cid = 0;
    }

    DEBUGMSGTL((MIBMOD, "cid=%d column=%d\n", cid, tinfo->colnum));

    // Get index for next entry - SNMP_ENDOFMIBVIEW informs the handler
    // to proceed with next column.
    if (cid >= DEFAULT_COMPONENT_ID)
        return SNMP_ENDOFMIBVIEW;
    if (cid == 0)
        cid = DEFAULT_COMPONENT_ID;

    // Update indexes and OID returned in SNMP response
    *tinfo->indexes->val.integer = cid;
    update_oid(req, reginfo, tinfo->colnum, tinfo->indexes);

    // return next entry column value
    return get_column(req->requestvb, tinfo->colnum);
}

/**
 * handles requests for the ieee8021QBridgeTable table
 */
static int _handler(netsnmp_mib_handler          *handler,
                    netsnmp_handler_registration *reginfo,
                    netsnmp_agent_request_info   *reqinfo,
                    netsnmp_request_info         *requests)
{
    int err;
    netsnmp_request_info        *req;
    netsnmp_table_request_info  *tinfo;

    switch (reqinfo->mode) {
    case MODE_GET:
        for (req = requests; req; req = req->next) {
            err = get(req);
            if (err)
                netsnmp_set_request_error(reqinfo, req, err);
        }
        break;
    case MODE_GETNEXT:
        for (req = requests; req; req = req->next) {
            err = get_next(req, reginfo);
            if (err)
                netsnmp_set_request_error(reqinfo, req, err);
        }
        break;
    case MODE_SET_RESERVE1:
        for (req = requests; req; req = req->next) {
            tinfo = netsnmp_extract_table_info(req);
            switch (tinfo->colnum) {
            case COLUMN_IEEE8021QBRIDGEMVRPENABLEDSTATUS:
                err = netsnmp_check_vb_truthvalue(req->requestvb);
                if (err)
                    netsnmp_set_request_error(reqinfo, req, err);
                break;
            default:
                netsnmp_set_request_error(reqinfo, req, SNMP_ERR_NOTWRITABLE);
            }
        }
        break;
    case MODE_SET_COMMIT:
        for (req = requests; req; req = req->next) {
            tinfo = netsnmp_extract_table_info(req);
            switch (tinfo->colnum) {
            case COLUMN_IEEE8021QBRIDGEMVRPENABLEDSTATUS:
                if (*req->requestvb->val.integer == TV_TRUE)
                    mvrp_proxy_enable();
                else
                    mvrp_proxy_disable();
                if (errno)
                    netsnmp_set_request_error(reqinfo, req, SNMP_ERR_GENERR);
                break;
            default:
                netsnmp_set_request_error(reqinfo, req, SNMP_ERR_NOTWRITABLE);
            }
        }
        break;
    }
    return SNMP_ERR_NOERROR;
}

/**
 * Initialize the ieee8021QBridgeTable table by defining its contents and
 * how it's structured
 */
static void initialize_table(void)
{
    const oid _oid[] = {1,3,111,2,802,1,1,4,1,1,1};
    netsnmp_handler_registration    *reg;
    netsnmp_table_registration_info *tinfo;

    reg = netsnmp_create_handler_registration(
            "ieee8021QBridgeTable",
            _handler,
            (oid *)_oid,
            OID_LENGTH(_oid),
            HANDLER_CAN_RWRITE);

    tinfo = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);

    netsnmp_table_helper_add_indexes(
            tinfo,
            ASN_UNSIGNED, /* index: ieee8021QBridgeComponentId */
            0);

    tinfo->min_column = COLUMN_IEEE8021QBRIDGEVLANVERSIONNUMBER;
    tinfo->max_column = COLUMN_IEEE8021QBRIDGEMVRPENABLEDSTATUS;

    netsnmp_register_table(reg, tinfo);
}

/**
 * Initializes the ieee8021QBridgeTable module
 */
void init_ieee8021QBridgeTable(void)
{
    struct minipc_ch *client;
    struct minipc_ch *mvrp_client;

    client = rtu_fdb_proxy_create("rtu_fdb");
    if (!client) {
        snmp_log(LOG_ERR, "%s: error creating mini-ipc proxy - %s\n", __FILE__,
            strerror(errno));
        return;
    }

    mvrp_client = mvrp_proxy_create("mvrp");
    if (!mvrp_client) {
        snmp_log(LOG_ERR, "%s: error creating mini-ipc proxy - %s\n", __FILE__,
            strerror(errno));
        return;
    }

    initialize_table();
    snmp_log(LOG_INFO, "%s: initialised\n", __FILE__);
}
