/*
 * White Rabbit Switch Management
 * Copyright (C) 2010, CERN.
 *
 * Version:     wrsw_snmpd v1.0
 *
 * Authors:     Juan Luis Manas (juan.manas@integrasys.es)
 *
 * Description: Handles requests for ieee8021QBridgeStaticUnicastTable table.
 *              Provides support for inserting/deleting static unicast
 *              entries into the RTU filtering database
 *              Note: this file originally auto-generated by mib2c using
 *              : mib2c.raw-table.conf 17436 2009-03-31 15:12:19Z dts12 $
 *
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version
 * 2 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "ieee8021QBridgeStaticUnicastTable.h"

#include "rtu_fd_proxy.h"
#include "mac.h"

/* column number definitions for table ieee8021QBridgeStaticUnicastTable */
#define COLUMN_IEEE8021QBRIDGESTATICUNICASTCOMPONENTID              1
#define COLUMN_IEEE8021QBRIDGESTATICUNICASTVLANINDEX                2
#define COLUMN_IEEE8021QBRIDGESTATICUNICASTADDRESS                  3
#define COLUMN_IEEE8021QBRIDGESTATICUNICASTRECEIVEPORT              4
#define COLUMN_IEEE8021QBRIDGESTATICUNICASTSTATICEGRESSPORTS        5
#define COLUMN_IEEE8021QBRIDGESTATICUNICASTFORBIDDENEGRESSPORTS     6
#define COLUMN_IEEE8021QBRIDGESTATICUNICASTSTORAGETYPE              7
#define COLUMN_IEEE8021QBRIDGESTATICUNICASTROWSTATUS                8

#define DEFAULT_COMPONENT_ID                                        1
#define ALL_PORTS                                                   0

#define CURR_ENT                                                    0
#define NEXT_ENT                                                    1

// Row entry
struct ieee8021QBridgeStaticUnicastTable_entry {
    // indexes
    u_long cid;
    uint16_t vid;
    uint8_t  mac[ETH_ALEN];
    u_long rx_port;
    // Columns
    enum filtering_control port_map[NUM_PORTS];
    char egress_ports[NUM_PORTS];
    char forbidden_egress_ports[NUM_PORTS];
    enum storage_type type;
    int  row_status;

    struct ieee8021QBridgeStaticUnicastTable_entry *next;
    netsnmp_request_info *req; // associated SNMP request
};

/**
 * Stores information related to SET actions that must be handled atomically
 */
static struct ieee8021QBridgeStaticUnicastTable_entry *cache = NULL;

static inline int active(int row_status)
{
    return ((row_status == RS_ACTIVE) || (row_status == RS_CREATEANDGO));
}

/**
 * Compute port map from egress ports and forbidden egress ports
 */
static void calculate_port_map(
    struct ieee8021QBridgeStaticUnicastTable_entry *ent)
{
    int i;

    for(i = 0; i < NUM_PORTS; i++) {
        if (ent->egress_ports[i] == 1)
            ent->port_map[i] = Forward;
        else if (ent->forbidden_egress_ports[i] == 1)
            ent->port_map[i] = Filter;
        else
            ent->port_map[i] = Dynamic;
    }
}

/**
 * Create a new row in the cache table
 */
static struct ieee8021QBridgeStaticUnicastTable_entry *create_entry(
    u_long  cid,
    u_long  vid,
    char *mac,
    u_long  rx_port)
{
    struct ieee8021QBridgeStaticUnicastTable_entry *ent;

    ent = SNMP_MALLOC_TYPEDEF(struct ieee8021QBridgeStaticUnicastTable_entry);
    if (!ent)
        return NULL;

    ent->cid = cid;
    ent->vid = vid;
    mac_copy(ent->mac, mac);
    ent->rx_port = rx_port;

    memset(ent->port_map, 0, NUM_PORTS);
    memset(ent->egress_ports, 0, NUM_PORTS);
    memset(ent->forbidden_egress_ports, 0, NUM_PORTS);

    ent->type       = Other;
    ent->row_status = RS_NOTINSERVICE;

    // insert entry in table
    ent->next = cache;
    cache     = ent;

    return ent;
}

/**
 * Remove all entries from cache.
 */
static void clean_cache()
{
    struct ieee8021QBridgeStaticUnicastTable_entry *ptr;

    while(cache) {
        ptr = cache;
        cache = cache->next;
        SNMP_FREE(ptr);
    }
}

/**
 * Determine the appropriate row for an exact request
 */
static struct ieee8021QBridgeStaticUnicastTable_entry *get_entry(
    struct ieee8021QBridgeStaticUnicastTable_entry *indexes)
{
    struct ieee8021QBridgeStaticUnicastTable_entry *ent;

    for (ent = cache; ent; ent = ent->next)
        if ((ent->vid == indexes->vid) && mac_equal(ent->mac, indexes->mac))
            return ent;
    return NULL;
}

/**
 * Update the requested OID to match this instance
 */
static void update_oid(
    netsnmp_request_info           *req,
    netsnmp_handler_registration   *reginfo,
    int                            column,
    netsnmp_variable_list          *indexes)
{
    oid    build_space[MAX_OID_LEN];
    size_t build_space_len = 0;
    size_t index_oid_len = 0;

    memcpy(build_space, reginfo->rootoid,       /* registered oid */
                        reginfo->rootoid_len * sizeof(oid));
    build_space_len = reginfo->rootoid_len;
    build_space[build_space_len++] = 1;         /* entry */
    build_space[build_space_len++] = column;    /* column */
    build_oid_noalloc(build_space + build_space_len,
                      MAX_OID_LEN - build_space_len, &index_oid_len,
                      NULL, 0, indexes);
    snmp_set_var_objid(req->requestvb, build_space,
                       build_space_len + index_oid_len);
}

/**
 * Get indexes for an entry.
 * @param tinfo table information that contains the indexes (in raw format)
 * @param ent (OUT) used to return the retrieved indexes
 * @return SNMP_ERR_NOERROR if indexes are valid. SNMP_NOSUCHINSTANCE in case
 * any of the indexes is not valid.
 */
static int get_indexes(netsnmp_table_request_info *tinfo,
    struct ieee8021QBridgeStaticUnicastTable_entry *ent)
{
    netsnmp_variable_list *idx = tinfo->indexes;

    ent->cid = *(idx->val.integer);
    idx = idx->next_variable;
    ent->vid = *(idx->val.integer);
    idx = idx->next_variable;
    memcpy(ent->mac, idx->val.string, idx->val_len);
    idx = idx->next_variable;
    ent->rx_port = *(idx->val.integer);
    if ((ent->cid != DEFAULT_COMPONENT_ID) || (ent->vid >= NUM_VLANS) ||
        (ent->rx_port != ALL_PORTS))
        return SNMP_NOSUCHINSTANCE;
    return SNMP_ERR_NOERROR;
}

/**
 * Cache entry in agent memory. The ent parameter must have its indexes already
 * set by callee. The method fills the rest of parameters with data from
 * actual FDB.
 * @param next 1 = cache next entry.
 */
static int cache_entry(
    struct ieee8021QBridgeStaticUnicastTable_entry *ent,
    int next)
{
    int found, i;

    errno = 0;
    found = next ?
            (rtu_fdb_proxy_read_next_static_entry(&(ent->mac), &(ent->vid),
                &(ent->port_map), &(ent->type), &(ent->row_status)) == 0):
            (rtu_fdb_proxy_read_static_entry(ent->mac, ent->vid,
                &(ent->port_map), &(ent->type), &(ent->row_status)) == 0);

    if (errno)
        return SNMP_ERR_GENERR;
    if (!found)
        return SNMP_NOSUCHINSTANCE;

    // Get info on egress ports and forbidden egress ports from port map
    for (i = 0; i < NUM_PORTS; i++)
        ent->egress_ports[i] = (ent->port_map[i] == Forward) ? 1:0;

    for (i = 0; i < NUM_PORTS; i++)
        ent->forbidden_egress_ports[i] = (ent->port_map[i] == Filter) ? 1:0;

    ent->row_status = ent->row_status ? RS_ACTIVE:RS_NOTINSERVICE; // std row status
    return SNMP_ERR_NOERROR;
}


/**
 * @param ent should contain appropriate entry indexes
 */
static int get_column(
    netsnmp_request_info *req,
    int colnum,
    struct ieee8021QBridgeStaticUnicastTable_entry *ent)
{
    switch (colnum) {
    case COLUMN_IEEE8021QBRIDGESTATICUNICASTSTATICEGRESSPORTS:
        snmp_set_var_typed_value(req->requestvb, ASN_OCTET_STR,
            ent->egress_ports, NUM_PORTS);
        break;
    case COLUMN_IEEE8021QBRIDGESTATICUNICASTFORBIDDENEGRESSPORTS:
        snmp_set_var_typed_value(req->requestvb, ASN_OCTET_STR,
            ent->forbidden_egress_ports, NUM_PORTS);
        break;
    case COLUMN_IEEE8021QBRIDGESTATICUNICASTSTORAGETYPE:
        snmp_set_var_typed_integer(req->requestvb, ASN_INTEGER, ent->type);
        break;
    case COLUMN_IEEE8021QBRIDGESTATICUNICASTROWSTATUS:
        snmp_set_var_typed_integer(req->requestvb, ASN_INTEGER, ent->row_status);
        break;
    default:
        return SNMP_NOSUCHOBJECT;
    }
    return 0;
}

static int get(netsnmp_request_info *req)
{
    int err;
    struct ieee8021QBridgeStaticUnicastTable_entry ent;
    netsnmp_table_request_info *tinfo;

    tinfo = netsnmp_extract_table_info(req);
    // Get indexes for entry
    err = get_indexes(tinfo, &ent);

    snmp_log(LOG_DEBUG,
        "ieee8021QBridgeStaticUnicastTable: get cid=%lu vid=%d mac=%s rx_port=%d column=%d.\n",
        ent.cid, ent.vid, mac_to_string(ent.mac), ent.rx_port, tinfo->colnum);

    if (err != SNMP_ERR_NOERROR)
        return err;
    // Cache entry in agent memory.
    err = cache_entry(&ent, CURR_ENT);
    if (err != SNMP_ERR_NOERROR)
        return err;
    // Get column value
    return get_column(req, tinfo->colnum, &ent);
}

static int get_next(netsnmp_request_info *req,
    netsnmp_handler_registration *reginfo)
{
    int err;
    netsnmp_variable_list *idx;
    netsnmp_table_request_info *tinfo;
    struct ieee8021QBridgeStaticUnicastTable_entry ent;

    tinfo = netsnmp_extract_table_info(req);
    // Get indexes for entry
    err = get_indexes(tinfo, &ent);
    if (err != SNMP_ERR_NOERROR)
        return err;
    // Cache next entry in agent memory.
    err = cache_entry(&ent, NEXT_ENT);
    if (err == SNMP_NOSUCHINSTANCE)
        return SNMP_ENDOFMIBVIEW;
    if (err != SNMP_ERR_NOERROR)
        return err;
    // Update indexes (no need to update cid and rx_port, as they do not change)
    idx = tinfo->indexes->next_variable;
    *(idx->val.integer) = ent.vid;
    idx = idx->next_variable;
    memcpy(idx->val.string, ent.mac, ETH_ALEN);
    // Update OID
    update_oid(req, reginfo, tinfo->colnum, tinfo->indexes);
    // Get next entry column value
    return get_column(req, tinfo->colnum, &ent);
}

/**
 * Checks that the type and size of the value matches the corresponding
 * column type and size.
 */
static int set_reserve1(netsnmp_request_info *req)
{
    int ret = SNMP_ERR_NOERROR, found;
    netsnmp_table_request_info *tinfo;
    struct ieee8021QBridgeStaticUnicastTable_entry ent;

    tinfo = netsnmp_extract_table_info(req);
    switch (tinfo->colnum) {
    case COLUMN_IEEE8021QBRIDGESTATICUNICASTSTATICEGRESSPORTS:
        ret = netsnmp_check_vb_type_and_size(req->requestvb, ASN_OCTET_STR, NUM_PORTS);
        break;
    case COLUMN_IEEE8021QBRIDGESTATICUNICASTFORBIDDENEGRESSPORTS:
        ret = netsnmp_check_vb_type_and_size(req->requestvb, ASN_OCTET_STR, NUM_PORTS);
        break;
    case COLUMN_IEEE8021QBRIDGESTATICUNICASTSTORAGETYPE:
        ret = netsnmp_check_vb_int_range(req->requestvb, Other, Read_only);
        break;
    case COLUMN_IEEE8021QBRIDGESTATICUNICASTROWSTATUS:
        // Get current row status and check transition from current to requested
        ret = get_indexes(tinfo, &ent);
        if (ret != SNMP_ERR_NOERROR)
            return ret;

        errno = 0;
        found = (rtu_fdb_proxy_read_static_entry(ent.mac, ent.vid,
                &(ent.port_map), &(ent.type), &(ent.row_status)) == 0);
        if (errno)
            return SNMP_ERR_GENERR;

        ret = netsnmp_check_vb_rowstatus(req->requestvb,
                (found ? RS_ACTIVE:RS_NONEXISTENT));
        break;
    default:
        return SNMP_ERR_NOTWRITABLE;
    }
    return ret;
}


/**
 * Reserve space in agent memory to hold values until commited
 */
static int set_reserve2(netsnmp_request_info *req)
{
    int status;
    netsnmp_table_request_info *tinfo;
    struct ieee8021QBridgeStaticUnicastTable_entry *ent;

    tinfo = netsnmp_extract_table_info(req);
    switch (tinfo->colnum) {
    case COLUMN_IEEE8021QBRIDGESTATICUNICASTROWSTATUS:
        status = *req->requestvb->val.integer;
        switch (status) {
        case RS_CREATEANDGO:
        case RS_CREATEANDWAIT:
            ent = create_entry(
                *tinfo->indexes->val.integer,
                *tinfo->indexes->val.integer,
                 tinfo->indexes->val.string,
                *tinfo->indexes->val.integer
                );
            if (!ent)
                return SNMP_ERR_RESOURCEUNAVAILABLE;
            break;
        }
    }
    return 0;
}

/**
 * Cache active/notInService FDB entries.
 */
static int set_reserve3(netsnmp_request_info *req)
{
    int ret;
    netsnmp_table_request_info *tinfo;
    struct ieee8021QBridgeStaticUnicastTable_entry *ent, indexes;

    // Get indexes for entry
    tinfo = netsnmp_extract_table_info(req);
    ret = get_indexes(tinfo, &indexes);
    if (ret != SNMP_ERR_NOERROR)
        return ret;
    // Get entry from cache
    ent = get_entry(&indexes);
    if (!ent) {
        // This means we are setting fields for ACTIVE or NOTINSERVICE rows.
        // (set_reserve2 creates rows for CREATE_AND_GO and CREATE_AND_WAIT)
        ent = create_entry(
                indexes.cid,
                indexes.vid,
                indexes.mac,
                indexes.rx_port);
        if (!ent)
            return SNMP_ERR_RESOURCEUNAVAILABLE;
        ret = cache_entry(ent, CURR_ENT);
    }
    return ret;
}


/**
 * Sets value using cached entries in the agent memory.
 */
static int set_action(netsnmp_request_info *req)
{
    int err;
    netsnmp_table_request_info *tinfo;
    struct ieee8021QBridgeStaticUnicastTable_entry *ent, indexes;

    // Get indexes
    tinfo = netsnmp_extract_table_info(req);
    err = get_indexes(tinfo, &indexes);
    if (err != SNMP_ERR_NOERROR)
        return err;
    // Get entry from cache
    ent = get_entry(&indexes);
    switch (tinfo->colnum) {
    case COLUMN_IEEE8021QBRIDGESTATICUNICASTSTATICEGRESSPORTS:
        memcpy(ent->egress_ports,
               req->requestvb->val.string,
               req->requestvb->val_len);
        break;
    case COLUMN_IEEE8021QBRIDGESTATICUNICASTFORBIDDENEGRESSPORTS:
        memcpy(ent->forbidden_egress_ports,
               req->requestvb->val.string,
               req->requestvb->val_len);
        break;
    case COLUMN_IEEE8021QBRIDGESTATICUNICASTSTORAGETYPE:
        ent->type = *req->requestvb->val.integer;
        break;
    case COLUMN_IEEE8021QBRIDGESTATICUNICASTROWSTATUS:
        ent->row_status = *req->requestvb->val.integer;
        break;
    }
    // Keep reference to last request for this entry (to return err later on)
    ent->req = req;
    return 0;
}

/**
 * Check consistency of active rows.
 */
static int check_consistency(struct ieee8021QBridgeStaticUnicastTable_entry *ent)
{
    int i;

    switch(ent->row_status) {
        case RS_ACTIVE:
        case RS_CREATEANDGO:
            // MAC should not be multicast (this is static _unicast_ table)
            if (mac_multicast(ent->mac))
                return SNMP_ERR_INCONSISTENTVALUE;
            // Ports can not be egress and forbidden egress at the same time.
            for (i = 0; i < NUM_PORTS; i++)
                if((ent->egress_ports[i] == 1) &&
                   (ent->forbidden_egress_ports[i] == 1))
                   return SNMP_ERR_INCONSISTENTVALUE;
    }
    return 0;
}

static int set_commit(struct ieee8021QBridgeStaticUnicastTable_entry *ent)
{
    int i, err;

    switch (ent->row_status) {
    case RS_DESTROY:
        // Remove entry from FDB
        errno = 0;
        err = rtu_fdb_proxy_delete_static_entry(ent->mac, ent->vid);
        // Permanent entries can not be removed so an error might be raised...
        if (errno || err)
            return SNMP_ERR_GENERR;
        break;
    default:
        calculate_port_map(ent);
        // create/update entry in FDB
        errno = 0;
        err = rtu_fdb_proxy_create_static_entry(ent->mac, ent->vid,
            ent->port_map, ent->type, active(ent->row_status));
        if (errno || err)
            return SNMP_ERR_GENERR;
        break;
    }
    return 0;
}

/**
 * Handles requests for the ieee8021QBridgeStaticUnicastTable table
 */
static int ieee8021QBridgeStaticUnicastTable_handler(
    netsnmp_mib_handler               *handler,
    netsnmp_handler_registration      *reginfo,
    netsnmp_agent_request_info        *reqinfo,
    netsnmp_request_info              *requests)
{
    int err;
    netsnmp_request_info *req;
    struct ieee8021QBridgeStaticUnicastTable_entry *ent;

    switch (reqinfo->mode) {
    case MODE_GET:
        for (req = requests; req; req = req->next) {
            err = get(req);
            if (err)
                netsnmp_set_request_error(reqinfo, req, err);
        }
        break;
    case MODE_GETNEXT:
        for (req = requests; req; req = req->next) {
            err = get_next(req, reginfo);
            if (err)
                netsnmp_set_request_error(reqinfo, req, err);
        }
        break;
    case MODE_SET_RESERVE1:
        for (req =requests; req; req =req->next) {
            err = set_reserve1(req);
            if (err)
                netsnmp_set_request_error(reqinfo, req, err);
        }
        break;
    case MODE_SET_RESERVE2:
        for (req = requests; req; req = req->next) {
            err = set_reserve2(req);
            if (err)
                netsnmp_set_request_error(reqinfo, req, err);
        }
        for (req = requests; req; req = req->next) {
            err = set_reserve3(req);
            if (err)
                netsnmp_set_request_error(reqinfo, req, err);
        }
        break;
    case MODE_SET_FREE:
        clean_cache();
        break;
    case MODE_SET_ACTION:
        for (req = requests; req; req = req->next) {
            err = set_action(req);
            if (err)
                netsnmp_set_request_error(reqinfo, req, err);
        }
        for (ent = cache; ent; ent = ent->next) {
            err = check_consistency(ent);
            if (err)
                netsnmp_set_request_error(reqinfo, ent->req, err);
        }
        break;
    case MODE_SET_UNDO:
        clean_cache();
        break;
    case MODE_SET_COMMIT:
        for (ent = cache; ent; ent = ent->next) {
            err = set_commit(ent);
            if (err)
                netsnmp_set_request_error(reqinfo, ent->req, err);
        }
        clean_cache(); // prepare for next atomic set operation
        break;
    }
    return SNMP_ERR_NOERROR;
}

/**
 * Initialize the ieee8021QBridgeStaticUnicastTable table by defining its
 * contents and how it's structured
 */
static void initialize_table_ieee8021QBridgeStaticUnicastTable(void)
{
    const oid ieee8021QBridgeStaticUnicastTable_oid[] = {1,3,111,2,802,1,1,4,1,3,1};
    netsnmp_handler_registration    *reg;
    netsnmp_table_registration_info *tinfo;
    netsnmp_variable_list *idx;

    reg = netsnmp_create_handler_registration(
              "ieee8021QBridgeStaticUnicastTable",
              ieee8021QBridgeStaticUnicastTable_handler,
              (oid *)ieee8021QBridgeStaticUnicastTable_oid,
              OID_LENGTH(ieee8021QBridgeStaticUnicastTable_oid),
              HANDLER_CAN_RWRITE);

    tinfo = SNMP_MALLOC_TYPEDEF( netsnmp_table_registration_info );
    netsnmp_table_helper_add_indexes(tinfo,
            ASN_UNSIGNED,  /* index: ComponentId */
            ASN_UNSIGNED,  /* index: VlanIndex */
            ASN_PRIV_IMPLIED_OCTET_STR, /* index: Address */
            ASN_UNSIGNED,  /* index: ReceivePort */
            0);

    // Fix the MacAddress Index variable binding lenght
    idx = tinfo->indexes;

    idx = idx->next_variable; // skip componentId
    idx = idx->next_variable; // skip vlanIndex

    idx->val_len = ETH_ALEN;

    tinfo->min_column = COLUMN_IEEE8021QBRIDGESTATICUNICASTSTATICEGRESSPORTS;
    tinfo->max_column = COLUMN_IEEE8021QBRIDGESTATICUNICASTROWSTATUS;

    netsnmp_register_table(reg, tinfo);
}

/**
 * Initializes the ieee8021QBridgeStaticUnicastTable module
 */
void init_ieee8021QBridgeStaticUnicastTable(void)
{
    struct minipc_ch *client;

    initialize_table_ieee8021QBridgeStaticUnicastTable();
    client = rtu_fdb_proxy_create("rtu_fdb");
    if (!client)
        snmp_log(LOG_ERR,
            "ieee8021QBridgeStaticUnicastTable: error creating mini-ipc proxy - %s\n",
            strerror(errno));
    snmp_log(LOG_INFO,"ieee8021QBridgeStaticUnicastTable: initialised\n");

}
