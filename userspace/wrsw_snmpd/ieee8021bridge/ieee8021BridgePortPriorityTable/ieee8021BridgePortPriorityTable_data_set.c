/*
 * White Rabbit SNMP
 * Copyright (C) 2010, CERN.
 *
 * Version:     wrsw_snmpd v1.0
 *
 * Authors:     Miguel Baiz√°n (miguel.baizan@integrasys-sa.com)
 *
 * Description: These functions are used to set the column data in the container
 *              and commit the values where appropriate. It uses a states
 *              machine to control the consistence of data (see below).
 *              Note: this file originally auto-generated by mib2c using
 *              mib2c.mfd.conf 17337
 *
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version
 * 2 of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/* standard Net-SNMP includes */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

#include <sys/ioctl.h>
#include <linux/if.h>

#include <wr_ipc.h>
#include <wrsw_hal.h>
#include <hal_exports.h>

/* include our parent header */
#include "ieee8021BridgePortPriorityTable.h"


/** @defgroup data_set data_set: Routines to set data
 *
 * These routines are used to set the value for individual objects. The
 * row context is passed, along with the new value.
 *
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table ieee8021BridgePortPriorityTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * IEEE8021-BRIDGE-MIB::ieee8021BridgePortPriorityTable is subid 1 of ieee8021BridgePriority.
 * Its status is Current.
 * OID: .1.3.111.2.802.1.1.2.1.3.1, length: 11
*/
    /*
     * NOTE: if you update this chart, please update the versions in
     *       local/mib2c-conf.d/parent-set.m2i
     *       agent/mibgroup/helpers/baby_steps.c
     * while you're at it.
     */
    /*
     ***********************************************************************
     * Baby Steps Flow Chart (2004.06.05)                                  *
     *                                                                     *
     * +--------------+    +================+    U = unconditional path    *
     * |optional state|    ||required state||    S = path for success      *
     * +--------------+    +================+    E = path for error        *
     ***********************************************************************
     *
     *                        +--------------+
     *                        |     pre      |
     *                        |   request    |
     *                        +--------------+
     *                               | U
     *                        +==============+
     *       +----------------||  object    ||
     *       |              E ||  lookup    ||
     *       |                +==============+
     *       |                       | S
     *       |                +==============+
     *       |              E ||   check    ||
     *       |<---------------||   values   ||
     *       |                +==============+
     *       |                       | S
     *       |                +==============+
     *       |       +<-------||   undo     ||
     *       |       |      E ||   setup    ||
     *       |       |        +==============+
     *       |       |               | S
     *       |       |        +==============+
     *       |       |        ||    set     ||-------------------------->+
     *       |       |        ||   value    || E                         |
     *       |       |        +==============+                           |
     *       |       |               | S                                 |
     *       |       |        +--------------+                           |
     *       |       |        |    check     |-------------------------->|
     *       |       |        |  consistency | E                         |
     *       |       |        +--------------+                           |
     *       |       |               | S                                 |
     *       |       |        +==============+         +==============+  |
     *       |       |        ||   commit   ||-------->||     undo   ||  |
     *       |       |        ||            || E       ||    commit  ||  |
     *       |       |        +==============+         +==============+  |
     *       |       |               | S                     U |<--------+
     *       |       |        +--------------+         +==============+
     *       |       |        | irreversible |         ||    undo    ||
     *       |       |        |    commit    |         ||     set    ||
     *       |       |        +--------------+         +==============+
     *       |       |               | U                     U |
     *       |       +-------------->|<------------------------+
     *       |                +==============+
     *       |                ||   undo     ||
     *       |                ||  cleanup   ||
     *       |                +==============+
     *       +---------------------->| U
     *                        +--------------+
     *                        |    post      |
     *                        |   request    |
     *                        +--------------+
     *
     */


/* Static functions */
static int
ieee8021BridgePortDefaultUserPriority_commit(
    ieee8021BridgePortPriorityTable_rowreq_ctx *rowreq_ctx,
    int undo_flag);


/**
 * Setup up context with information needed to undo a set request.
 *
 * This function will be called before the individual node undo setup
 * functions are called. If you need to do any undo setup that is not
 * related to a specific column, you can do it here.
 *
 * Note that the undo context has been allocated with
 * ieee8021BridgePortPriorityTable_allocate_data(), but may need extra
 * initialization similar to what you may have done in
 * ieee8021BridgePortPriorityTable_rowreq_ctx_init().
 * Note that an individual node's undo_setup function will only be called
 * if that node is being set to a new value.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in the node's undo_setup
 * function, so it won't be done unless it is necessary.
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ieee8021BridgePortPriorityTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 */
int
ieee8021BridgePortPriorityTable_undo_setup( ieee8021BridgePortPriorityTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:ieee8021BridgePortPriorityTable:ieee8021BridgePortPriorityTable_undo_setup","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * TODO:451:M: |-> Setup ieee8021BridgePortPriorityTable undo.
     * set up ieee8021BridgePortPriorityTable undo information, in preparation for a set.
     * Undo storage is in (* ieee8021BridgePortServiceAccessPrioritySelection_val_ptr )*
     */

    return rc;
} /* ieee8021BridgePortPriorityTable_undo_setup */

/**
 * Undo a set request.
 *
 * This function will be called before the individual node undo
 * functions are called. If you need to do any undo that is not
 * related to a specific column, you can do it here.
 *
 * Note that an individual node's undo function will only be called
 * if that node is being set to a new value.
 *
 * If there is anything  specific to a particular column (e.g. releasing
 * memory for a string), you should do that setup in the node's undo
 * function, so it won't be done unless it is necessary.
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ieee8021BridgePortPriorityTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 */
int
ieee8021BridgePortPriorityTable_undo( ieee8021BridgePortPriorityTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:ieee8021BridgePortPriorityTable:ieee8021BridgePortPriorityTable_undo","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * TODO:451:M: |-> ieee8021BridgePortPriorityTable undo.
     * ieee8021BridgePortPriorityTable undo information, in response to a failed set.
     * Undo storage is in (* ieee8021BridgePortServiceAccessPrioritySelection_val_ptr )*
     */

    return rc;
} /* ieee8021BridgePortPriorityTable_undo_setup */

/**
 * Cleanup up context undo information.
 *
 * This function will be called after set/commit processing. If you
 * allocated any resources in undo_setup, this is the place to release
 * those resources.
 *
 * This function is called regardless of the success or failure of the set
 * request. If you need to perform different steps for cleanup depending
 * on success or failure, you can add a flag to the rowreq_ctx.
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ieee8021BridgePortPriorityTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error
 */
int
ieee8021BridgePortPriorityTable_undo_cleanup( ieee8021BridgePortPriorityTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:ieee8021BridgePortPriorityTable:ieee8021BridgePortPriorityTable_undo_cleanup","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * TODO:452:M: |-> Cleanup ieee8021BridgePortPriorityTable undo.
     * Undo storage is in (* ieee8021BridgePortServiceAccessPrioritySelection_val_ptr )*
     */

    return rc;
} /* ieee8021BridgePortPriorityTable_undo_cleanup */

/**
 * commit new values.
 *
 * At this point, you should have done everything you can to ensure that
 * this commit will not fail.
 *
 * Should you need different behavior depending on which columns were
 * set, rowreq_ctx->column_set_flags will indicate which writeable columns were
 * set. The definitions for the COLUMN_*_FLAG bits can be found in
 * ieee8021BridgePortPriorityTable_oids.h.
 * A new row will have the MFD_ROW_CREATED bit set in rowreq_flags.
 *
 * @param ieee8021BridgePortPriorityTable_rowreq_ctx
 *        Pointer to the users context.
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error
 */
int
ieee8021BridgePortPriorityTable_commit( ieee8021BridgePortPriorityTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;
    int save_flags;

    DEBUGMSGTL(("verbose:ieee8021BridgePortPriorityTable:"
                "ieee8021BridgePortPriorityTable_commit","called\n"));

    /* We should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /* Save flags, then clear until we actually do something. We use now the
       flags to control the commits */
    save_flags = rowreq_ctx->column_set_flags;
    rowreq_ctx->column_set_flags = 0;

    /*
     * Commit ieee8021BridgePortPriorityTable data
     * 1) check the column's flag in save_flags to see if it was set.
     * 2) clear the flag when you handle that column
     * 3) set the column's flag in column_set_flags if it needs undo
     *    processing in case of a failure.
     */

    if (save_flags & COLUMN_IEEE8021BRIDGEPORTDEFAULTUSERPRIORITY_FLAG) {
        /* Commit column ieee8021BridgePortDefaultUserPriority */
        rc = ieee8021BridgePortDefaultUserPriority_commit(rowreq_ctx, 0);
        if (rc) {
            snmp_log(LOG_ERR,"ieee8021BridgePortPriorityTable column"
                     " ieee8021BridgePortDefaultUserPriority commit failed\n");
        } else {
            save_flags &= ~COLUMN_IEEE8021BRIDGEPORTDEFAULTUSERPRIORITY_FLAG;
            /* Set flag, in case we need to undo
               ieee8021BridgePortDefaultUserPriority */
            rowreq_ctx->column_set_flags |=
                COLUMN_IEEE8021BRIDGEPORTDEFAULTUSERPRIORITY_FLAG;
        }
    }

    if (save_flags) {
       snmp_log(LOG_ERR, "unhandled columns (0x%x) in commit\n", save_flags);
       return MFD_ERROR;
    }

    /* If we successfully commited this row, set the dirty flag
       and return success */
    rowreq_ctx->rowreq_flags |= MFD_ROW_DIRTY;

    return MFD_SUCCESS;
} /* ieee8021BridgePortPriorityTable_commit */

/**
 * undo commit new values.
 *
 * Should you need different behavior depending on which columns were
 * set, rowreq_ctx->column_set_flags will indicate which writeable columns were
 * set. The definitions for the COLUMN_*_FLAG bits can be found in
 * ieee8021BridgePortPriorityTable_oids.h.
 * A new row will have the MFD_ROW_CREATED bit set in rowreq_flags.
 *
 * @param ieee8021BridgePortPriorityTable_rowreq_ctx
 *        Pointer to the users context.
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error
 */
int
ieee8021BridgePortPriorityTable_undo_commit( ieee8021BridgePortPriorityTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:ieee8021BridgePortPriorityTable:"
                "ieee8021BridgePortPriorityTable_undo_commit","called\n"));

    /* We should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    if (rowreq_ctx->column_set_flags &
        COLUMN_IEEE8021BRIDGEPORTDEFAULTUSERPRIORITY_FLAG) {
        /* This column has been commited, so need undo */
        rc = ieee8021BridgePortDefaultUserPriority_commit(rowreq_ctx, 1);
        if (rc) {
            /* Nothing we can do about it but log it */
            snmp_log(LOG_ERR,"ieee8021BridgePortPriorityTable column"
                     " ieee8021BridgePortDefaultUserPriority undo"
                     " commit failed\n");
        }
    }

    /* If we successfully un-commited this row, clear the dirty flag */
    if (rc == MFD_SUCCESS) {
        rowreq_ctx->rowreq_flags &= ~MFD_ROW_DIRTY;
    }

    return rc;
} /* ieee8021BridgePortPriorityTable_undo_commit */

/*
 * TODO:440:M: Implement ieee8021BridgePortPriorityTable node value checks.
 * TODO:450:M: Implement ieee8021BridgePortPriorityTable undo functions.
 * TODO:460:M: Implement ieee8021BridgePortPriorityTable set functions.
 * TODO:480:M: Implement ieee8021BridgePortPriorityTable commit functions.
 */
/*---------------------------------------------------------------------
 * IEEE8021-BRIDGE-MIB::ieee8021BridgePortPriorityEntry.ieee8021BridgePortDefaultUserPriority
 * ieee8021BridgePortDefaultUserPriority is subid 1 of ieee8021BridgePortPriorityEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.111.2.802.1.1.2.1.3.1.1.1
 * Description:
The default ingress User Priority for this port.  This
        only has effect on media, such as Ethernet, that do not
        support native User Priority.

        The value of this object MUST be retained across
        reinitializations of the management system.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   1
 *   hint: d
 *
 * Ranges:  0 - 7;
 *
 * Its syntax is IEEE8021PriorityValue (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ieee8021BridgePortDefaultUserPriority_val
 *        A u_long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 *
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * ieee8021BridgePortPriorityTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_UNSIGNED
 *    The value is in (one of) the range set(s):  0 - 7
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
ieee8021BridgePortDefaultUserPriority_check_value( ieee8021BridgePortPriorityTable_rowreq_ctx *rowreq_ctx, u_long ieee8021BridgePortDefaultUserPriority_val)
{
    DEBUGMSGTL(("verbose:ieee8021BridgePortPriorityTable:ieee8021BridgePortDefaultUserPriority_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid ieee8021BridgePortDefaultUserPriority value.
     */

    return MFD_SUCCESS; /* ieee8021BridgePortDefaultUserPriority value not illegal */
} /* ieee8021BridgePortDefaultUserPriority_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ieee8021BridgePortPriorityTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * ieee8021BridgePortPriorityTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
ieee8021BridgePortDefaultUserPriority_undo_setup( ieee8021BridgePortPriorityTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:ieee8021BridgePortPriorityTable:ieee8021BridgePortDefaultUserPriority_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup ieee8021BridgePortDefaultUserPriority undo.
     */
    /*
     * copy ieee8021BridgePortDefaultUserPriority data
     * set rowreq_ctx->undo->ieee8021BridgePortDefaultUserPriority from rowreq_ctx->data.ieee8021BridgePortDefaultUserPriority
     */
    rowreq_ctx->undo->ieee8021BridgePortDefaultUserPriority = rowreq_ctx->data.ieee8021BridgePortDefaultUserPriority;


    return MFD_SUCCESS;
} /* ieee8021BridgePortDefaultUserPriority_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param ieee8021BridgePortDefaultUserPriority_val
 *        A u_long containing the new value.
 */
int
ieee8021BridgePortDefaultUserPriority_set( ieee8021BridgePortPriorityTable_rowreq_ctx *rowreq_ctx, u_long ieee8021BridgePortDefaultUserPriority_val )
{

    DEBUGMSGTL(("verbose:ieee8021BridgePortPriorityTable:ieee8021BridgePortDefaultUserPriority_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set ieee8021BridgePortDefaultUserPriority value.
     * set ieee8021BridgePortDefaultUserPriority value in rowreq_ctx->data
     */
    rowreq_ctx->data.ieee8021BridgePortDefaultUserPriority = ieee8021BridgePortDefaultUserPriority_val;

    return MFD_SUCCESS;
} /* ieee8021BridgePortDefaultUserPriority_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
ieee8021BridgePortDefaultUserPriority_undo( ieee8021BridgePortPriorityTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:ieee8021BridgePortPriorityTable:ieee8021BridgePortDefaultUserPriority_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up ieee8021BridgePortDefaultUserPriority undo.
     */
    /*
     * copy ieee8021BridgePortDefaultUserPriority data
     * set rowreq_ctx->data.ieee8021BridgePortDefaultUserPriority from rowreq_ctx->undo->ieee8021BridgePortDefaultUserPriority
     */
    rowreq_ctx->data.ieee8021BridgePortDefaultUserPriority = rowreq_ctx->undo->ieee8021BridgePortDefaultUserPriority;


    return MFD_SUCCESS;
} /* ieee8021BridgePortDefaultUserPriority_undo */


/**
 * Internal function used to commit or undo-commit values of
 * the ieee8021BridgePortDefaultUserPriority object
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param undo_flag
 *        A flag to control if we are making a commit(0) or an undo-commit(1)
 *
 * @retval MFD_SUCCESS              : success
 * @retval MFD_ERROR                : error
 * @retval MFD_RESOURCE_UNAVAILABLE : socket to interface not available
 *
 */
static int
ieee8021BridgePortDefaultUserPriority_commit(
 ieee8021BridgePortPriorityTable_rowreq_ctx *rowreq_ctx, int undo_flag)
{
    wripc_handle_t              hal_ipc;
    hexp_port_list_t            port_list;

    struct wrn_register_req     req;
    struct ifreq                ifr;
    int                         sockfd, port_id, i;


    DEBUGMSGTL(("verbose:ieee8021BridgePortPriorityTable:"
                "ieee8021BridgePortDefaultUserPriority_commit","called\n"));

    /* Should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /* Check if the value is the same as the one in the undo context.
       If it's the same value we don't need to commit anything */
    if (rowreq_ctx->undo->ieee8021BridgePortDefaultUserPriority ==
        rowreq_ctx->data.ieee8021BridgePortDefaultUserPriority) {
        return MFD_SUCCESS;
    }

    /* Create socket interface */
    sockfd = socket(AF_PACKET, SOCK_RAW, 0);
    if (sockfd < 0) {
        snmp_log(LOG_ERR,"socket failed\n");
        return MFD_RESOURCE_UNAVAILABLE;
    }

    /* Search the port name associated with the ieee8021BridgeBasePort */

    /* Connect to HAL to get the information */
    hal_ipc = wripc_connect("wrsw_hal");
    if(hal_ipc < 0) {
        snmp_log(LOG_ERR,"Unable to connect to HAL\n");
        close(sockfd);
        return MFD_ERROR;
    }

    /* Get the port list */
    if (wripc_call(hal_ipc, "halexp_query_all_ports", &port_list, 0) < 0) {
        snmp_log(LOG_ERR,"halexp_query_all_ports has not worked\n");
        wripc_close(hal_ipc);
        close(sockfd);
        return MFD_ERROR;
    }

    ifr.ifr_addr.sa_family = AF_PACKET;
    ifr.ifr_data = &req;

    /* Iterate through the port list */
    for(i = 0; i < HAL_MAX_PORTS; i++) {
        /* Only interested in non null port names */
        if (port_list.port_names[i][0] != '\0') {
            /* Make custom ioctl to get data */
            strncpy(ifr.ifr_name, port_list.port_names[i],
                    sizeof(ifr.ifr_name));
            req.cmd = WRN_ECR_GET_PORTID;

            if (ioctl(sockfd, PRIV_IOCGGETECR, &ifr) < 0) {
                snmp_log(LOG_ERR, "ioctl PRIV_IOCGGETECR failed\n");
                wripc_close(hal_ipc);
                close(sockfd);
                return MFD_ERROR;
            } else {
                /* Check if this is the port ID that we need */
                if (req.val == rowreq_ctx->tbl_idx.ieee8021BridgeBasePort) {
                    req.cmd = WRN_RFCR_SET_PRIO_VAL;
                    /* Check if we are commiting or undoing a previous commit */
                    req.val = (undo_flag ?
                      rowreq_ctx->undo->ieee8021BridgePortDefaultUserPriority :
                      rowreq_ctx->data.ieee8021BridgePortDefaultUserPriority);

                    ifr.ifr_data = &req;

                    /* Set ieee8021BridgePortDefaultUserPriority value */
                    /* TODO:WR: Support for the persistence of this data */
                    if(ioctl(sockfd, PRIV_IOCSSETRFCR, &ifr) < 0) {
                        snmp_log(LOG_ERR, "ioctl PRIV_IOCSSETECR failed\n");
                        wripc_close(hal_ipc);
                        close(sockfd);
                        return MFD_ERROR;
                    } else {
                        DEBUGMSGTL(("verbose:ieee8021BridgePortPriorityTable:"
                                "ieee8021BridgePortDefaultUserPriority_commit",
                                "%s default user priority set to: %i\n",
                                ifr.ifr_name, req.val));
                    }
                    break;
                }
            }
        } /* Only interested in non null port names*/
    } /* Iterate through port list */

    wripc_close(hal_ipc);
    close(sockfd);
    return MFD_SUCCESS;
} /* ieee8021BridgePortDefaultUserPriority_commit */

/*---------------------------------------------------------------------
 * IEEE8021-BRIDGE-MIB::ieee8021BridgePortPriorityEntry.ieee8021BridgePortNumTrafficClasses
 * ieee8021BridgePortNumTrafficClasses is subid 2 of ieee8021BridgePortPriorityEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.111.2.802.1.1.2.1.3.1.1.2
 * Description:
The number of egress traffic classes supported on this
        port.  This object may optionally be read-only.

        The value of this object MUST be retained across
        reinitializations of the management system.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  1 - 8;
 *
 * Its syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ieee8021BridgePortNumTrafficClasses_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 *
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * ieee8021BridgePortPriorityTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is in (one of) the range set(s):  1 - 8
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
ieee8021BridgePortNumTrafficClasses_check_value( ieee8021BridgePortPriorityTable_rowreq_ctx *rowreq_ctx, long ieee8021BridgePortNumTrafficClasses_val)
{
    DEBUGMSGTL(("verbose:ieee8021BridgePortPriorityTable:ieee8021BridgePortNumTrafficClasses_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid ieee8021BridgePortNumTrafficClasses value.
     */

    return SNMP_ERR_NOTWRITABLE; /* It can be optionally RO */
} /* ieee8021BridgePortNumTrafficClasses_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ieee8021BridgePortPriorityTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * ieee8021BridgePortPriorityTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
ieee8021BridgePortNumTrafficClasses_undo_setup( ieee8021BridgePortPriorityTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:ieee8021BridgePortPriorityTable:ieee8021BridgePortNumTrafficClasses_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup ieee8021BridgePortNumTrafficClasses undo.
     */
    /*
     * copy ieee8021BridgePortNumTrafficClasses data
     * set rowreq_ctx->undo->ieee8021BridgePortNumTrafficClasses from rowreq_ctx->data.ieee8021BridgePortNumTrafficClasses
     */
    rowreq_ctx->undo->ieee8021BridgePortNumTrafficClasses = rowreq_ctx->data.ieee8021BridgePortNumTrafficClasses;


    return MFD_SUCCESS;
} /* ieee8021BridgePortNumTrafficClasses_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param ieee8021BridgePortNumTrafficClasses_val
 *        A long containing the new value.
 */
int
ieee8021BridgePortNumTrafficClasses_set( ieee8021BridgePortPriorityTable_rowreq_ctx *rowreq_ctx, long ieee8021BridgePortNumTrafficClasses_val )
{

    DEBUGMSGTL(("verbose:ieee8021BridgePortPriorityTable:ieee8021BridgePortNumTrafficClasses_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set ieee8021BridgePortNumTrafficClasses value.
     * set ieee8021BridgePortNumTrafficClasses value in rowreq_ctx->data
     */
    rowreq_ctx->data.ieee8021BridgePortNumTrafficClasses = ieee8021BridgePortNumTrafficClasses_val;

    return MFD_SUCCESS;
} /* ieee8021BridgePortNumTrafficClasses_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
ieee8021BridgePortNumTrafficClasses_undo( ieee8021BridgePortPriorityTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:ieee8021BridgePortPriorityTable:ieee8021BridgePortNumTrafficClasses_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up ieee8021BridgePortNumTrafficClasses undo.
     */
    /*
     * copy ieee8021BridgePortNumTrafficClasses data
     * set rowreq_ctx->data.ieee8021BridgePortNumTrafficClasses from rowreq_ctx->undo->ieee8021BridgePortNumTrafficClasses
     */
    rowreq_ctx->data.ieee8021BridgePortNumTrafficClasses = rowreq_ctx->undo->ieee8021BridgePortNumTrafficClasses;


    return MFD_SUCCESS;
} /* ieee8021BridgePortNumTrafficClasses_undo */

/*---------------------------------------------------------------------
 * IEEE8021-BRIDGE-MIB::ieee8021BridgePortPriorityEntry.ieee8021BridgePortPriorityCodePointSelection
 * ieee8021BridgePortPriorityCodePointSelection is subid 3 of ieee8021BridgePortPriorityEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.111.2.802.1.1.2.1.3.1.1.3
 * Description:
 This object identifies the rows in the PCP encoding and
          decoding tables that are used to remark frames on this
          port if this remarking is enabled.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 3/8. Values:  codePoint8p0d(1), codePoint7p1d(2), codePoint6p2d(3), codePoint5p3d(4)
 *
 * Its syntax is IEEE8021PriorityCodePoint (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ieee8021BridgePortPriorityCodePointSelection_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 *
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * ieee8021BridgePortPriorityTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  codePoint8p0d(1), codePoint7p1d(2), codePoint6p2d(3), codePoint5p3d(4)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
ieee8021BridgePortPriorityCodePointSelection_check_value( ieee8021BridgePortPriorityTable_rowreq_ctx *rowreq_ctx, u_long ieee8021BridgePortPriorityCodePointSelection_val)
{
    DEBUGMSGTL(("verbose:ieee8021BridgePortPriorityTable:ieee8021BridgePortPriorityCodePointSelection_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid ieee8021BridgePortPriorityCodePointSelection value.
     */

    return SNMP_ERR_NOTWRITABLE; /* Object not implemented */
} /* ieee8021BridgePortPriorityCodePointSelection_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ieee8021BridgePortPriorityTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * ieee8021BridgePortPriorityTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
ieee8021BridgePortPriorityCodePointSelection_undo_setup( ieee8021BridgePortPriorityTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:ieee8021BridgePortPriorityTable:ieee8021BridgePortPriorityCodePointSelection_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup ieee8021BridgePortPriorityCodePointSelection undo.
     */
    /*
     * copy ieee8021BridgePortPriorityCodePointSelection data
     * set rowreq_ctx->undo->ieee8021BridgePortPriorityCodePointSelection from rowreq_ctx->data.ieee8021BridgePortPriorityCodePointSelection
     */
    rowreq_ctx->undo->ieee8021BridgePortPriorityCodePointSelection = rowreq_ctx->data.ieee8021BridgePortPriorityCodePointSelection;


    return MFD_SUCCESS;
} /* ieee8021BridgePortPriorityCodePointSelection_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param ieee8021BridgePortPriorityCodePointSelection_val
 *        A long containing the new value.
 */
int
ieee8021BridgePortPriorityCodePointSelection_set( ieee8021BridgePortPriorityTable_rowreq_ctx *rowreq_ctx, u_long ieee8021BridgePortPriorityCodePointSelection_val )
{

    DEBUGMSGTL(("verbose:ieee8021BridgePortPriorityTable:ieee8021BridgePortPriorityCodePointSelection_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set ieee8021BridgePortPriorityCodePointSelection value.
     * set ieee8021BridgePortPriorityCodePointSelection value in rowreq_ctx->data
     */
    rowreq_ctx->data.ieee8021BridgePortPriorityCodePointSelection = ieee8021BridgePortPriorityCodePointSelection_val;

    return MFD_SUCCESS;
} /* ieee8021BridgePortPriorityCodePointSelection_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
ieee8021BridgePortPriorityCodePointSelection_undo( ieee8021BridgePortPriorityTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:ieee8021BridgePortPriorityTable:ieee8021BridgePortPriorityCodePointSelection_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up ieee8021BridgePortPriorityCodePointSelection undo.
     */
    /*
     * copy ieee8021BridgePortPriorityCodePointSelection data
     * set rowreq_ctx->data.ieee8021BridgePortPriorityCodePointSelection from rowreq_ctx->undo->ieee8021BridgePortPriorityCodePointSelection
     */
    rowreq_ctx->data.ieee8021BridgePortPriorityCodePointSelection = rowreq_ctx->undo->ieee8021BridgePortPriorityCodePointSelection;


    return MFD_SUCCESS;
} /* ieee8021BridgePortPriorityCodePointSelection_undo */

/*---------------------------------------------------------------------
 * IEEE8021-BRIDGE-MIB::ieee8021BridgePortPriorityEntry.ieee8021BridgePortUseDEI
 * ieee8021BridgePortUseDEI is subid 4 of ieee8021BridgePortPriorityEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.111.2.802.1.1.2.1.3.1.1.4
 * Description:
If the Use_DEI is set to true(1) for the Port then the
        drop_eligible parameter is encoded in the DEI of transmitted
        frames, and the drop_eligible parameter shall be true(1) for a
        received frame if the DEI is set in the S-TAG or the Priority
        Code Point Decoding Table indicates drop_eligible True for
        the received PCP value. If the Use_DEI parameter is false(2),
        the DEI shall be transmitted as zero and ignored on receipt.
        The default value of the Use_DEI parameter is false(2).
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ieee8021BridgePortUseDEI_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 *
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * ieee8021BridgePortPriorityTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  true(1), false(2)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
ieee8021BridgePortUseDEI_check_value( ieee8021BridgePortPriorityTable_rowreq_ctx *rowreq_ctx, u_long ieee8021BridgePortUseDEI_val)
{
    DEBUGMSGTL(("verbose:ieee8021BridgePortPriorityTable:ieee8021BridgePortUseDEI_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid ieee8021BridgePortUseDEI value.
     */

    return SNMP_ERR_NOTWRITABLE; /* Object not implemented */
} /* ieee8021BridgePortUseDEI_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ieee8021BridgePortPriorityTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * ieee8021BridgePortPriorityTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
ieee8021BridgePortUseDEI_undo_setup( ieee8021BridgePortPriorityTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:ieee8021BridgePortPriorityTable:ieee8021BridgePortUseDEI_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup ieee8021BridgePortUseDEI undo.
     */
    /*
     * copy ieee8021BridgePortUseDEI data
     * set rowreq_ctx->undo->ieee8021BridgePortUseDEI from rowreq_ctx->data.ieee8021BridgePortUseDEI
     */
    rowreq_ctx->undo->ieee8021BridgePortUseDEI = rowreq_ctx->data.ieee8021BridgePortUseDEI;


    return MFD_SUCCESS;
} /* ieee8021BridgePortUseDEI_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param ieee8021BridgePortUseDEI_val
 *        A long containing the new value.
 */
int
ieee8021BridgePortUseDEI_set( ieee8021BridgePortPriorityTable_rowreq_ctx *rowreq_ctx, u_long ieee8021BridgePortUseDEI_val )
{

    DEBUGMSGTL(("verbose:ieee8021BridgePortPriorityTable:ieee8021BridgePortUseDEI_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set ieee8021BridgePortUseDEI value.
     * set ieee8021BridgePortUseDEI value in rowreq_ctx->data
     */
    rowreq_ctx->data.ieee8021BridgePortUseDEI = ieee8021BridgePortUseDEI_val;

    return MFD_SUCCESS;
} /* ieee8021BridgePortUseDEI_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
ieee8021BridgePortUseDEI_undo( ieee8021BridgePortPriorityTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:ieee8021BridgePortPriorityTable:ieee8021BridgePortUseDEI_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up ieee8021BridgePortUseDEI undo.
     */
    /*
     * copy ieee8021BridgePortUseDEI data
     * set rowreq_ctx->data.ieee8021BridgePortUseDEI from rowreq_ctx->undo->ieee8021BridgePortUseDEI
     */
    rowreq_ctx->data.ieee8021BridgePortUseDEI = rowreq_ctx->undo->ieee8021BridgePortUseDEI;


    return MFD_SUCCESS;
} /* ieee8021BridgePortUseDEI_undo */

/*---------------------------------------------------------------------
 * IEEE8021-BRIDGE-MIB::ieee8021BridgePortPriorityEntry.ieee8021BridgePortRequireDropEncoding
 * ieee8021BridgePortRequireDropEncoding is subid 5 of ieee8021BridgePortPriorityEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.111.2.802.1.1.2.1.3.1.1.5
 * Description:
If a Bridge supports encoding or decoding of drop_eligible
        from the PCP field of a VLAN tag (6.7.3) on any of its Ports,
        then it shall implement a Boolean parameter Require Drop
        Encoding on each of its Ports with default value false(2). If
        Require Drop Encoding is True and the Bridge Port cannot
        encode particular priorities with drop_eligible, then frames
        queued with those priorities and drop_eligible true(1) shall
        be discarded and not transmitted.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 1
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *   defval: false
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ieee8021BridgePortRequireDropEncoding_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 *
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * ieee8021BridgePortPriorityTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  true(1), false(2)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
ieee8021BridgePortRequireDropEncoding_check_value( ieee8021BridgePortPriorityTable_rowreq_ctx *rowreq_ctx, u_long ieee8021BridgePortRequireDropEncoding_val)
{
    DEBUGMSGTL(("verbose:ieee8021BridgePortPriorityTable:ieee8021BridgePortRequireDropEncoding_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid ieee8021BridgePortRequireDropEncoding value.
     */

    return SNMP_ERR_NOTWRITABLE; /* Object not implemented */
} /* ieee8021BridgePortRequireDropEncoding_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ieee8021BridgePortPriorityTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * ieee8021BridgePortPriorityTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
ieee8021BridgePortRequireDropEncoding_undo_setup( ieee8021BridgePortPriorityTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:ieee8021BridgePortPriorityTable:ieee8021BridgePortRequireDropEncoding_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup ieee8021BridgePortRequireDropEncoding undo.
     */
    /*
     * copy ieee8021BridgePortRequireDropEncoding data
     * set rowreq_ctx->undo->ieee8021BridgePortRequireDropEncoding from rowreq_ctx->data.ieee8021BridgePortRequireDropEncoding
     */
    rowreq_ctx->undo->ieee8021BridgePortRequireDropEncoding = rowreq_ctx->data.ieee8021BridgePortRequireDropEncoding;


    return MFD_SUCCESS;
} /* ieee8021BridgePortRequireDropEncoding_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param ieee8021BridgePortRequireDropEncoding_val
 *        A long containing the new value.
 */
int
ieee8021BridgePortRequireDropEncoding_set( ieee8021BridgePortPriorityTable_rowreq_ctx *rowreq_ctx, u_long ieee8021BridgePortRequireDropEncoding_val )
{

    DEBUGMSGTL(("verbose:ieee8021BridgePortPriorityTable:ieee8021BridgePortRequireDropEncoding_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set ieee8021BridgePortRequireDropEncoding value.
     * set ieee8021BridgePortRequireDropEncoding value in rowreq_ctx->data
     */
    rowreq_ctx->data.ieee8021BridgePortRequireDropEncoding = ieee8021BridgePortRequireDropEncoding_val;

    return MFD_SUCCESS;
} /* ieee8021BridgePortRequireDropEncoding_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
ieee8021BridgePortRequireDropEncoding_undo( ieee8021BridgePortPriorityTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:ieee8021BridgePortPriorityTable:ieee8021BridgePortRequireDropEncoding_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up ieee8021BridgePortRequireDropEncoding undo.
     */
    /*
     * copy ieee8021BridgePortRequireDropEncoding data
     * set rowreq_ctx->data.ieee8021BridgePortRequireDropEncoding from rowreq_ctx->undo->ieee8021BridgePortRequireDropEncoding
     */
    rowreq_ctx->data.ieee8021BridgePortRequireDropEncoding = rowreq_ctx->undo->ieee8021BridgePortRequireDropEncoding;


    return MFD_SUCCESS;
} /* ieee8021BridgePortRequireDropEncoding_undo */

/*---------------------------------------------------------------------
 * IEEE8021-BRIDGE-MIB::ieee8021BridgePortPriorityEntry.ieee8021BridgePortServiceAccessPrioritySelection
 * ieee8021BridgePortServiceAccessPrioritySelection is subid 6 of ieee8021BridgePortPriorityEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.111.2.802.1.1.2.1.3.1.1.6
 * Description:
Indication of if the Service Access Priority Selection
        function is supported on the Customer Bridge Port to request
        priority handling of the frame from a Port-based service
        interface.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ieee8021BridgePortServiceAccessPrioritySelection_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 *
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * ieee8021BridgePortPriorityTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  true(1), false(2)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
ieee8021BridgePortServiceAccessPrioritySelection_check_value( ieee8021BridgePortPriorityTable_rowreq_ctx *rowreq_ctx, u_long ieee8021BridgePortServiceAccessPrioritySelection_val)
{
    DEBUGMSGTL(("verbose:ieee8021BridgePortPriorityTable:ieee8021BridgePortServiceAccessPrioritySelection_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid ieee8021BridgePortServiceAccessPrioritySelection value.
     */

    return SNMP_ERR_NOTWRITABLE; /* Object not implemented */
} /* ieee8021BridgePortServiceAccessPrioritySelection_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ieee8021BridgePortPriorityTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * ieee8021BridgePortPriorityTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
ieee8021BridgePortServiceAccessPrioritySelection_undo_setup( ieee8021BridgePortPriorityTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:ieee8021BridgePortPriorityTable:ieee8021BridgePortServiceAccessPrioritySelection_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup ieee8021BridgePortServiceAccessPrioritySelection undo.
     */
    /*
     * copy ieee8021BridgePortServiceAccessPrioritySelection data
     * set rowreq_ctx->undo->ieee8021BridgePortServiceAccessPrioritySelection from rowreq_ctx->data.ieee8021BridgePortServiceAccessPrioritySelection
     */
    rowreq_ctx->undo->ieee8021BridgePortServiceAccessPrioritySelection = rowreq_ctx->data.ieee8021BridgePortServiceAccessPrioritySelection;


    return MFD_SUCCESS;
} /* ieee8021BridgePortServiceAccessPrioritySelection_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param ieee8021BridgePortServiceAccessPrioritySelection_val
 *        A long containing the new value.
 */
int
ieee8021BridgePortServiceAccessPrioritySelection_set( ieee8021BridgePortPriorityTable_rowreq_ctx *rowreq_ctx, u_long ieee8021BridgePortServiceAccessPrioritySelection_val )
{

    DEBUGMSGTL(("verbose:ieee8021BridgePortPriorityTable:ieee8021BridgePortServiceAccessPrioritySelection_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set ieee8021BridgePortServiceAccessPrioritySelection value.
     * set ieee8021BridgePortServiceAccessPrioritySelection value in rowreq_ctx->data
     */
    rowreq_ctx->data.ieee8021BridgePortServiceAccessPrioritySelection = ieee8021BridgePortServiceAccessPrioritySelection_val;

    return MFD_SUCCESS;
} /* ieee8021BridgePortServiceAccessPrioritySelection_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
ieee8021BridgePortServiceAccessPrioritySelection_undo( ieee8021BridgePortPriorityTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:ieee8021BridgePortPriorityTable:ieee8021BridgePortServiceAccessPrioritySelection_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up ieee8021BridgePortServiceAccessPrioritySelection undo.
     */
    /*
     * copy ieee8021BridgePortServiceAccessPrioritySelection data
     * set rowreq_ctx->data.ieee8021BridgePortServiceAccessPrioritySelection from rowreq_ctx->undo->ieee8021BridgePortServiceAccessPrioritySelection
     */
    rowreq_ctx->data.ieee8021BridgePortServiceAccessPrioritySelection = rowreq_ctx->undo->ieee8021BridgePortServiceAccessPrioritySelection;


    return MFD_SUCCESS;
} /* ieee8021BridgePortServiceAccessPrioritySelection_undo */

/**
 * check dependencies
 *
 * This is useful for for tables which have dependencies between columns
 * (or rows, or tables). For example, two columns allocating a percentage
 * of something add up 100%.
 *
 * Should you need different behavior depending on which columns were
 * set, rowreq_ctx->column_set_flags will indicate which writeable columns were
 * set. The definitions for the COLUMN_*_FLAG bits can be found in
 * ieee8021BridgePortPriorityTable_oids.h.
 * A new row will have the MFD_ROW_CREATED bit set in rowreq_flags.
 *
 * @retval MFD_SUCCESS all the changes to the row are legal
 * @retval MFD_ERROR   one or more changes are not legal
 *
 * (see README-table-ieee8021BridgePortPriorityTable if you don't have dependencies)
 */
int
ieee8021BridgePortPriorityTable_check_dependencies(ieee8021BridgePortPriorityTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;

    DEBUGMSGTL(("internal:ieee8021BridgePortPriorityTable:ieee8021BridgePortPriorityTable_check_dependencies","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:470:o: Check ieee8021BridgePortPriorityTable row dependencies.
     * check that all new value are legal and consistent with each other
     */
    return rc;
} /* ieee8021BridgePortPriorityTable_check_dependencies */

/** @} */
