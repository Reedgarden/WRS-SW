/*
 * Note: this file originally auto-generated by mib2c using
 *       version : 12088 $ of $ 
 *
 * $Id:$
 */
/* standard Net-SNMP includes */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/* include our parent header */
#include "ieee8021BridgePortPriorityTable.h"


/** @defgroup data_get data_get: Routines to get data
 *
 * TODO:230:M: Implement ieee8021BridgePortPriorityTable get routines.
 * TODO:240:M: Implement ieee8021BridgePortPriorityTable mapping routines (if any).
 *
 * These routine are used to get the value for individual objects. The
 * row context is passed, along with a pointer to the memory where the
 * value should be copied.
 *
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table ieee8021BridgePortPriorityTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * IEEE8021-BRIDGE-MIB::ieee8021BridgePortPriorityTable is subid 1 of ieee8021BridgePriority.
 * Its status is Current.
 * OID: .1.3.111.2.802.1.1.2.1.3.1, length: 11
*/

/* ---------------------------------------------------------------------
 * TODO:200:r: Implement ieee8021BridgePortPriorityTable data context functions.
 */


/**
 * set mib index(es)
 *
 * @param tbl_idx mib index structure
 * @param ieee8021BridgeBasePortComponentId_val
 * @param ieee8021BridgeBasePort_val
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This convenience function is useful for setting all the MIB index
 *  components with a single function call. It is assume that the C values
 *  have already been mapped from their native/rawformat to the MIB format.
 */
int
ieee8021BridgePortPriorityTable_indexes_set_tbl_idx(ieee8021BridgePortPriorityTable_mib_index *tbl_idx, u_long ieee8021BridgeBasePortComponentId_val, u_long ieee8021BridgeBasePort_val)
{
    DEBUGMSGTL(("verbose:ieee8021BridgePortPriorityTable:ieee8021BridgePortPriorityTable_indexes_set_tbl_idx","called\n"));

    /* ieee8021BridgeBasePortComponentId(1)/IEEE8021PbbComponentIdentifier/ASN_UNSIGNED/u_long(u_long)//l/a/w/e/R/d/H */
    tbl_idx->ieee8021BridgeBasePortComponentId = ieee8021BridgeBasePortComponentId_val;
    
    /* ieee8021BridgeBasePort(2)/IEEE8021BridgePortNumber/ASN_UNSIGNED/u_long(u_long)//l/a/w/e/R/d/H */
    tbl_idx->ieee8021BridgeBasePort = ieee8021BridgeBasePort_val;
    

    return MFD_SUCCESS;
} /* ieee8021BridgePortPriorityTable_indexes_set_tbl_idx */

/**
 * @internal
 * set row context indexes
 *
 * @param reqreq_ctx the row context that needs updated indexes
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This function sets the mib indexs, then updates the oid indexs
 *  from the mib index.
 */
int
ieee8021BridgePortPriorityTable_indexes_set(ieee8021BridgePortPriorityTable_rowreq_ctx *rowreq_ctx, u_long ieee8021BridgeBasePortComponentId_val, u_long ieee8021BridgeBasePort_val)
{
    DEBUGMSGTL(("verbose:ieee8021BridgePortPriorityTable:ieee8021BridgePortPriorityTable_indexes_set","called\n"));

    if(MFD_SUCCESS != ieee8021BridgePortPriorityTable_indexes_set_tbl_idx(&rowreq_ctx->tbl_idx
                                   , ieee8021BridgeBasePortComponentId_val
                                   , ieee8021BridgeBasePort_val
           ))
        return MFD_ERROR;

    /*
     * convert mib index to oid index
     */
    rowreq_ctx->oid_idx.len = sizeof(rowreq_ctx->oid_tmp) / sizeof(oid);
    if(0 != ieee8021BridgePortPriorityTable_index_to_oid(&rowreq_ctx->oid_idx,
                                    &rowreq_ctx->tbl_idx)) {
        return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* ieee8021BridgePortPriorityTable_indexes_set */


/*---------------------------------------------------------------------
 * IEEE8021-BRIDGE-MIB::ieee8021BridgePortPriorityEntry.ieee8021BridgePortDefaultUserPriority
 * ieee8021BridgePortDefaultUserPriority is subid 1 of ieee8021BridgePortPriorityEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.111.2.802.1.1.2.1.3.1.1.1
 * Description:
The default ingress User Priority for this port.  This
        only has effect on media, such as Ethernet, that do not
        support native User Priority.

        The value of this object MUST be retained across
        reinitializations of the management system.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   1
 *   hint: d
 *
 * Ranges:  0 - 7;
 *
 * Its syntax is IEEE8021PriorityValue (based on perltype UNSIGNED32)
 * The net-snmp type is ASN_UNSIGNED. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the ieee8021BridgePortDefaultUserPriority data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ieee8021BridgePortDefaultUserPriority_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ieee8021BridgePortDefaultUserPriority_get( ieee8021BridgePortPriorityTable_rowreq_ctx *rowreq_ctx, u_long * ieee8021BridgePortDefaultUserPriority_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != ieee8021BridgePortDefaultUserPriority_val_ptr );


    DEBUGMSGTL(("verbose:ieee8021BridgePortPriorityTable:ieee8021BridgePortDefaultUserPriority_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the ieee8021BridgePortDefaultUserPriority data.
 * copy (* ieee8021BridgePortDefaultUserPriority_val_ptr ) from rowreq_ctx->data
 */
    (* ieee8021BridgePortDefaultUserPriority_val_ptr ) = rowreq_ctx->data.ieee8021BridgePortDefaultUserPriority;

    return MFD_SUCCESS;
} /* ieee8021BridgePortDefaultUserPriority_get */

/*---------------------------------------------------------------------
 * IEEE8021-BRIDGE-MIB::ieee8021BridgePortPriorityEntry.ieee8021BridgePortNumTrafficClasses
 * ieee8021BridgePortNumTrafficClasses is subid 2 of ieee8021BridgePortPriorityEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.111.2.802.1.1.2.1.3.1.1.2
 * Description:
The number of egress traffic classes supported on this
        port.  This object may optionally be read-only.

        The value of this object MUST be retained across
        reinitializations of the management system.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   0
 *   settable   1
 *
 * Ranges:  1 - 8;
 *
 * Its syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the ieee8021BridgePortNumTrafficClasses data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ieee8021BridgePortNumTrafficClasses_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ieee8021BridgePortNumTrafficClasses_get( ieee8021BridgePortPriorityTable_rowreq_ctx *rowreq_ctx, long * ieee8021BridgePortNumTrafficClasses_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != ieee8021BridgePortNumTrafficClasses_val_ptr );


    DEBUGMSGTL(("verbose:ieee8021BridgePortPriorityTable:ieee8021BridgePortNumTrafficClasses_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the ieee8021BridgePortNumTrafficClasses data.
 * copy (* ieee8021BridgePortNumTrafficClasses_val_ptr ) from rowreq_ctx->data
 */
    (* ieee8021BridgePortNumTrafficClasses_val_ptr ) = rowreq_ctx->data.ieee8021BridgePortNumTrafficClasses;

    return MFD_SUCCESS;
} /* ieee8021BridgePortNumTrafficClasses_get */

/*---------------------------------------------------------------------
 * IEEE8021-BRIDGE-MIB::ieee8021BridgePortPriorityEntry.ieee8021BridgePortPriorityCodePointSelection
 * ieee8021BridgePortPriorityCodePointSelection is subid 3 of ieee8021BridgePortPriorityEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.111.2.802.1.1.2.1.3.1.1.3
 * Description:
 This object identifies the rows in the PCP encoding and
          decoding tables that are used to remark frames on this 
          port if this remarking is enabled.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 3/8. Values:  codePoint8p0d(1), codePoint7p1d(2), codePoint6p2d(3), codePoint5p3d(4)
 *
 * Its syntax is IEEE8021PriorityCodePoint (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the ieee8021BridgePortPriorityCodePointSelection data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ieee8021BridgePortPriorityCodePointSelection_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ieee8021BridgePortPriorityCodePointSelection_get( ieee8021BridgePortPriorityTable_rowreq_ctx *rowreq_ctx, u_long * ieee8021BridgePortPriorityCodePointSelection_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != ieee8021BridgePortPriorityCodePointSelection_val_ptr );


    DEBUGMSGTL(("verbose:ieee8021BridgePortPriorityTable:ieee8021BridgePortPriorityCodePointSelection_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the ieee8021BridgePortPriorityCodePointSelection data.
 * copy (* ieee8021BridgePortPriorityCodePointSelection_val_ptr ) from rowreq_ctx->data
 */
    (* ieee8021BridgePortPriorityCodePointSelection_val_ptr ) = rowreq_ctx->data.ieee8021BridgePortPriorityCodePointSelection;

    return MFD_SUCCESS;
} /* ieee8021BridgePortPriorityCodePointSelection_get */

/*---------------------------------------------------------------------
 * IEEE8021-BRIDGE-MIB::ieee8021BridgePortPriorityEntry.ieee8021BridgePortUseDEI
 * ieee8021BridgePortUseDEI is subid 4 of ieee8021BridgePortPriorityEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.111.2.802.1.1.2.1.3.1.1.4
 * Description:
If the Use_DEI is set to true(1) for the Port then the 
        drop_eligible parameter is encoded in the DEI of transmitted
        frames, and the drop_eligible parameter shall be true(1) for a
        received frame if the DEI is set in the S-TAG or the Priority
        Code Point Decoding Table indicates drop_eligible True for
        the received PCP value. If the Use_DEI parameter is false(2),
        the DEI shall be transmitted as zero and ignored on receipt.
        The default value of the Use_DEI parameter is false(2).
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the ieee8021BridgePortUseDEI data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ieee8021BridgePortUseDEI_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ieee8021BridgePortUseDEI_get( ieee8021BridgePortPriorityTable_rowreq_ctx *rowreq_ctx, u_long * ieee8021BridgePortUseDEI_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != ieee8021BridgePortUseDEI_val_ptr );


    DEBUGMSGTL(("verbose:ieee8021BridgePortPriorityTable:ieee8021BridgePortUseDEI_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the ieee8021BridgePortUseDEI data.
 * copy (* ieee8021BridgePortUseDEI_val_ptr ) from rowreq_ctx->data
 */
    (* ieee8021BridgePortUseDEI_val_ptr ) = rowreq_ctx->data.ieee8021BridgePortUseDEI;

    return MFD_SUCCESS;
} /* ieee8021BridgePortUseDEI_get */

/*---------------------------------------------------------------------
 * IEEE8021-BRIDGE-MIB::ieee8021BridgePortPriorityEntry.ieee8021BridgePortRequireDropEncoding
 * ieee8021BridgePortRequireDropEncoding is subid 5 of ieee8021BridgePortPriorityEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.111.2.802.1.1.2.1.3.1.1.5
 * Description:
If a Bridge supports encoding or decoding of drop_eligible
        from the PCP field of a VLAN tag (6.7.3) on any of its Ports,
        then it shall implement a Boolean parameter Require Drop
        Encoding on each of its Ports with default value false(2). If
        Require Drop Encoding is True and the Bridge Port cannot
        encode particular priorities with drop_eligible, then frames
        queued with those priorities and drop_eligible true(1) shall
        be discarded and not transmitted.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 1
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *   defval: false
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the ieee8021BridgePortRequireDropEncoding data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ieee8021BridgePortRequireDropEncoding_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ieee8021BridgePortRequireDropEncoding_get( ieee8021BridgePortPriorityTable_rowreq_ctx *rowreq_ctx, u_long * ieee8021BridgePortRequireDropEncoding_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != ieee8021BridgePortRequireDropEncoding_val_ptr );


    DEBUGMSGTL(("verbose:ieee8021BridgePortPriorityTable:ieee8021BridgePortRequireDropEncoding_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the ieee8021BridgePortRequireDropEncoding data.
 * copy (* ieee8021BridgePortRequireDropEncoding_val_ptr ) from rowreq_ctx->data
 */
    (* ieee8021BridgePortRequireDropEncoding_val_ptr ) = rowreq_ctx->data.ieee8021BridgePortRequireDropEncoding;

    return MFD_SUCCESS;
} /* ieee8021BridgePortRequireDropEncoding_get */

/*---------------------------------------------------------------------
 * IEEE8021-BRIDGE-MIB::ieee8021BridgePortPriorityEntry.ieee8021BridgePortServiceAccessPrioritySelection
 * ieee8021BridgePortServiceAccessPrioritySelection is subid 6 of ieee8021BridgePortPriorityEntry.
 * Its status is Current, and its access level is ReadWrite.
 * OID: .1.3.111.2.802.1.1.2.1.3.1.1.6
 * Description:
Indication of if the Service Access Priority Selection
        function is supported on the Customer Bridge Port to request
        priority handling of the frame from a Port-based service
        interface.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the ieee8021BridgePortServiceAccessPrioritySelection data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ieee8021BridgePortServiceAccessPrioritySelection_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ieee8021BridgePortServiceAccessPrioritySelection_get( ieee8021BridgePortPriorityTable_rowreq_ctx *rowreq_ctx, u_long * ieee8021BridgePortServiceAccessPrioritySelection_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != ieee8021BridgePortServiceAccessPrioritySelection_val_ptr );


    DEBUGMSGTL(("verbose:ieee8021BridgePortPriorityTable:ieee8021BridgePortServiceAccessPrioritySelection_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the ieee8021BridgePortServiceAccessPrioritySelection data.
 * copy (* ieee8021BridgePortServiceAccessPrioritySelection_val_ptr ) from rowreq_ctx->data
 */
    (* ieee8021BridgePortServiceAccessPrioritySelection_val_ptr ) = rowreq_ctx->data.ieee8021BridgePortServiceAccessPrioritySelection;

    return MFD_SUCCESS;
} /* ieee8021BridgePortServiceAccessPrioritySelection_get */



/** @} */
