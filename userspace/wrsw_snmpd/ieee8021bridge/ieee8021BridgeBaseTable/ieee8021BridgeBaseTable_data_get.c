/*
 * Note: this file originally auto-generated by mib2c using
 *       version : 12088 $ of $
 *
 * $Id:$
 */
/* standard Net-SNMP includes */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/* include our parent header */
#include "ieee8021BridgeBaseTable.h"


/** @defgroup data_get data_get: Routines to get data
 *
 * TODO:230:M: Implement ieee8021BridgeBaseTable get routines.
 * TODO:240:M: Implement ieee8021BridgeBaseTable mapping routines (if any).
 *
 * These routine are used to get the value for individual objects. The
 * row context is passed, along with a pointer to the memory where the
 * value should be copied.
 *
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table ieee8021BridgeBaseTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * IEEE8021-BRIDGE-MIB::ieee8021BridgeBaseTable is subid 1 of ieee8021BridgeBase.
 * Its status is Current.
 * OID: .1.3.111.2.802.1.1.2.1.1.1, length: 11
*/

/* ---------------------------------------------------------------------
 * TODO:200:r: Implement ieee8021BridgeBaseTable data context functions.
 */


/**
 * set mib index(es)
 *
 * @param tbl_idx mib index structure
 * @param ieee8021BridgeBaseComponentId_val
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This convenience function is useful for setting all the MIB index
 *  components with a single function call. It is assume that the C values
 *  have already been mapped from their native/rawformat to the MIB format.
 */
int
ieee8021BridgeBaseTable_indexes_set_tbl_idx(ieee8021BridgeBaseTable_mib_index *tbl_idx, u_long ieee8021BridgeBaseComponentId_val)
{
    DEBUGMSGTL(("verbose:ieee8021BridgeBaseTable:ieee8021BridgeBaseTable_indexes_set_tbl_idx","called\n"));

    /* ieee8021BridgeBaseComponentId(1)/IEEE8021PbbComponentIdentifier/ASN_UNSIGNED/u_long(u_long)//l/a/w/e/R/d/H */
    tbl_idx->ieee8021BridgeBaseComponentId = ieee8021BridgeBaseComponentId_val;


    return MFD_SUCCESS;
} /* ieee8021BridgeBaseTable_indexes_set_tbl_idx */

/**
 * @internal
 * set row context indexes
 *
 * @param reqreq_ctx the row context that needs updated indexes
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This function sets the mib indexs, then updates the oid indexs
 *  from the mib index.
 */
int
ieee8021BridgeBaseTable_indexes_set(ieee8021BridgeBaseTable_rowreq_ctx *rowreq_ctx, u_long ieee8021BridgeBaseComponentId_val)
{
    DEBUGMSGTL(("verbose:ieee8021BridgeBaseTable:ieee8021BridgeBaseTable_indexes_set","called\n"));

    if(MFD_SUCCESS != ieee8021BridgeBaseTable_indexes_set_tbl_idx(&rowreq_ctx->tbl_idx
                                   , ieee8021BridgeBaseComponentId_val
           ))
        return MFD_ERROR;

    /*
     * convert mib index to oid index
     */
    rowreq_ctx->oid_idx.len = sizeof(rowreq_ctx->oid_tmp) / sizeof(oid);
    if(0 != ieee8021BridgeBaseTable_index_to_oid(&rowreq_ctx->oid_idx,
                                    &rowreq_ctx->tbl_idx)) {
        return MFD_ERROR;
    }

    return MFD_SUCCESS;
} /* ieee8021BridgeBaseTable_indexes_set */


/*---------------------------------------------------------------------
 * IEEE8021-BRIDGE-MIB::ieee8021BridgeBaseEntry.ieee8021BridgeBaseBridgeAddress
 * ieee8021BridgeBaseBridgeAddress is subid 2 of ieee8021BridgeBaseEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.111.2.802.1.1.2.1.1.1.1.2
 * Description:
The MAC address used by this bridge when it must be
        referred to in a unique fashion.  It is recommended
        that this be the numerically smallest MAC address of
        all ports that belong to this bridge.  However, it is
        only required to be unique.  When concatenated with
        ieee8021SpanningTreePriority, a unique BridgeIdentifier
        is formed, which is used in the Spanning Tree Protocol.

        This object may not be modified while the corresponding
        instance of ieee8021BridgeBaseRowStatus is active(1).

        The value of this object MUST be retained across
        reinitializations of the management system.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   1
 *   hint: 1x:
 *
 * Ranges:  6;
 *
 * Its syntax is MacAddress (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 6)
 */
/**
 * Extract the current value of the ieee8021BridgeBaseBridgeAddress data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ieee8021BridgeBaseBridgeAddress_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param ieee8021BridgeBaseBridgeAddress_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by ieee8021BridgeBaseBridgeAddress.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*ieee8021BridgeBaseBridgeAddress_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update ieee8021BridgeBaseBridgeAddress_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
ieee8021BridgeBaseBridgeAddress_get( ieee8021BridgeBaseTable_rowreq_ctx *rowreq_ctx, char **ieee8021BridgeBaseBridgeAddress_val_ptr_ptr, size_t *ieee8021BridgeBaseBridgeAddress_val_ptr_len_ptr )
{
   /** we should have a non-NULL pointer and enough storage */
   netsnmp_assert( (NULL != ieee8021BridgeBaseBridgeAddress_val_ptr_ptr) && (NULL != *ieee8021BridgeBaseBridgeAddress_val_ptr_ptr));
   netsnmp_assert( NULL != ieee8021BridgeBaseBridgeAddress_val_ptr_len_ptr );


    DEBUGMSGTL(("verbose:ieee8021BridgeBaseTable:ieee8021BridgeBaseBridgeAddress_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the ieee8021BridgeBaseBridgeAddress data.
 * copy (* ieee8021BridgeBaseBridgeAddress_val_ptr_ptr ) data and (* ieee8021BridgeBaseBridgeAddress_val_ptr_len_ptr ) from rowreq_ctx->data
 */
    /*
     * make sure there is enough space for ieee8021BridgeBaseBridgeAddress data
     */
    if ((NULL == (* ieee8021BridgeBaseBridgeAddress_val_ptr_ptr )) ||
        ((* ieee8021BridgeBaseBridgeAddress_val_ptr_len_ptr ) <
         (rowreq_ctx->data.ieee8021BridgeBaseBridgeAddress_len* sizeof(rowreq_ctx->data.ieee8021BridgeBaseBridgeAddress[0])))) {
        /*
         * allocate space for ieee8021BridgeBaseBridgeAddress data
         */
        (* ieee8021BridgeBaseBridgeAddress_val_ptr_ptr ) = malloc(rowreq_ctx->data.ieee8021BridgeBaseBridgeAddress_len* sizeof(rowreq_ctx->data.ieee8021BridgeBaseBridgeAddress[0]));
        if(NULL == (* ieee8021BridgeBaseBridgeAddress_val_ptr_ptr )) {
            snmp_log(LOG_ERR,"could not allocate memory\n");
            return MFD_ERROR;
        }
    }
    (* ieee8021BridgeBaseBridgeAddress_val_ptr_len_ptr ) = rowreq_ctx->data.ieee8021BridgeBaseBridgeAddress_len* sizeof(rowreq_ctx->data.ieee8021BridgeBaseBridgeAddress[0]);
    memcpy( (* ieee8021BridgeBaseBridgeAddress_val_ptr_ptr ), rowreq_ctx->data.ieee8021BridgeBaseBridgeAddress, rowreq_ctx->data.ieee8021BridgeBaseBridgeAddress_len* sizeof(rowreq_ctx->data.ieee8021BridgeBaseBridgeAddress[0]) );

    return MFD_SUCCESS;
} /* ieee8021BridgeBaseBridgeAddress_get */

/*---------------------------------------------------------------------
 * IEEE8021-BRIDGE-MIB::ieee8021BridgeBaseEntry.ieee8021BridgeBaseNumPorts
 * ieee8021BridgeBaseNumPorts is subid 3 of ieee8021BridgeBaseEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.111.2.802.1.1.2.1.1.1.1.3
 * Description:
The number of ports controlled by this bridging
        entity.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is INTEGER32 (based on perltype INTEGER32)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (long)
 */
/**
 * Extract the current value of the ieee8021BridgeBaseNumPorts data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ieee8021BridgeBaseNumPorts_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ieee8021BridgeBaseNumPorts_get( ieee8021BridgeBaseTable_rowreq_ctx *rowreq_ctx, long * ieee8021BridgeBaseNumPorts_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != ieee8021BridgeBaseNumPorts_val_ptr );


    DEBUGMSGTL(("verbose:ieee8021BridgeBaseTable:ieee8021BridgeBaseNumPorts_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the ieee8021BridgeBaseNumPorts data.
 * copy (* ieee8021BridgeBaseNumPorts_val_ptr ) from rowreq_ctx->data
 */
    (* ieee8021BridgeBaseNumPorts_val_ptr ) = rowreq_ctx->data.ieee8021BridgeBaseNumPorts;

    return MFD_SUCCESS;
} /* ieee8021BridgeBaseNumPorts_get */

/*---------------------------------------------------------------------
 * IEEE8021-BRIDGE-MIB::ieee8021BridgeBaseEntry.ieee8021BridgeBaseComponentType
 * ieee8021BridgeBaseComponentType is subid 4 of ieee8021BridgeBaseEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.111.2.802.1.1.2.1.1.1.1.4
 * Description:
Indicates the component type(s) of this bridge.  The
        following component types are possible:

            iComponent(1) - An S-VLAN aware component of a Backbone
                Edge Bridge which performs encapsulation of customer
                frames.

            bComponent(2) - An S-VLAN aware component of a Backbone
                Edge Bridge which bundles backbone service instances
                into B-VLANs.

            cVlanComponent(3) - A C-VLAN aware component of an
                enterprise VLAN bridge or of a Provider Bridge used
                to process C-tagged frames.

            sVlanComponent(4) - An S-VLAN aware component of a
                Provider Bridge.

            dBridgeComponent(5) - A VLAN unaware component of an
                802.1D bridge.

        This object may not be modified while the corresponding
        instance of ieee8021BridgeBaseRowStatus is active(1).

        The value of this object MUST be retained across
        reinitializations of the management system.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 3/8. Values:  iComponent(1), bComponent(2), cVlanComponent(3), sVlanComponent(4), dBridgeComponent(5)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the ieee8021BridgeBaseComponentType data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ieee8021BridgeBaseComponentType_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ieee8021BridgeBaseComponentType_get( ieee8021BridgeBaseTable_rowreq_ctx *rowreq_ctx, u_long * ieee8021BridgeBaseComponentType_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != ieee8021BridgeBaseComponentType_val_ptr );


    DEBUGMSGTL(("verbose:ieee8021BridgeBaseTable:ieee8021BridgeBaseComponentType_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the ieee8021BridgeBaseComponentType data.
 * copy (* ieee8021BridgeBaseComponentType_val_ptr ) from rowreq_ctx->data
 */
    (* ieee8021BridgeBaseComponentType_val_ptr ) = rowreq_ctx->data.ieee8021BridgeBaseComponentType;

    return MFD_SUCCESS;
} /* ieee8021BridgeBaseComponentType_get */

/*---------------------------------------------------------------------
 * IEEE8021-BRIDGE-MIB::ieee8021BridgeBaseEntry.ieee8021BridgeBaseDeviceCapabilities
 * ieee8021BridgeBaseDeviceCapabilities is subid 5 of ieee8021BridgeBaseEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.111.2.802.1.1.2.1.1.1.1.5
 * Description:
Indicates the optional parts of IEEE 802.1D and 802.1Q
        that are implemented by this device and are manageable
        through this MIB.  Capabilities that are allowed on a
        per-port basis are indicated in
        ieee8021BridgeBasePortCapabilities.

        dot1dExtendedFilteringServices(0),
                              -- can perform filtering of
                              -- individual multicast addresses
                              -- controlled by MMRP.
        dot1dTrafficClasses(1),
                              -- can map user priority to
                              -- multiple traffic classes.
        dot1qStaticEntryIndividualPort(2),
                              -- dot1qStaticUnicastReceivePort &
                              -- dot1qStaticMulticastReceivePort
                              -- can represent non-zero entries.
        dot1qIVLCapable(3),   -- Independent VLAN Learning (IVL).
        dot1qSVLCapable(4),   -- Shared VLAN Learning (SVL).
        dot1qHybridCapable(5),
                              -- both IVL & SVL simultaneously.
        dot1qConfigurablePvidTagging(6),
                              -- whether the implementation
                              -- supports the ability to
                              -- override the default PVID
                              -- setting and its egress status
                              -- (VLAN-Tagged or Untagged) on
                              -- each port.
        dot1dLocalVlanCapable(7)
                              -- can support multiple local
                              -- bridges, outside of the scope
                              -- of 802.1Q defined VLANs.

        This object may not be modified while the corresponding
        instance of ieee8021BridgeBaseRowStatus is active(1).

        The value of this object MUST be retained across
        reinitializations of the management system.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 5/8. Values:  dot1dExtendedFilteringServices(0), dot1dTrafficClasses(1), dot1qStaticEntryIndividualPort(2), dot1qIVLCapable(3), dot1qSVLCapable(4), dot1qHybridCapable(5), dot1qConfigurablePvidTagging(6), dot1dLocalVlanCapable(7)
 *
 * Its syntax is BITS (based on perltype BITS)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (u_long)
 * This data type requires a length.
 */
/**
 * Extract the current value of the ieee8021BridgeBaseDeviceCapabilities data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ieee8021BridgeBaseDeviceCapabilities_val_ptr
 *        Pointer to storage for a char variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ieee8021BridgeBaseDeviceCapabilities_get( ieee8021BridgeBaseTable_rowreq_ctx *rowreq_ctx, u_long * ieee8021BridgeBaseDeviceCapabilities_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != ieee8021BridgeBaseDeviceCapabilities_val_ptr );


    DEBUGMSGTL(("verbose:ieee8021BridgeBaseTable:ieee8021BridgeBaseDeviceCapabilities_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the ieee8021BridgeBaseDeviceCapabilities data.
 * copy (* ieee8021BridgeBaseDeviceCapabilities_val_ptr ) from rowreq_ctx->data
 */
    /*
     * TODO:242:o: update or replace BITS tests (get).
     * If ieee8021BridgeBaseDeviceCapabilities data is stored in SNMP BIT order, individual
     * bit tests are redundant, and you can do a straight copy. If not, then
     * update each if condition to test the correct bit.
     *
     * NOTE WELL: setting bit '0' for:
     *             C  0x0000001
     *          SNMP  0x8000000
     *
     * assuming generated code keeps ieee8021BridgeBaseDeviceCapabilities BITS in SNMP order.
     */
    (* ieee8021BridgeBaseDeviceCapabilities_val_ptr ) =
        rowreq_ctx->data.ieee8021BridgeBaseDeviceCapabilities;

    return MFD_SUCCESS;
} /* ieee8021BridgeBaseDeviceCapabilities_get */

/*---------------------------------------------------------------------
 * IEEE8021-BRIDGE-MIB::ieee8021BridgeBaseEntry.ieee8021BridgeBaseTrafficClassesEnabled
 * ieee8021BridgeBaseTrafficClassesEnabled is subid 6 of ieee8021BridgeBaseEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.111.2.802.1.1.2.1.1.1.1.6
 * Description:
The value true(1) indicates that Traffic Classes are
        enabled on this bridge.  When false(2), the bridge
        operates with a single priority level for all traffic.

        This object may be modified while the corresponding
        instance of ieee8021BridgeBaseRowStatus is active(1).

        The value of this object MUST be retained across
        reinitializations of the management system.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 1
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *   defval: true
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the ieee8021BridgeBaseTrafficClassesEnabled data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ieee8021BridgeBaseTrafficClassesEnabled_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ieee8021BridgeBaseTrafficClassesEnabled_get( ieee8021BridgeBaseTable_rowreq_ctx *rowreq_ctx, u_long * ieee8021BridgeBaseTrafficClassesEnabled_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != ieee8021BridgeBaseTrafficClassesEnabled_val_ptr );


    DEBUGMSGTL(("verbose:ieee8021BridgeBaseTable:ieee8021BridgeBaseTrafficClassesEnabled_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the ieee8021BridgeBaseTrafficClassesEnabled data.
 * copy (* ieee8021BridgeBaseTrafficClassesEnabled_val_ptr ) from rowreq_ctx->data
 */
    (* ieee8021BridgeBaseTrafficClassesEnabled_val_ptr ) = rowreq_ctx->data.ieee8021BridgeBaseTrafficClassesEnabled;

    return MFD_SUCCESS;
} /* ieee8021BridgeBaseTrafficClassesEnabled_get */

/*---------------------------------------------------------------------
 * IEEE8021-BRIDGE-MIB::ieee8021BridgeBaseEntry.ieee8021BridgeBaseMmrpEnabledStatus
 * ieee8021BridgeBaseMmrpEnabledStatus is subid 7 of ieee8021BridgeBaseEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.111.2.802.1.1.2.1.1.1.1.7
 * Description:
The administrative status requested by management for
        MMRP.  The value true(1) indicates that MMRP should
        be enabled on this device, in all VLANs, on all ports
        for which it has not been specifically disabled.  When
        false(2), MMRP is disabled, in all VLANs and on all
        ports, and all MMRP packets will be forwarded
        transparently.  This object affects both Applicant and
        Registrar state machines.  A transition from false(2)
        to true(1) will cause a reset of all MMRP state
        machines on all ports.

        This object may be modified while the corresponding
        instance of ieee8021BridgeBaseRowStatus is active(1).

        The value of this object MUST be retained across
        reinitializations of the management system.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 1
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *   defval: true
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the ieee8021BridgeBaseMmrpEnabledStatus data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ieee8021BridgeBaseMmrpEnabledStatus_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ieee8021BridgeBaseMmrpEnabledStatus_get( ieee8021BridgeBaseTable_rowreq_ctx *rowreq_ctx, u_long * ieee8021BridgeBaseMmrpEnabledStatus_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != ieee8021BridgeBaseMmrpEnabledStatus_val_ptr );


    DEBUGMSGTL(("verbose:ieee8021BridgeBaseTable:ieee8021BridgeBaseMmrpEnabledStatus_get","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

/*
 * TODO:231:o: |-> Extract the current value of the ieee8021BridgeBaseMmrpEnabledStatus data.
 * copy (* ieee8021BridgeBaseMmrpEnabledStatus_val_ptr ) from rowreq_ctx->data
 */
    (* ieee8021BridgeBaseMmrpEnabledStatus_val_ptr ) = rowreq_ctx->data.ieee8021BridgeBaseMmrpEnabledStatus;

    return MFD_SUCCESS;
} /* ieee8021BridgeBaseMmrpEnabledStatus_get */

/*---------------------------------------------------------------------
 * IEEE8021-BRIDGE-MIB::ieee8021BridgeBaseEntry.ieee8021BridgeBaseRowStatus
 * ieee8021BridgeBaseRowStatus is subid 8 of ieee8021BridgeBaseEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.111.2.802.1.1.2.1.1.1.1.8
 * Description:
The object indicates the status of an entry, and is used
        to create/delete entries.

        The following objects must be set prior to making a new
        entry active:
            ieee8021BridgeBaseBridgeAddress
            ieee8021BridgeBaseComponentType
            ieee8021BridgeBaseDeviceCapabilities
        It is recommended that these three objects not be allowed
        to be modified while the corresponding instance of
        ieee8021BridgeBaseRowStatus object is active(1).

        The following objects are not required to be set before
        making a new entry active (they will take their defaults),
        and they also may be modified while the corresponding
        instance of this object is active(1):
            ieee8021BridgeBaseTrafficClassesEnabled
            ieee8021BridgeBaseMmrpEnabledStatus

        The value of this object and all corresponding instances
        of other objects in this table MUST be retained across
        reinitializations of the management system.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 3/8. Values:  active(1), notInService(2), notReady(3), createAndGo(4), createAndWait(5), destroy(6)
 *
 * Its syntax is RowStatus (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Extract the current value of the ieee8021BridgeBaseRowStatus data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ieee8021BridgeBaseRowStatus_val_ptr
 *        Pointer to storage for a long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
ieee8021BridgeBaseRowStatus_get( ieee8021BridgeBaseTable_rowreq_ctx *rowreq_ctx, u_long * ieee8021BridgeBaseRowStatus_val_ptr )
{
   /** we should have a non-NULL pointer */
   netsnmp_assert( NULL != ieee8021BridgeBaseRowStatus_val_ptr );

    (* ieee8021BridgeBaseRowStatus_val_ptr ) = rowreq_ctx->data.ieee8021BridgeBaseRowStatus;

    return MFD_SUCCESS;
} /* ieee8021BridgeBaseRowStatus_get */



/** @} */
