/*
 * Note: this file originally auto-generated by mib2c using
 *       version : 12077 $ of $
 *
 * $Id:$
 *
 */
/* standard Net-SNMP includes */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/* include our parent header */
#include "ieee8021BridgeBaseTable.h"


/** @defgroup data_set data_set: Routines to set data
 *
 * These routines are used to set the value for individual objects. The
 * row context is passed, along with the new value.
 *
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table ieee8021BridgeBaseTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * IEEE8021-BRIDGE-MIB::ieee8021BridgeBaseTable is subid 1 of ieee8021BridgeBase.
 * Its status is Current.
 * OID: .1.3.111.2.802.1.1.2.1.1.1, length: 11
*/
    /*
     * NOTE: if you update this chart, please update the versions in
     *       local/mib2c-conf.d/parent-set.m2i
     *       agent/mibgroup/helpers/baby_steps.c
     * while you're at it.
     */
    /*
     ***********************************************************************
     * Baby Steps Flow Chart (2004.06.05)                                  *
     *                                                                     *
     * +--------------+    +================+    U = unconditional path    *
     * |optional state|    ||required state||    S = path for success      *
     * +--------------+    +================+    E = path for error        *
     ***********************************************************************
     *
     *                        +--------------+
     *                        |     pre      |
     *                        |   request    |
     *                        +--------------+
     *                               | U
     * +-------------+        +==============+
     * |    row    |f|<-------||  object    ||
     * |  create   |1|      E ||  lookup    ||
     * +-------------+        +==============+
     *     E |   | S                 | S
     *       |   +------------------>|
     *       |                +==============+
     *       |              E ||   check    ||
     *       |<---------------||   values   ||
     *       |                +==============+
     *       |                       | S
     *       |                +==============+
     *       |       +<-------||   undo     ||
     *       |       |      E ||   setup    ||
     *       |       |        +==============+
     *       |       |               | S
     *       |       |        +==============+
     *       |       |        ||    set     ||-------------------------->+
     *       |       |        ||   value    || E                         |
     *       |       |        +==============+                           |
     *       |       |               | S                                 |
     *       |       |        +--------------+                           |
     *       |       |        |    check     |-------------------------->|
     *       |       |        |  consistency | E                         |
     *       |       |        +--------------+                           |
     *       |       |               | S                                 |
     *       |       |        +==============+         +==============+  |
     *       |       |        ||   commit   ||-------->||     undo   ||  |
     *       |       |        ||            || E       ||    commit  ||  |
     *       |       |        +==============+         +==============+  |
     *       |       |               | S                     U |<--------+
     *       |       |        +--------------+         +==============+
     *       |       |        | irreversible |         ||    undo    ||
     *       |       |        |    commit    |         ||     set    ||
     *       |       |        +--------------+         +==============+
     *       |       |               | U                     U |
     *       |       +-------------->|<------------------------+
     *       |                +==============+
     *       |                ||   undo     ||
     *       |                ||  cleanup   ||
     *       |                +==============+
     *       +---------------------->| U
     *                               |
     *                          (err && f1)------------------->+
     *                               |                         |
     *                        +--------------+         +--------------+
     *                        |    post      |<--------|      row     |
     *                        |   request    |       U |    release   |
     *                        +--------------+         +--------------+
     *
     */

/**
 * Setup up context with information needed to undo a set request.
 *
 * This function will be called before the individual node undo setup
 * functions are called. If you need to do any undo setup that is not
 * related to a specific column, you can do it here.
 *
 * Note that the undo context has been allocated with
 * ieee8021BridgeBaseTable_allocate_data(), but may need extra
 * initialization similar to what you may have done in
 * ieee8021BridgeBaseTable_rowreq_ctx_init().
 * Note that an individual node's undo_setup function will only be called
 * if that node is being set to a new value.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in the node's undo_setup
 * function, so it won't be done unless it is necessary.
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ieee8021BridgeBaseTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 */
int
ieee8021BridgeBaseTable_undo_setup( ieee8021BridgeBaseTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:ieee8021BridgeBaseTable:ieee8021BridgeBaseTable_undo_setup","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * TODO:451:M: |-> Setup ieee8021BridgeBaseTable undo.
     * set up ieee8021BridgeBaseTable undo information, in preparation for a set.
     * Undo storage is in (* ieee8021BridgeBaseRowStatus_val_ptr )*
     */

    return rc;
} /* ieee8021BridgeBaseTable_undo_setup */

/**
 * Undo a set request.
 *
 * This function will be called before the individual node undo
 * functions are called. If you need to do any undo that is not
 * related to a specific column, you can do it here.
 *
 * Note that an individual node's undo function will only be called
 * if that node is being set to a new value.
 *
 * If there is anything  specific to a particular column (e.g. releasing
 * memory for a string), you should do that setup in the node's undo
 * function, so it won't be done unless it is necessary.
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ieee8021BridgeBaseTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 */
int
ieee8021BridgeBaseTable_undo( ieee8021BridgeBaseTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:ieee8021BridgeBaseTable:ieee8021BridgeBaseTable_undo","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * TODO:451:M: |-> ieee8021BridgeBaseTable undo.
     * ieee8021BridgeBaseTable undo information, in response to a failed set.
     * Undo storage is in (* ieee8021BridgeBaseRowStatus_val_ptr )*
     */

    return rc;
} /* ieee8021BridgeBaseTable_undo_setup */

/**
 * Cleanup up context undo information.
 *
 * This function will be called after set/commit processing. If you
 * allocated any resources in undo_setup, this is the place to release
 * those resources.
 *
 * This function is called regardless of the success or failure of the set
 * request. If you need to perform different steps for cleanup depending
 * on success or failure, you can add a flag to the rowreq_ctx.
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ieee8021BridgeBaseTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error
 */
int
ieee8021BridgeBaseTable_undo_cleanup( ieee8021BridgeBaseTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:ieee8021BridgeBaseTable:ieee8021BridgeBaseTable_undo_cleanup","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * TODO:452:M: |-> Cleanup ieee8021BridgeBaseTable undo.
     * Undo storage is in (* ieee8021BridgeBaseRowStatus_val_ptr )*
     */

    return rc;
} /* ieee8021BridgeBaseTable_undo_cleanup */

/**
 * commit new values.
 *
 * At this point, you should have done everything you can to ensure that
 * this commit will not fail.
 *
 * Should you need different behavior depending on which columns were
 * set, rowreq_ctx->column_set_flags will indicate which writeable columns were
 * set. The definitions for the COLUMN_*_FLAG bits can be found in
 * ieee8021BridgeBaseTable_oids.h.
 * A new row will have the MFD_ROW_CREATED bit set in rowreq_flags.
 *
 * @param ieee8021BridgeBaseTable_rowreq_ctx
 *        Pointer to the users context.
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error
 */
int
ieee8021BridgeBaseTable_commit( ieee8021BridgeBaseTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;
    int             save_flags;

    DEBUGMSGTL(("verbose:ieee8021BridgeBaseTable:ieee8021BridgeBaseTable_commit","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * save flags, then clear until we actually do something
     */
    save_flags = rowreq_ctx->column_set_flags;
    rowreq_ctx->column_set_flags = 0;

    /*
     * commit ieee8021BridgeBaseTable data
     * 1) check the column's flag in save_flags to see if it was set.
     * 2) clear the flag when you handle that column
     * 3) set the column's flag in column_set_flags if it needs undo
     *    processing in case of a failure.
     */
    if (save_flags & COLUMN_IEEE8021BRIDGEBASEBRIDGEADDRESS_FLAG) {
       save_flags &= ~COLUMN_IEEE8021BRIDGEBASEBRIDGEADDRESS_FLAG; /* clear ieee8021BridgeBaseBridgeAddress */
       /*
        * TODO:482:o: |-> commit column ieee8021BridgeBaseBridgeAddress.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"ieee8021BridgeBaseTable column ieee8021BridgeBaseBridgeAddress commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo ieee8021BridgeBaseBridgeAddress
             */
            rowreq_ctx->column_set_flags |= COLUMN_IEEE8021BRIDGEBASEBRIDGEADDRESS_FLAG;
       }
    }

    if (save_flags & COLUMN_IEEE8021BRIDGEBASECOMPONENTTYPE_FLAG) {
       save_flags &= ~COLUMN_IEEE8021BRIDGEBASECOMPONENTTYPE_FLAG; /* clear ieee8021BridgeBaseComponentType */
       /*
        * TODO:482:o: |-> commit column ieee8021BridgeBaseComponentType.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"ieee8021BridgeBaseTable column ieee8021BridgeBaseComponentType commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo ieee8021BridgeBaseComponentType
             */
            rowreq_ctx->column_set_flags |= COLUMN_IEEE8021BRIDGEBASECOMPONENTTYPE_FLAG;
       }
    }

    if (save_flags & COLUMN_IEEE8021BRIDGEBASEDEVICECAPABILITIES_FLAG) {
       save_flags &= ~COLUMN_IEEE8021BRIDGEBASEDEVICECAPABILITIES_FLAG; /* clear ieee8021BridgeBaseDeviceCapabilities */
       /*
        * TODO:482:o: |-> commit column ieee8021BridgeBaseDeviceCapabilities.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"ieee8021BridgeBaseTable column ieee8021BridgeBaseDeviceCapabilities commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo ieee8021BridgeBaseDeviceCapabilities
             */
            rowreq_ctx->column_set_flags |= COLUMN_IEEE8021BRIDGEBASEDEVICECAPABILITIES_FLAG;
       }
    }

    if (save_flags & COLUMN_IEEE8021BRIDGEBASETRAFFICCLASSESENABLED_FLAG) {
       save_flags &= ~COLUMN_IEEE8021BRIDGEBASETRAFFICCLASSESENABLED_FLAG; /* clear ieee8021BridgeBaseTrafficClassesEnabled */
       /*
        * TODO:482:o: |-> commit column ieee8021BridgeBaseTrafficClassesEnabled.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"ieee8021BridgeBaseTable column ieee8021BridgeBaseTrafficClassesEnabled commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo ieee8021BridgeBaseTrafficClassesEnabled
             */
            rowreq_ctx->column_set_flags |= COLUMN_IEEE8021BRIDGEBASETRAFFICCLASSESENABLED_FLAG;
       }
    }

    if (save_flags & COLUMN_IEEE8021BRIDGEBASEMMRPENABLEDSTATUS_FLAG) {
       save_flags &= ~COLUMN_IEEE8021BRIDGEBASEMMRPENABLEDSTATUS_FLAG; /* clear ieee8021BridgeBaseMmrpEnabledStatus */
       /*
        * TODO:482:o: |-> commit column ieee8021BridgeBaseMmrpEnabledStatus.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"ieee8021BridgeBaseTable column ieee8021BridgeBaseMmrpEnabledStatus commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo ieee8021BridgeBaseMmrpEnabledStatus
             */
            rowreq_ctx->column_set_flags |= COLUMN_IEEE8021BRIDGEBASEMMRPENABLEDSTATUS_FLAG;
       }
    }

    if (save_flags & COLUMN_IEEE8021BRIDGEBASEROWSTATUS_FLAG) {
       save_flags &= ~COLUMN_IEEE8021BRIDGEBASEROWSTATUS_FLAG; /* clear ieee8021BridgeBaseRowStatus */
       /*
        * TODO:482:o: |-> commit column ieee8021BridgeBaseRowStatus.
        */
       rc = -1;
       if(-1 == rc) {
           snmp_log(LOG_ERR,"ieee8021BridgeBaseTable column ieee8021BridgeBaseRowStatus commit failed\n");
       }
       else {
            /*
             * set flag, in case we need to undo ieee8021BridgeBaseRowStatus
             */
            rowreq_ctx->column_set_flags |= COLUMN_IEEE8021BRIDGEBASEROWSTATUS_FLAG;
       }
    }

    /*
     * if we successfully commited this row, set the dirty flag.
     */
    if (MFD_SUCCESS == rc) {
        rowreq_ctx->rowreq_flags |= MFD_ROW_DIRTY;
    }

    if (save_flags) {
       snmp_log(LOG_ERR, "unhandled columns (0x%x) in commit\n", save_flags);
       return MFD_ERROR;
    }

    return rc;
} /* ieee8021BridgeBaseTable_commit */

/**
 * undo commit new values.
 *
 * Should you need different behavior depending on which columns were
 * set, rowreq_ctx->column_set_flags will indicate which writeable columns were
 * set. The definitions for the COLUMN_*_FLAG bits can be found in
 * ieee8021BridgeBaseTable_oids.h.
 * A new row will have the MFD_ROW_CREATED bit set in rowreq_flags.
 *
 * @param ieee8021BridgeBaseTable_rowreq_ctx
 *        Pointer to the users context.
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error
 */
int
ieee8021BridgeBaseTable_undo_commit( ieee8021BridgeBaseTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;

    DEBUGMSGTL(("verbose:ieee8021BridgeBaseTable:ieee8021BridgeBaseTable_undo_commit","called\n"));

    /** we should have a non-NULL pointer */
    netsnmp_assert( NULL != rowreq_ctx );

    /*
     * TODO:485:M: |-> Undo ieee8021BridgeBaseTable commit.
     * check the column's flag in rowreq_ctx->column_set_flags to see
     * if it was set during commit, then undo it.
     *
     * eg: if (rowreq_ctx->column_set_flags & COLUMN__FLAG) {}
     */


    /*
     * if we successfully un-commited this row, clear the dirty flag.
     */
    if (MFD_SUCCESS == rc) {
        rowreq_ctx->rowreq_flags &= ~MFD_ROW_DIRTY;
    }

    return rc;
} /* ieee8021BridgeBaseTable_undo_commit */

/*
 * TODO:440:M: Implement ieee8021BridgeBaseTable node value checks.
 * TODO:450:M: Implement ieee8021BridgeBaseTable undo functions.
 * TODO:460:M: Implement ieee8021BridgeBaseTable set functions.
 * TODO:480:M: Implement ieee8021BridgeBaseTable commit functions.
 */
/*---------------------------------------------------------------------
 * IEEE8021-BRIDGE-MIB::ieee8021BridgeBaseEntry.ieee8021BridgeBaseBridgeAddress
 * ieee8021BridgeBaseBridgeAddress is subid 2 of ieee8021BridgeBaseEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.111.2.802.1.1.2.1.1.1.1.2
 * Description:
The MAC address used by this bridge when it must be
        referred to in a unique fashion.  It is recommended
        that this be the numerically smallest MAC address of
        all ports that belong to this bridge.  However, it is
        only required to be unique.  When concatenated with
        ieee8021SpanningTreePriority, a unique BridgeIdentifier
        is formed, which is used in the Spanning Tree Protocol.

        This object may not be modified while the corresponding
        instance of ieee8021BridgeBaseRowStatus is active(1).

        The value of this object MUST be retained across
        reinitializations of the management system.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   1
 *   hint: 1x:
 *
 * Ranges:  6;
 *
 * Its syntax is MacAddress (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 6)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ieee8021BridgeBaseBridgeAddress_val_ptr
 *        A char containing the new value.
 * @param ieee8021BridgeBaseBridgeAddress_val_ptr_len
 *        The size (in bytes) of the data pointed to by ieee8021BridgeBaseBridgeAddress_val_ptr
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 *
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * ieee8021BridgeBaseTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_OCTET_STR
 *    The length is < sizeof(rowreq_ctx->data.ieee8021BridgeBaseBridgeAddress).
 *    The length is in (one of) the range set(s):  6
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
ieee8021BridgeBaseBridgeAddress_check_value( ieee8021BridgeBaseTable_rowreq_ctx *rowreq_ctx, char *ieee8021BridgeBaseBridgeAddress_val_ptr,  size_t ieee8021BridgeBaseBridgeAddress_val_ptr_len)
{
    DEBUGMSGTL(("verbose:ieee8021BridgeBaseTable:ieee8021BridgeBaseBridgeAddress_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);
    netsnmp_assert(NULL != ieee8021BridgeBaseBridgeAddress_val_ptr);

    /*
     * TODO:441:o: |-> Check for valid ieee8021BridgeBaseBridgeAddress value.
     */

    return MFD_SUCCESS; /* ieee8021BridgeBaseBridgeAddress value not illegal */
} /* ieee8021BridgeBaseBridgeAddress_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ieee8021BridgeBaseTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * ieee8021BridgeBaseTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
ieee8021BridgeBaseBridgeAddress_undo_setup( ieee8021BridgeBaseTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:ieee8021BridgeBaseTable:ieee8021BridgeBaseBridgeAddress_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup ieee8021BridgeBaseBridgeAddress undo.
     */
    /*
     * copy ieee8021BridgeBaseBridgeAddress and ieee8021BridgeBaseBridgeAddress_len data
     * set rowreq_ctx->undo->ieee8021BridgeBaseBridgeAddress from rowreq_ctx->data.ieee8021BridgeBaseBridgeAddress
     */
    memcpy( rowreq_ctx->undo->ieee8021BridgeBaseBridgeAddress, rowreq_ctx->data.ieee8021BridgeBaseBridgeAddress,
            (rowreq_ctx->data.ieee8021BridgeBaseBridgeAddress_len * sizeof(rowreq_ctx->undo->ieee8021BridgeBaseBridgeAddress[0])));
    rowreq_ctx->undo->ieee8021BridgeBaseBridgeAddress_len = rowreq_ctx->data.ieee8021BridgeBaseBridgeAddress_len;


    return MFD_SUCCESS;
} /* ieee8021BridgeBaseBridgeAddress_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param ieee8021BridgeBaseBridgeAddress_val_ptr
 *        A char containing the new value.
 * @param ieee8021BridgeBaseBridgeAddress_val_ptr_len
 *        The size (in bytes) of the data pointed to by ieee8021BridgeBaseBridgeAddress_val_ptr
 */
int
ieee8021BridgeBaseBridgeAddress_set( ieee8021BridgeBaseTable_rowreq_ctx *rowreq_ctx, char *ieee8021BridgeBaseBridgeAddress_val_ptr,  size_t ieee8021BridgeBaseBridgeAddress_val_ptr_len )
{

    DEBUGMSGTL(("verbose:ieee8021BridgeBaseTable:ieee8021BridgeBaseBridgeAddress_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);
    netsnmp_assert(NULL != ieee8021BridgeBaseBridgeAddress_val_ptr);

    /*
     * TODO:461:M: |-> Set ieee8021BridgeBaseBridgeAddress value.
     * set ieee8021BridgeBaseBridgeAddress value in rowreq_ctx->data
     */
    memcpy( rowreq_ctx->data.ieee8021BridgeBaseBridgeAddress, ieee8021BridgeBaseBridgeAddress_val_ptr, ieee8021BridgeBaseBridgeAddress_val_ptr_len );
    /** convert bytes to number of char */
    rowreq_ctx->data.ieee8021BridgeBaseBridgeAddress_len = ieee8021BridgeBaseBridgeAddress_val_ptr_len / sizeof(ieee8021BridgeBaseBridgeAddress_val_ptr[0]);

    return MFD_SUCCESS;
} /* ieee8021BridgeBaseBridgeAddress_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
ieee8021BridgeBaseBridgeAddress_undo( ieee8021BridgeBaseTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:ieee8021BridgeBaseTable:ieee8021BridgeBaseBridgeAddress_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up ieee8021BridgeBaseBridgeAddress undo.
     */
    /*
     * copy ieee8021BridgeBaseBridgeAddress and ieee8021BridgeBaseBridgeAddress_len data
     * set rowreq_ctx->data.ieee8021BridgeBaseBridgeAddress from rowreq_ctx->undo->ieee8021BridgeBaseBridgeAddress
     */
    memcpy( rowreq_ctx->data.ieee8021BridgeBaseBridgeAddress, rowreq_ctx->undo->ieee8021BridgeBaseBridgeAddress,
            (rowreq_ctx->undo->ieee8021BridgeBaseBridgeAddress_len * sizeof(rowreq_ctx->data.ieee8021BridgeBaseBridgeAddress[0])));
    rowreq_ctx->data.ieee8021BridgeBaseBridgeAddress_len = rowreq_ctx->undo->ieee8021BridgeBaseBridgeAddress_len;


    return MFD_SUCCESS;
} /* ieee8021BridgeBaseBridgeAddress_undo */

/*---------------------------------------------------------------------
 * IEEE8021-BRIDGE-MIB::ieee8021BridgeBaseEntry.ieee8021BridgeBaseComponentType
 * ieee8021BridgeBaseComponentType is subid 4 of ieee8021BridgeBaseEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.111.2.802.1.1.2.1.1.1.1.4
 * Description:
Indicates the component type(s) of this bridge.  The
        following component types are possible:

            iComponent(1) - An S-VLAN aware component of a Backbone
                Edge Bridge which performs encapsulation of customer
                frames.

            bComponent(2) - An S-VLAN aware component of a Backbone
                Edge Bridge which bundles backbone service instances
                into B-VLANs.

            cVlanComponent(3) - A C-VLAN aware component of an
                enterprise VLAN bridge or of a Provider Bridge used
                to process C-tagged frames.

            sVlanComponent(4) - An S-VLAN aware component of a
                Provider Bridge.

            dBridgeComponent(5) - A VLAN unaware component of an
                802.1D bridge.

        This object may not be modified while the corresponding
        instance of ieee8021BridgeBaseRowStatus is active(1).

        The value of this object MUST be retained across
        reinitializations of the management system.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 3/8. Values:  iComponent(1), bComponent(2), cVlanComponent(3), sVlanComponent(4), dBridgeComponent(5)
 *
 * Its syntax is INTEGER (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ieee8021BridgeBaseComponentType_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 *
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * ieee8021BridgeBaseTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  iComponent(1), bComponent(2), cVlanComponent(3), sVlanComponent(4), dBridgeComponent(5)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
ieee8021BridgeBaseComponentType_check_value( ieee8021BridgeBaseTable_rowreq_ctx *rowreq_ctx, u_long ieee8021BridgeBaseComponentType_val)
{
    DEBUGMSGTL(("verbose:ieee8021BridgeBaseTable:ieee8021BridgeBaseComponentType_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid ieee8021BridgeBaseComponentType value.
     */

    return MFD_SUCCESS; /* ieee8021BridgeBaseComponentType value not illegal */
} /* ieee8021BridgeBaseComponentType_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ieee8021BridgeBaseTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * ieee8021BridgeBaseTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
ieee8021BridgeBaseComponentType_undo_setup( ieee8021BridgeBaseTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:ieee8021BridgeBaseTable:ieee8021BridgeBaseComponentType_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup ieee8021BridgeBaseComponentType undo.
     */
    /*
     * copy ieee8021BridgeBaseComponentType data
     * set rowreq_ctx->undo->ieee8021BridgeBaseComponentType from rowreq_ctx->data.ieee8021BridgeBaseComponentType
     */
    rowreq_ctx->undo->ieee8021BridgeBaseComponentType = rowreq_ctx->data.ieee8021BridgeBaseComponentType;


    return MFD_SUCCESS;
} /* ieee8021BridgeBaseComponentType_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param ieee8021BridgeBaseComponentType_val
 *        A long containing the new value.
 */
int
ieee8021BridgeBaseComponentType_set( ieee8021BridgeBaseTable_rowreq_ctx *rowreq_ctx, u_long ieee8021BridgeBaseComponentType_val )
{

    DEBUGMSGTL(("verbose:ieee8021BridgeBaseTable:ieee8021BridgeBaseComponentType_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set ieee8021BridgeBaseComponentType value.
     * set ieee8021BridgeBaseComponentType value in rowreq_ctx->data
     */
    rowreq_ctx->data.ieee8021BridgeBaseComponentType = ieee8021BridgeBaseComponentType_val;

    return MFD_SUCCESS;
} /* ieee8021BridgeBaseComponentType_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
ieee8021BridgeBaseComponentType_undo( ieee8021BridgeBaseTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:ieee8021BridgeBaseTable:ieee8021BridgeBaseComponentType_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up ieee8021BridgeBaseComponentType undo.
     */
    /*
     * copy ieee8021BridgeBaseComponentType data
     * set rowreq_ctx->data.ieee8021BridgeBaseComponentType from rowreq_ctx->undo->ieee8021BridgeBaseComponentType
     */
    rowreq_ctx->data.ieee8021BridgeBaseComponentType = rowreq_ctx->undo->ieee8021BridgeBaseComponentType;


    return MFD_SUCCESS;
} /* ieee8021BridgeBaseComponentType_undo */

/*---------------------------------------------------------------------
 * IEEE8021-BRIDGE-MIB::ieee8021BridgeBaseEntry.ieee8021BridgeBaseDeviceCapabilities
 * ieee8021BridgeBaseDeviceCapabilities is subid 5 of ieee8021BridgeBaseEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.111.2.802.1.1.2.1.1.1.1.5
 * Description:
Indicates the optional parts of IEEE 802.1D and 802.1Q
        that are implemented by this device and are manageable
        through this MIB.  Capabilities that are allowed on a
        per-port basis are indicated in
        ieee8021BridgeBasePortCapabilities.

        dot1dExtendedFilteringServices(0),
                              -- can perform filtering of
                              -- individual multicast addresses
                              -- controlled by MMRP.
        dot1dTrafficClasses(1),
                              -- can map user priority to
                              -- multiple traffic classes.
        dot1qStaticEntryIndividualPort(2),
                              -- dot1qStaticUnicastReceivePort &
                              -- dot1qStaticMulticastReceivePort
                              -- can represent non-zero entries.
        dot1qIVLCapable(3),   -- Independent VLAN Learning (IVL).
        dot1qSVLCapable(4),   -- Shared VLAN Learning (SVL).
        dot1qHybridCapable(5),
                              -- both IVL & SVL simultaneously.
        dot1qConfigurablePvidTagging(6),
                              -- whether the implementation
                              -- supports the ability to
                              -- override the default PVID
                              -- setting and its egress status
                              -- (VLAN-Tagged or Untagged) on
                              -- each port.
        dot1dLocalVlanCapable(7)
                              -- can support multiple local
                              -- bridges, outside of the scope
                              -- of 802.1Q defined VLANs.

        This object may not be modified while the corresponding
        instance of ieee8021BridgeBaseRowStatus is active(1).

        The value of this object MUST be retained across
        reinitializations of the management system.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 5/8. Values:  dot1dExtendedFilteringServices(0), dot1dTrafficClasses(1), dot1qStaticEntryIndividualPort(2), dot1qIVLCapable(3), dot1qSVLCapable(4), dot1qHybridCapable(5), dot1qConfigurablePvidTagging(6), dot1dLocalVlanCapable(7)
 *
 * Its syntax is BITS (based on perltype BITS)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (u_long)
 * This data type requires a length.
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ieee8021BridgeBaseDeviceCapabilities_val
 *        A char containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 *
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * ieee8021BridgeBaseTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_OCTET_STR
 *    The value is one of  dot1dExtendedFilteringServices(0), dot1dTrafficClasses(1), dot1qStaticEntryIndividualPort(2), dot1qIVLCapable(3), dot1qSVLCapable(4), dot1qHybridCapable(5), dot1qConfigurablePvidTagging(6), dot1dLocalVlanCapable(7)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
ieee8021BridgeBaseDeviceCapabilities_check_value( ieee8021BridgeBaseTable_rowreq_ctx *rowreq_ctx, u_long ieee8021BridgeBaseDeviceCapabilities_val)
{
    DEBUGMSGTL(("verbose:ieee8021BridgeBaseTable:ieee8021BridgeBaseDeviceCapabilities_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid ieee8021BridgeBaseDeviceCapabilities value.
     */

    return MFD_SUCCESS; /* ieee8021BridgeBaseDeviceCapabilities value not illegal */
} /* ieee8021BridgeBaseDeviceCapabilities_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ieee8021BridgeBaseTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * ieee8021BridgeBaseTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
ieee8021BridgeBaseDeviceCapabilities_undo_setup( ieee8021BridgeBaseTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:ieee8021BridgeBaseTable:ieee8021BridgeBaseDeviceCapabilities_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup ieee8021BridgeBaseDeviceCapabilities undo.
     */
    /*
     * copy ieee8021BridgeBaseDeviceCapabilities data
     * set rowreq_ctx->undo->ieee8021BridgeBaseDeviceCapabilities from rowreq_ctx->data.ieee8021BridgeBaseDeviceCapabilities
     */
    rowreq_ctx->undo->ieee8021BridgeBaseDeviceCapabilities = rowreq_ctx->data.ieee8021BridgeBaseDeviceCapabilities;


    return MFD_SUCCESS;
} /* ieee8021BridgeBaseDeviceCapabilities_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param ieee8021BridgeBaseDeviceCapabilities_val
 *        A char containing the new value.
 */
int
ieee8021BridgeBaseDeviceCapabilities_set( ieee8021BridgeBaseTable_rowreq_ctx *rowreq_ctx, u_long ieee8021BridgeBaseDeviceCapabilities_val )
{

    DEBUGMSGTL(("verbose:ieee8021BridgeBaseTable:ieee8021BridgeBaseDeviceCapabilities_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set ieee8021BridgeBaseDeviceCapabilities value.
     * set ieee8021BridgeBaseDeviceCapabilities value in rowreq_ctx->data
     */
    rowreq_ctx->data.ieee8021BridgeBaseDeviceCapabilities = ieee8021BridgeBaseDeviceCapabilities_val;

    return MFD_SUCCESS;
} /* ieee8021BridgeBaseDeviceCapabilities_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
ieee8021BridgeBaseDeviceCapabilities_undo( ieee8021BridgeBaseTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:ieee8021BridgeBaseTable:ieee8021BridgeBaseDeviceCapabilities_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up ieee8021BridgeBaseDeviceCapabilities undo.
     */
    /*
     * copy ieee8021BridgeBaseDeviceCapabilities data
     * set rowreq_ctx->data.ieee8021BridgeBaseDeviceCapabilities from rowreq_ctx->undo->ieee8021BridgeBaseDeviceCapabilities
     */
    rowreq_ctx->data.ieee8021BridgeBaseDeviceCapabilities = rowreq_ctx->undo->ieee8021BridgeBaseDeviceCapabilities;


    return MFD_SUCCESS;
} /* ieee8021BridgeBaseDeviceCapabilities_undo */

/*---------------------------------------------------------------------
 * IEEE8021-BRIDGE-MIB::ieee8021BridgeBaseEntry.ieee8021BridgeBaseTrafficClassesEnabled
 * ieee8021BridgeBaseTrafficClassesEnabled is subid 6 of ieee8021BridgeBaseEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.111.2.802.1.1.2.1.1.1.1.6
 * Description:
The value true(1) indicates that Traffic Classes are
        enabled on this bridge.  When false(2), the bridge
        operates with a single priority level for all traffic.

        This object may be modified while the corresponding
        instance of ieee8021BridgeBaseRowStatus is active(1).

        The value of this object MUST be retained across
        reinitializations of the management system.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 1
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *   defval: true
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ieee8021BridgeBaseTrafficClassesEnabled_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 *
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * ieee8021BridgeBaseTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  true(1), false(2)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
ieee8021BridgeBaseTrafficClassesEnabled_check_value( ieee8021BridgeBaseTable_rowreq_ctx *rowreq_ctx, u_long ieee8021BridgeBaseTrafficClassesEnabled_val)
{
    DEBUGMSGTL(("verbose:ieee8021BridgeBaseTable:ieee8021BridgeBaseTrafficClassesEnabled_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid ieee8021BridgeBaseTrafficClassesEnabled value.
     */

    return MFD_SUCCESS; /* ieee8021BridgeBaseTrafficClassesEnabled value not illegal */
} /* ieee8021BridgeBaseTrafficClassesEnabled_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ieee8021BridgeBaseTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * ieee8021BridgeBaseTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
ieee8021BridgeBaseTrafficClassesEnabled_undo_setup( ieee8021BridgeBaseTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:ieee8021BridgeBaseTable:ieee8021BridgeBaseTrafficClassesEnabled_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup ieee8021BridgeBaseTrafficClassesEnabled undo.
     */
    /*
     * copy ieee8021BridgeBaseTrafficClassesEnabled data
     * set rowreq_ctx->undo->ieee8021BridgeBaseTrafficClassesEnabled from rowreq_ctx->data.ieee8021BridgeBaseTrafficClassesEnabled
     */
    rowreq_ctx->undo->ieee8021BridgeBaseTrafficClassesEnabled = rowreq_ctx->data.ieee8021BridgeBaseTrafficClassesEnabled;


    return MFD_SUCCESS;
} /* ieee8021BridgeBaseTrafficClassesEnabled_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param ieee8021BridgeBaseTrafficClassesEnabled_val
 *        A long containing the new value.
 */
int
ieee8021BridgeBaseTrafficClassesEnabled_set( ieee8021BridgeBaseTable_rowreq_ctx *rowreq_ctx, u_long ieee8021BridgeBaseTrafficClassesEnabled_val )
{

    DEBUGMSGTL(("verbose:ieee8021BridgeBaseTable:ieee8021BridgeBaseTrafficClassesEnabled_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set ieee8021BridgeBaseTrafficClassesEnabled value.
     * set ieee8021BridgeBaseTrafficClassesEnabled value in rowreq_ctx->data
     */
    rowreq_ctx->data.ieee8021BridgeBaseTrafficClassesEnabled = ieee8021BridgeBaseTrafficClassesEnabled_val;

    return MFD_SUCCESS;
} /* ieee8021BridgeBaseTrafficClassesEnabled_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
ieee8021BridgeBaseTrafficClassesEnabled_undo( ieee8021BridgeBaseTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:ieee8021BridgeBaseTable:ieee8021BridgeBaseTrafficClassesEnabled_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up ieee8021BridgeBaseTrafficClassesEnabled undo.
     */
    /*
     * copy ieee8021BridgeBaseTrafficClassesEnabled data
     * set rowreq_ctx->data.ieee8021BridgeBaseTrafficClassesEnabled from rowreq_ctx->undo->ieee8021BridgeBaseTrafficClassesEnabled
     */
    rowreq_ctx->data.ieee8021BridgeBaseTrafficClassesEnabled = rowreq_ctx->undo->ieee8021BridgeBaseTrafficClassesEnabled;


    return MFD_SUCCESS;
} /* ieee8021BridgeBaseTrafficClassesEnabled_undo */

/*---------------------------------------------------------------------
 * IEEE8021-BRIDGE-MIB::ieee8021BridgeBaseEntry.ieee8021BridgeBaseMmrpEnabledStatus
 * ieee8021BridgeBaseMmrpEnabledStatus is subid 7 of ieee8021BridgeBaseEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.111.2.802.1.1.2.1.1.1.1.7
 * Description:
The administrative status requested by management for
        MMRP.  The value true(1) indicates that MMRP should
        be enabled on this device, in all VLANs, on all ports
        for which it has not been specifically disabled.  When
        false(2), MMRP is disabled, in all VLANs and on all
        ports, and all MMRP packets will be forwarded
        transparently.  This object affects both Applicant and
        Registrar state machines.  A transition from false(2)
        to true(1) will cause a reset of all MMRP state
        machines on all ports.

        This object may be modified while the corresponding
        instance of ieee8021BridgeBaseRowStatus is active(1).

        The value of this object MUST be retained across
        reinitializations of the management system.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 1
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *   defval: true
 *
 * Enum range: 2/8. Values:  true(1), false(2)
 *
 * Its syntax is TruthValue (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ieee8021BridgeBaseMmrpEnabledStatus_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 *
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * ieee8021BridgeBaseTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  true(1), false(2)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
ieee8021BridgeBaseMmrpEnabledStatus_check_value( ieee8021BridgeBaseTable_rowreq_ctx *rowreq_ctx, u_long ieee8021BridgeBaseMmrpEnabledStatus_val)
{
    DEBUGMSGTL(("verbose:ieee8021BridgeBaseTable:ieee8021BridgeBaseMmrpEnabledStatus_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid ieee8021BridgeBaseMmrpEnabledStatus value.
     */

    return MFD_SUCCESS; /* ieee8021BridgeBaseMmrpEnabledStatus value not illegal */
} /* ieee8021BridgeBaseMmrpEnabledStatus_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ieee8021BridgeBaseTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * ieee8021BridgeBaseTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
ieee8021BridgeBaseMmrpEnabledStatus_undo_setup( ieee8021BridgeBaseTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:ieee8021BridgeBaseTable:ieee8021BridgeBaseMmrpEnabledStatus_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup ieee8021BridgeBaseMmrpEnabledStatus undo.
     */
    /*
     * copy ieee8021BridgeBaseMmrpEnabledStatus data
     * set rowreq_ctx->undo->ieee8021BridgeBaseMmrpEnabledStatus from rowreq_ctx->data.ieee8021BridgeBaseMmrpEnabledStatus
     */
    rowreq_ctx->undo->ieee8021BridgeBaseMmrpEnabledStatus = rowreq_ctx->data.ieee8021BridgeBaseMmrpEnabledStatus;


    return MFD_SUCCESS;
} /* ieee8021BridgeBaseMmrpEnabledStatus_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param ieee8021BridgeBaseMmrpEnabledStatus_val
 *        A long containing the new value.
 */
int
ieee8021BridgeBaseMmrpEnabledStatus_set( ieee8021BridgeBaseTable_rowreq_ctx *rowreq_ctx, u_long ieee8021BridgeBaseMmrpEnabledStatus_val )
{

    DEBUGMSGTL(("verbose:ieee8021BridgeBaseTable:ieee8021BridgeBaseMmrpEnabledStatus_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set ieee8021BridgeBaseMmrpEnabledStatus value.
     * set ieee8021BridgeBaseMmrpEnabledStatus value in rowreq_ctx->data
     */
    rowreq_ctx->data.ieee8021BridgeBaseMmrpEnabledStatus = ieee8021BridgeBaseMmrpEnabledStatus_val;

    return MFD_SUCCESS;
} /* ieee8021BridgeBaseMmrpEnabledStatus_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
ieee8021BridgeBaseMmrpEnabledStatus_undo( ieee8021BridgeBaseTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:ieee8021BridgeBaseTable:ieee8021BridgeBaseMmrpEnabledStatus_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up ieee8021BridgeBaseMmrpEnabledStatus undo.
     */
    /*
     * copy ieee8021BridgeBaseMmrpEnabledStatus data
     * set rowreq_ctx->data.ieee8021BridgeBaseMmrpEnabledStatus from rowreq_ctx->undo->ieee8021BridgeBaseMmrpEnabledStatus
     */
    rowreq_ctx->data.ieee8021BridgeBaseMmrpEnabledStatus = rowreq_ctx->undo->ieee8021BridgeBaseMmrpEnabledStatus;


    return MFD_SUCCESS;
} /* ieee8021BridgeBaseMmrpEnabledStatus_undo */

/*---------------------------------------------------------------------
 * IEEE8021-BRIDGE-MIB::ieee8021BridgeBaseEntry.ieee8021BridgeBaseRowStatus
 * ieee8021BridgeBaseRowStatus is subid 8 of ieee8021BridgeBaseEntry.
 * Its status is Current, and its access level is Create.
 * OID: .1.3.111.2.802.1.1.2.1.1.1.1.8
 * Description:
The object indicates the status of an entry, and is used
        to create/delete entries.

        The following objects must be set prior to making a new
        entry active:
            ieee8021BridgeBaseBridgeAddress
            ieee8021BridgeBaseComponentType
            ieee8021BridgeBaseDeviceCapabilities
        It is recommended that these three objects not be allowed
        to be modified while the corresponding instance of
        ieee8021BridgeBaseRowStatus object is active(1).

        The following objects are not required to be set before
        making a new entry active (they will take their defaults),
        and they also may be modified while the corresponding
        instance of this object is active(1):
            ieee8021BridgeBaseTrafficClassesEnabled
            ieee8021BridgeBaseMmrpEnabledStatus

        The value of this object and all corresponding instances
        of other objects in this table MUST be retained across
        reinitializations of the management system.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  1      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   1
 *
 * Enum range: 3/8. Values:  active(1), notInService(2), notReady(3), createAndGo(4), createAndWait(5), destroy(6)
 *
 * Its syntax is RowStatus (based on perltype INTEGER)
 * The net-snmp type is ASN_INTEGER. The C type decl is long (u_long)
 */
/**
 * Check that the proposed new value is potentially valid.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param ieee8021BridgeBaseRowStatus_val
 *        A long containing the new value.
 *
 * @retval MFD_SUCCESS        : incoming value is legal
 * @retval MFD_NOT_VALID_NOW  : incoming value is not valid now
 * @retval MFD_NOT_VALID_EVER : incoming value is never valid
 *
 * This is the place to check for requirements that are not
 * expressed in the mib syntax (for example, a requirement that
 * is detailed in the description for an object).
 *
 * You should check that the requested change between the undo value and the
 * new value is legal (ie, the transistion from one value to another
 * is legal).
 *
 *@note
 * This check is only to determine if the new value
 * is \b potentially valid. This is the first check of many, and
 * is one of the simplest ones.
 *
 *@note
 * this is not the place to do any checks for values
 * which depend on some other value in the mib. Those
 * types of checks should be done in the
 * ieee8021BridgeBaseTable_check_dependencies() function.
 *
 * The following checks have already been done for you:
 *    The syntax is ASN_INTEGER
 *    The value is one of  active(1), notInService(2), notReady(3), createAndGo(4), createAndWait(5), destroy(6)
 *
 * If there a no other checks you need to do, simply return MFD_SUCCESS.
 *
 */
int
ieee8021BridgeBaseRowStatus_check_value( ieee8021BridgeBaseTable_rowreq_ctx *rowreq_ctx, u_long ieee8021BridgeBaseRowStatus_val)
{
    DEBUGMSGTL(("verbose:ieee8021BridgeBaseTable:ieee8021BridgeBaseRowStatus_check_value","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:441:o: |-> Check for valid ieee8021BridgeBaseRowStatus value.
     */

    return MFD_SUCCESS; /* ieee8021BridgeBaseRowStatus value not illegal */
} /* ieee8021BridgeBaseRowStatus_check_value */

/**
 * Save old value information
 *
 * @param rowreq_ctx
 *        Pointer to the table context (ieee8021BridgeBaseTable_rowreq_ctx)
 *
 * @retval MFD_SUCCESS : success
 * @retval MFD_ERROR   : error. set will fail.
 *
 * This function will be called after the table level undo setup function
 * ieee8021BridgeBaseTable_undo_setup has been called.
 *
 *@note
 * this function will only be called if a new value is set for this column.
 *
 * If there is any setup specific to a particular column (e.g. allocating
 * memory for a string), you should do that setup in this function, so it
 * won't be done unless it is necessary.
 */
int
ieee8021BridgeBaseRowStatus_undo_setup( ieee8021BridgeBaseTable_rowreq_ctx *rowreq_ctx)
{
    DEBUGMSGTL(("verbose:ieee8021BridgeBaseTable:ieee8021BridgeBaseRowStatus_undo_setup","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:455:o: |-> Setup ieee8021BridgeBaseRowStatus undo.
     */
    /*
     * copy ieee8021BridgeBaseRowStatus data
     * set rowreq_ctx->undo->ieee8021BridgeBaseRowStatus from rowreq_ctx->data.ieee8021BridgeBaseRowStatus
     */
    rowreq_ctx->undo->ieee8021BridgeBaseRowStatus = rowreq_ctx->data.ieee8021BridgeBaseRowStatus;


    return MFD_SUCCESS;
} /* ieee8021BridgeBaseRowStatus_undo_setup */

/**
 * Set the new value.
 *
 * @param rowreq_ctx
 *        Pointer to the users context. You should know how to
 *        manipulate the value from this object.
 * @param ieee8021BridgeBaseRowStatus_val
 *        A long containing the new value.
 */
int
ieee8021BridgeBaseRowStatus_set( ieee8021BridgeBaseTable_rowreq_ctx *rowreq_ctx, u_long ieee8021BridgeBaseRowStatus_val )
{

    DEBUGMSGTL(("verbose:ieee8021BridgeBaseTable:ieee8021BridgeBaseRowStatus_set","called\n"));

    /** should never get a NULL pointer */
    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:461:M: |-> Set ieee8021BridgeBaseRowStatus value.
     * set ieee8021BridgeBaseRowStatus value in rowreq_ctx->data
     */
    rowreq_ctx->data.ieee8021BridgeBaseRowStatus = ieee8021BridgeBaseRowStatus_val;

    return MFD_SUCCESS;
} /* ieee8021BridgeBaseRowStatus_set */

/**
 * undo the previous set.
 *
 * @param rowreq_ctx
 *        Pointer to the users context.
 */
int
ieee8021BridgeBaseRowStatus_undo( ieee8021BridgeBaseTable_rowreq_ctx *rowreq_ctx)
{

    DEBUGMSGTL(("verbose:ieee8021BridgeBaseTable:ieee8021BridgeBaseRowStatus_undo","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:456:o: |-> Clean up ieee8021BridgeBaseRowStatus undo.
     */
    /*
     * copy ieee8021BridgeBaseRowStatus data
     * set rowreq_ctx->data.ieee8021BridgeBaseRowStatus from rowreq_ctx->undo->ieee8021BridgeBaseRowStatus
     */
    rowreq_ctx->data.ieee8021BridgeBaseRowStatus = rowreq_ctx->undo->ieee8021BridgeBaseRowStatus;


    return MFD_SUCCESS;
} /* ieee8021BridgeBaseRowStatus_undo */

/**
 * check dependencies
 *
 * This is useful for for tables which have dependencies between columns
 * (or rows, or tables). For example, two columns allocating a percentage
 * of something add up 100%.
 *
 * Should you need different behavior depending on which columns were
 * set, rowreq_ctx->column_set_flags will indicate which writeable columns were
 * set. The definitions for the COLUMN_*_FLAG bits can be found in
 * ieee8021BridgeBaseTable_oids.h.
 * A new row will have the MFD_ROW_CREATED bit set in rowreq_flags.
 *
 * @retval MFD_SUCCESS all the changes to the row are legal
 * @retval MFD_ERROR   one or more changes are not legal
 *
 * (see README-table-ieee8021BridgeBaseTable if you don't have dependencies)
 */
int
ieee8021BridgeBaseTable_check_dependencies(ieee8021BridgeBaseTable_rowreq_ctx *rowreq_ctx)
{
    int rc = MFD_SUCCESS;

    DEBUGMSGTL(("internal:ieee8021BridgeBaseTable:ieee8021BridgeBaseTable_check_dependencies","called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:470:o: Check ieee8021BridgeBaseTable row dependencies.
     * check that all new value are legal and consistent with each other
     */
    /*
     * check RowStatus dependencies
     */
    if (rowreq_ctx->column_set_flags & COLUMN_IEEE8021BRIDGEBASEROWSTATUS_FLAG) {
        /*
         * check for valid RowStatus transition (old, new)
         * (Note: move transition check to
         *  to catch errors earlier)
         */
        rc = check_rowstatus_transition( rowreq_ctx->undo->ieee8021BridgeBaseRowStatus,
                                         rowreq_ctx->data.ieee8021BridgeBaseRowStatus );
        if (MFD_SUCCESS != rc)
            return rc;

        /*
         * row creation requirements
         */
        if (rowreq_ctx->rowreq_flags & MFD_ROW_CREATED) {
            if (ROWSTATUS_DESTROY ==  rowreq_ctx->data.ieee8021BridgeBaseRowStatus) {
                rowreq_ctx->rowreq_flags |= MFD_ROW_DELETED;
            }
            else if (ROWSTATUS_CREATEANDGO ==  rowreq_ctx->data.ieee8021BridgeBaseRowStatus) {
                if ((rowreq_ctx->column_set_flags & IEEE8021BRIDGEBASETABLE_REQUIRED_COLS)
                    != IEEE8021BRIDGEBASETABLE_REQUIRED_COLS) {
                    DEBUGMSGTL(("ieee8021BridgeBaseTable",
                                "required columns missing (0x%0x != 0x%0x)\n",
                                rowreq_ctx->column_set_flags, IEEE8021BRIDGEBASETABLE_REQUIRED_COLS));
                    return MFD_CANNOT_CREATE_NOW;
                }
                rowreq_ctx->data.ieee8021BridgeBaseRowStatus = ROWSTATUS_ACTIVE;
            }
        } /* row creation */
        else {
            /*
             * row change requirements
             */
            /*
             * don't allow a destroy if any other value was changed, since
             * that might call data access routines with bad info.
             *
             * you may or may not require the row be notInService before it
             * can be destroyed.
             */
            if (ROWSTATUS_DESTROY == rowreq_ctx->data.ieee8021BridgeBaseRowStatus) {
                if (rowreq_ctx->column_set_flags & ~COLUMN_IEEE8021BRIDGEBASEROWSTATUS_FLAG) {
                    DEBUGMSGTL(("ieee8021BridgeBaseTable",
                                "destroy must be only varbind for row\n"));
                    return MFD_NOT_VALID_NOW;
                }
                rowreq_ctx->rowreq_flags |= MFD_ROW_DELETED;

            } /* row destroy */
        } /* row change */
    }
    else {
        /*
         * must have row status to create a row
         */
        if (rowreq_ctx->rowreq_flags & MFD_ROW_CREATED) {
            DEBUGMSGTL(("ieee8021BridgeBaseTable",
                        "must use RowStatus to create rows\n"));
            return MFD_CANNOT_CREATE_NOW;
        }
    } /* row status not set */

    if ( MFD_SUCCESS != rc )
        return rc;

    return rc;
} /* ieee8021BridgeBaseTable_check_dependencies */

/** @} */
