/*
 * Note: this file originally auto-generated by mib2c using
 *       version : 12088 $ of $ 
 *
 * $Id:$
 */
/*
 * standard Net-SNMP includes 
 */
#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>

/*
 * include our parent header 
 */
#include "pstatsTable.h"


/** @defgroup data_get data_get: Routines to get data
 *
 * TODO:230:M: Implement pstatsTable get routines.
 * TODO:240:M: Implement pstatsTable mapping routines (if any).
 *
 * These routine are used to get the value for individual objects. The
 * row context is passed, along with a pointer to the memory where the
 * value should be copied.
 *
 * @{
 */
/**********************************************************************
 **********************************************************************
 ***
 *** Table pstatsTable
 ***
 **********************************************************************
 **********************************************************************/
/*
 * WR-SWITCH-MIB::pstatsTable is subid 2 of wrsPstats.
 * Its status is Current.
 * OID: .1.3.6.1.4.1.96.100.2.2, length: 10
 */

/*
 * ---------------------------------------------------------------------
 * * TODO:200:r: Implement pstatsTable data context functions.
 */


/**
 * set mib index(es)
 *
 * @param tbl_idx mib index structure
 * @param pstatsIndex_val
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This convenience function is useful for setting all the MIB index
 *  components with a single function call. It is assume that the C values
 *  have already been mapped from their native/rawformat to the MIB format.
 */
int
pstatsTable_indexes_set_tbl_idx(pstatsTable_mib_index * tbl_idx,
                                long pstatsIndex_val)
{
    DEBUGMSGTL(("verbose:pstatsTable:pstatsTable_indexes_set_tbl_idx",
                "called\n"));

    /*
     * pstatsIndex(1)/INTEGER32/ASN_INTEGER/long(long)//l/A/w/e/r/d/h 
     */
    tbl_idx->pstatsIndex = pstatsIndex_val;


    return MFD_SUCCESS;
}                               /* pstatsTable_indexes_set_tbl_idx */

/**
 * @internal
 * set row context indexes
 *
 * @param reqreq_ctx the row context that needs updated indexes
 *
 * @retval MFD_SUCCESS     : success.
 * @retval MFD_ERROR       : other error.
 *
 * @remark
 *  This function sets the mib indexs, then updates the oid indexs
 *  from the mib index.
 */
int
pstatsTable_indexes_set(pstatsTable_rowreq_ctx * rowreq_ctx,
                        long pstatsIndex_val)
{
    DEBUGMSGTL(("verbose:pstatsTable:pstatsTable_indexes_set",
                "called\n"));

    if (MFD_SUCCESS !=
        pstatsTable_indexes_set_tbl_idx(&rowreq_ctx->tbl_idx,
                                        pstatsIndex_val))
        return MFD_ERROR;

    /*
     * convert mib index to oid index
     */
    rowreq_ctx->oid_idx.len = sizeof(rowreq_ctx->oid_tmp) / sizeof(oid);
    if (0 != pstatsTable_index_to_oid(&rowreq_ctx->oid_idx,
                                      &rowreq_ctx->tbl_idx)) {
        return MFD_ERROR;
    }

    return MFD_SUCCESS;
}                               /* pstatsTable_indexes_set */


/*---------------------------------------------------------------------
 * WR-SWITCH-MIB::pstatsEntry.pstatsDescr
 * pstatsDescr is subid 2 of pstatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.96.100.2.2.1.2
 * Description:
A textual string describing this counter
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 1      hashint   1
 *   settable   0
 *   hint: 255a
 *
 * Ranges:  0 - 32;
 *
 * Its syntax is DisplayString (based on perltype OCTETSTR)
 * The net-snmp type is ASN_OCTET_STR. The C type decl is char (char)
 * This data type requires a length.  (Max 32)
 */
/**
 * Extract the current value of the pstatsDescr data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param pstatsDescr_val_ptr_ptr
 *        Pointer to storage for a char variable
 * @param pstatsDescr_val_ptr_len_ptr
 *        Pointer to a size_t. On entry, it will contain the size (in bytes)
 *        pointed to by pstatsDescr.
 *        On exit, this value should contain the data size (in bytes).
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
*
 * @note If you need more than (*pstatsDescr_val_ptr_len_ptr) bytes of memory,
 *       allocate it using malloc() and update pstatsDescr_val_ptr_ptr.
 *       <b>DO NOT</b> free the previous pointer.
 *       The MFD helper will release the memory you allocate.
 *
 * @remark If you call this function yourself, you are responsible
 *         for checking if the pointer changed, and freeing any
 *         previously allocated memory. (Not necessary if you pass
 *         in a pointer to static memory, obviously.)
 */
int
pstatsDescr_get(pstatsTable_rowreq_ctx * rowreq_ctx,
                char **pstatsDescr_val_ptr_ptr,
                size_t *pstatsDescr_val_ptr_len_ptr)
{
   /** we should have a non-NULL pointer and enough storage */
    netsnmp_assert((NULL != pstatsDescr_val_ptr_ptr)
                   && (NULL != *pstatsDescr_val_ptr_ptr));
    netsnmp_assert(NULL != pstatsDescr_val_ptr_len_ptr);


    DEBUGMSGTL(("verbose:pstatsTable:pstatsDescr_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the pstatsDescr data.
     * copy (* pstatsDescr_val_ptr_ptr ) data and (* pstatsDescr_val_ptr_len_ptr ) from rowreq_ctx->data
     */
    /*
     * make sure there is enough space for pstatsDescr data
     */
    if ((NULL == (*pstatsDescr_val_ptr_ptr)) ||
        ((*pstatsDescr_val_ptr_len_ptr) <
         (rowreq_ctx->data.pstatsDescr_len *
          sizeof(rowreq_ctx->data.pstatsDescr[0])))) {
        /*
         * allocate space for pstatsDescr data
         */
        (*pstatsDescr_val_ptr_ptr) =
            malloc(rowreq_ctx->data.pstatsDescr_len *
                   sizeof(rowreq_ctx->data.pstatsDescr[0]));
        if (NULL == (*pstatsDescr_val_ptr_ptr)) {
            snmp_log(LOG_ERR, "could not allocate memory\n");
            return MFD_ERROR;
        }
    }
    (*pstatsDescr_val_ptr_len_ptr) =
        rowreq_ctx->data.pstatsDescr_len *
        sizeof(rowreq_ctx->data.pstatsDescr[0]);
    memcpy((*pstatsDescr_val_ptr_ptr), rowreq_ctx->data.pstatsDescr,
           rowreq_ctx->data.pstatsDescr_len *
           sizeof(rowreq_ctx->data.pstatsDescr[0]));

    return MFD_SUCCESS;
}                               /* pstatsDescr_get */

/*---------------------------------------------------------------------
 * WR-SWITCH-MIB::pstatsEntry.pstatsWR0
 * pstatsWR0 is subid 3 of pstatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.96.100.2.2.1.3
 * Description:
The value of this counter for interface wr0.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the pstatsWR0 data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param pstatsWR0_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
pstatsWR0_get(pstatsTable_rowreq_ctx * rowreq_ctx,
              u_long * pstatsWR0_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != pstatsWR0_val_ptr);


    DEBUGMSGTL(("verbose:pstatsTable:pstatsWR0_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the pstatsWR0 data.
     * copy (* pstatsWR0_val_ptr ) from rowreq_ctx->data
     */
    (*pstatsWR0_val_ptr) = rowreq_ctx->data.pstatsWR0;

    return MFD_SUCCESS;
}                               /* pstatsWR0_get */

/*---------------------------------------------------------------------
 * WR-SWITCH-MIB::pstatsEntry.pstatsWR1
 * pstatsWR1 is subid 4 of pstatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.96.100.2.2.1.4
 * Description:
The value of this counter for interface wr1.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the pstatsWR1 data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param pstatsWR1_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
pstatsWR1_get(pstatsTable_rowreq_ctx * rowreq_ctx,
              u_long * pstatsWR1_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != pstatsWR1_val_ptr);


    DEBUGMSGTL(("verbose:pstatsTable:pstatsWR1_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the pstatsWR1 data.
     * copy (* pstatsWR1_val_ptr ) from rowreq_ctx->data
     */
    (*pstatsWR1_val_ptr) = rowreq_ctx->data.pstatsWR1;

    return MFD_SUCCESS;
}                               /* pstatsWR1_get */

/*---------------------------------------------------------------------
 * WR-SWITCH-MIB::pstatsEntry.pstatsWR2
 * pstatsWR2 is subid 5 of pstatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.96.100.2.2.1.5
 * Description:
The value of this counter for interface wr2.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the pstatsWR2 data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param pstatsWR2_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
pstatsWR2_get(pstatsTable_rowreq_ctx * rowreq_ctx,
              u_long * pstatsWR2_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != pstatsWR2_val_ptr);


    DEBUGMSGTL(("verbose:pstatsTable:pstatsWR2_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the pstatsWR2 data.
     * copy (* pstatsWR2_val_ptr ) from rowreq_ctx->data
     */
    (*pstatsWR2_val_ptr) = rowreq_ctx->data.pstatsWR2;

    return MFD_SUCCESS;
}                               /* pstatsWR2_get */

/*---------------------------------------------------------------------
 * WR-SWITCH-MIB::pstatsEntry.pstatsWR3
 * pstatsWR3 is subid 6 of pstatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.96.100.2.2.1.6
 * Description:
The value of this counter for interface wr3.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the pstatsWR3 data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param pstatsWR3_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
pstatsWR3_get(pstatsTable_rowreq_ctx * rowreq_ctx,
              u_long * pstatsWR3_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != pstatsWR3_val_ptr);


    DEBUGMSGTL(("verbose:pstatsTable:pstatsWR3_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the pstatsWR3 data.
     * copy (* pstatsWR3_val_ptr ) from rowreq_ctx->data
     */
    (*pstatsWR3_val_ptr) = rowreq_ctx->data.pstatsWR3;

    return MFD_SUCCESS;
}                               /* pstatsWR3_get */

/*---------------------------------------------------------------------
 * WR-SWITCH-MIB::pstatsEntry.pstatsWR4
 * pstatsWR4 is subid 7 of pstatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.96.100.2.2.1.7
 * Description:
The value of this counter for interface wr4.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the pstatsWR4 data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param pstatsWR4_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
pstatsWR4_get(pstatsTable_rowreq_ctx * rowreq_ctx,
              u_long * pstatsWR4_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != pstatsWR4_val_ptr);


    DEBUGMSGTL(("verbose:pstatsTable:pstatsWR4_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the pstatsWR4 data.
     * copy (* pstatsWR4_val_ptr ) from rowreq_ctx->data
     */
    (*pstatsWR4_val_ptr) = rowreq_ctx->data.pstatsWR4;

    return MFD_SUCCESS;
}                               /* pstatsWR4_get */

/*---------------------------------------------------------------------
 * WR-SWITCH-MIB::pstatsEntry.pstatsWR5
 * pstatsWR5 is subid 8 of pstatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.96.100.2.2.1.8
 * Description:
The value of this counter for interface wr5.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the pstatsWR5 data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param pstatsWR5_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
pstatsWR5_get(pstatsTable_rowreq_ctx * rowreq_ctx,
              u_long * pstatsWR5_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != pstatsWR5_val_ptr);


    DEBUGMSGTL(("verbose:pstatsTable:pstatsWR5_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the pstatsWR5 data.
     * copy (* pstatsWR5_val_ptr ) from rowreq_ctx->data
     */
    (*pstatsWR5_val_ptr) = rowreq_ctx->data.pstatsWR5;

    return MFD_SUCCESS;
}                               /* pstatsWR5_get */

/*---------------------------------------------------------------------
 * WR-SWITCH-MIB::pstatsEntry.pstatsWR6
 * pstatsWR6 is subid 9 of pstatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.96.100.2.2.1.9
 * Description:
The value of this counter for interface wr6.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the pstatsWR6 data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param pstatsWR6_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
pstatsWR6_get(pstatsTable_rowreq_ctx * rowreq_ctx,
              u_long * pstatsWR6_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != pstatsWR6_val_ptr);


    DEBUGMSGTL(("verbose:pstatsTable:pstatsWR6_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the pstatsWR6 data.
     * copy (* pstatsWR6_val_ptr ) from rowreq_ctx->data
     */
    (*pstatsWR6_val_ptr) = rowreq_ctx->data.pstatsWR6;

    return MFD_SUCCESS;
}                               /* pstatsWR6_get */

/*---------------------------------------------------------------------
 * WR-SWITCH-MIB::pstatsEntry.pstatsWR7
 * pstatsWR7 is subid 10 of pstatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.96.100.2.2.1.10
 * Description:
The value of this counter for interface wr7.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the pstatsWR7 data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param pstatsWR7_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
pstatsWR7_get(pstatsTable_rowreq_ctx * rowreq_ctx,
              u_long * pstatsWR7_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != pstatsWR7_val_ptr);


    DEBUGMSGTL(("verbose:pstatsTable:pstatsWR7_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the pstatsWR7 data.
     * copy (* pstatsWR7_val_ptr ) from rowreq_ctx->data
     */
    (*pstatsWR7_val_ptr) = rowreq_ctx->data.pstatsWR7;

    return MFD_SUCCESS;
}                               /* pstatsWR7_get */

/*---------------------------------------------------------------------
 * WR-SWITCH-MIB::pstatsEntry.pstatsWR8
 * pstatsWR8 is subid 11 of pstatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.96.100.2.2.1.11
 * Description:
The value of this counter for interface wr8.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the pstatsWR8 data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param pstatsWR8_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
pstatsWR8_get(pstatsTable_rowreq_ctx * rowreq_ctx,
              u_long * pstatsWR8_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != pstatsWR8_val_ptr);


    DEBUGMSGTL(("verbose:pstatsTable:pstatsWR8_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the pstatsWR8 data.
     * copy (* pstatsWR8_val_ptr ) from rowreq_ctx->data
     */
    (*pstatsWR8_val_ptr) = rowreq_ctx->data.pstatsWR8;

    return MFD_SUCCESS;
}                               /* pstatsWR8_get */

/*---------------------------------------------------------------------
 * WR-SWITCH-MIB::pstatsEntry.pstatsWR9
 * pstatsWR9 is subid 12 of pstatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.96.100.2.2.1.12
 * Description:
The value of this counter for interface wr9.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the pstatsWR9 data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param pstatsWR9_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
pstatsWR9_get(pstatsTable_rowreq_ctx * rowreq_ctx,
              u_long * pstatsWR9_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != pstatsWR9_val_ptr);


    DEBUGMSGTL(("verbose:pstatsTable:pstatsWR9_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the pstatsWR9 data.
     * copy (* pstatsWR9_val_ptr ) from rowreq_ctx->data
     */
    (*pstatsWR9_val_ptr) = rowreq_ctx->data.pstatsWR9;

    return MFD_SUCCESS;
}                               /* pstatsWR9_get */

/*---------------------------------------------------------------------
 * WR-SWITCH-MIB::pstatsEntry.pstatsWR10
 * pstatsWR10 is subid 13 of pstatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.96.100.2.2.1.13
 * Description:
The value of this counter for interface wr10.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the pstatsWR10 data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param pstatsWR10_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
pstatsWR10_get(pstatsTable_rowreq_ctx * rowreq_ctx,
               u_long * pstatsWR10_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != pstatsWR10_val_ptr);


    DEBUGMSGTL(("verbose:pstatsTable:pstatsWR10_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the pstatsWR10 data.
     * copy (* pstatsWR10_val_ptr ) from rowreq_ctx->data
     */
    (*pstatsWR10_val_ptr) = rowreq_ctx->data.pstatsWR10;

    return MFD_SUCCESS;
}                               /* pstatsWR10_get */

/*---------------------------------------------------------------------
 * WR-SWITCH-MIB::pstatsEntry.pstatsWR11
 * pstatsWR11 is subid 14 of pstatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.96.100.2.2.1.14
 * Description:
The value of this counter for interface wr11.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the pstatsWR11 data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param pstatsWR11_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
pstatsWR11_get(pstatsTable_rowreq_ctx * rowreq_ctx,
               u_long * pstatsWR11_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != pstatsWR11_val_ptr);


    DEBUGMSGTL(("verbose:pstatsTable:pstatsWR11_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the pstatsWR11 data.
     * copy (* pstatsWR11_val_ptr ) from rowreq_ctx->data
     */
    (*pstatsWR11_val_ptr) = rowreq_ctx->data.pstatsWR11;

    return MFD_SUCCESS;
}                               /* pstatsWR11_get */

/*---------------------------------------------------------------------
 * WR-SWITCH-MIB::pstatsEntry.pstatsWR12
 * pstatsWR12 is subid 15 of pstatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.96.100.2.2.1.15
 * Description:
The value of this counter for interface wr12.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the pstatsWR12 data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param pstatsWR12_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
pstatsWR12_get(pstatsTable_rowreq_ctx * rowreq_ctx,
               u_long * pstatsWR12_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != pstatsWR12_val_ptr);


    DEBUGMSGTL(("verbose:pstatsTable:pstatsWR12_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the pstatsWR12 data.
     * copy (* pstatsWR12_val_ptr ) from rowreq_ctx->data
     */
    (*pstatsWR12_val_ptr) = rowreq_ctx->data.pstatsWR12;

    return MFD_SUCCESS;
}                               /* pstatsWR12_get */

/*---------------------------------------------------------------------
 * WR-SWITCH-MIB::pstatsEntry.pstatsWR13
 * pstatsWR13 is subid 16 of pstatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.96.100.2.2.1.16
 * Description:
The value of this counter for interface wr13.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the pstatsWR13 data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param pstatsWR13_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
pstatsWR13_get(pstatsTable_rowreq_ctx * rowreq_ctx,
               u_long * pstatsWR13_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != pstatsWR13_val_ptr);


    DEBUGMSGTL(("verbose:pstatsTable:pstatsWR13_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the pstatsWR13 data.
     * copy (* pstatsWR13_val_ptr ) from rowreq_ctx->data
     */
    (*pstatsWR13_val_ptr) = rowreq_ctx->data.pstatsWR13;

    return MFD_SUCCESS;
}                               /* pstatsWR13_get */

/*---------------------------------------------------------------------
 * WR-SWITCH-MIB::pstatsEntry.pstatsWR14
 * pstatsWR14 is subid 17 of pstatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.96.100.2.2.1.17
 * Description:
The value of this counter for interface wr14.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the pstatsWR14 data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param pstatsWR14_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
pstatsWR14_get(pstatsTable_rowreq_ctx * rowreq_ctx,
               u_long * pstatsWR14_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != pstatsWR14_val_ptr);


    DEBUGMSGTL(("verbose:pstatsTable:pstatsWR14_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the pstatsWR14 data.
     * copy (* pstatsWR14_val_ptr ) from rowreq_ctx->data
     */
    (*pstatsWR14_val_ptr) = rowreq_ctx->data.pstatsWR14;

    return MFD_SUCCESS;
}                               /* pstatsWR14_get */

/*---------------------------------------------------------------------
 * WR-SWITCH-MIB::pstatsEntry.pstatsWR15
 * pstatsWR15 is subid 18 of pstatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.96.100.2.2.1.18
 * Description:
The value of this counter for interface wr15.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the pstatsWR15 data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param pstatsWR15_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
pstatsWR15_get(pstatsTable_rowreq_ctx * rowreq_ctx,
               u_long * pstatsWR15_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != pstatsWR15_val_ptr);


    DEBUGMSGTL(("verbose:pstatsTable:pstatsWR15_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the pstatsWR15 data.
     * copy (* pstatsWR15_val_ptr ) from rowreq_ctx->data
     */
    (*pstatsWR15_val_ptr) = rowreq_ctx->data.pstatsWR15;

    return MFD_SUCCESS;
}                               /* pstatsWR15_get */

/*---------------------------------------------------------------------
 * WR-SWITCH-MIB::pstatsEntry.pstatsWR16
 * pstatsWR16 is subid 19 of pstatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.96.100.2.2.1.19
 * Description:
The value of this counter for interface wr16.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the pstatsWR16 data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param pstatsWR16_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
pstatsWR16_get(pstatsTable_rowreq_ctx * rowreq_ctx,
               u_long * pstatsWR16_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != pstatsWR16_val_ptr);


    DEBUGMSGTL(("verbose:pstatsTable:pstatsWR16_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the pstatsWR16 data.
     * copy (* pstatsWR16_val_ptr ) from rowreq_ctx->data
     */
    (*pstatsWR16_val_ptr) = rowreq_ctx->data.pstatsWR16;

    return MFD_SUCCESS;
}                               /* pstatsWR16_get */

/*---------------------------------------------------------------------
 * WR-SWITCH-MIB::pstatsEntry.pstatsWR17
 * pstatsWR17 is subid 20 of pstatsEntry.
 * Its status is Current, and its access level is ReadOnly.
 * OID: .1.3.6.1.4.1.96.100.2.2.1.20
 * Description:
The value of this counter for interface wr17.
 *
 * Attributes:
 *   accessible 1     isscalar 0     enums  0      hasdefval 0
 *   readable   1     iscolumn 1     ranges 0      hashint   0
 *   settable   0
 *
 *
 * Its syntax is COUNTER (based on perltype COUNTER)
 * The net-snmp type is ASN_COUNTER. The C type decl is u_long (u_long)
 */
/**
 * Extract the current value of the pstatsWR17 data.
 *
 * Set a value using the data context for the row.
 *
 * @param rowreq_ctx
 *        Pointer to the row request context.
 * @param pstatsWR17_val_ptr
 *        Pointer to storage for a u_long variable
 *
 * @retval MFD_SUCCESS         : success
 * @retval MFD_SKIP            : skip this node (no value for now)
 * @retval MFD_ERROR           : Any other error
 */
int
pstatsWR17_get(pstatsTable_rowreq_ctx * rowreq_ctx,
               u_long * pstatsWR17_val_ptr)
{
   /** we should have a non-NULL pointer */
    netsnmp_assert(NULL != pstatsWR17_val_ptr);


    DEBUGMSGTL(("verbose:pstatsTable:pstatsWR17_get", "called\n"));

    netsnmp_assert(NULL != rowreq_ctx);

    /*
     * TODO:231:o: |-> Extract the current value of the pstatsWR17 data.
     * copy (* pstatsWR17_val_ptr ) from rowreq_ctx->data
     */
    (*pstatsWR17_val_ptr) = rowreq_ctx->data.pstatsWR17;

    return MFD_SUCCESS;
}                               /* pstatsWR17_get */



/** @} */
