diff -N -r -up ./u-boot-1.3.4.orig/board/atmel/at91sam9263ek/at91sam9263ek.c ./u-boot-1.3.4/board/atmel/at91sam9263ek/at91sam9263ek.c
--- ./u-boot-1.3.4.orig/board/atmel/at91sam9263ek/at91sam9263ek.c	2008-08-12 16:08:38.000000000 +0200
+++ ./u-boot-1.3.4/board/atmel/at91sam9263ek/at91sam9263ek.c	2009-06-01 18:05:06.000000000 +0200
@@ -103,8 +103,9 @@ static void at91sam9263ek_nand_hw_init(v
 	at91_sys_write(AT91_PMC_PCER, 1 << AT91SAM9263_ID_PIOA |
 				      1 << AT91SAM9263_ID_PIOCDE);
 
-	/* Configure RDY/BSY */
-	at91_set_gpio_input(AT91_PIN_PA22, 1);
+	/* Configure RDY/BSY */ 
+
+at91_set_gpio_input(AT91_PIN_PE19, 1);
 
 	/* Enable NandFlash */
 	at91_set_gpio_output(AT91_PIN_PD15, 1);
diff -N -r -up ./u-boot-1.3.4.orig/board/atmel/at91sam9263ek/nand.c ./u-boot-1.3.4/board/atmel/at91sam9263ek/nand.c
--- ./u-boot-1.3.4.orig/board/atmel/at91sam9263ek/nand.c	2008-08-12 16:08:38.000000000 +0200
+++ ./u-boot-1.3.4/board/atmel/at91sam9263ek/nand.c	2009-06-01 18:04:41.000000000 +0200
@@ -62,7 +62,7 @@ static void at91sam9263ek_nand_hwcontrol
 
 static int at91sam9263ek_nand_ready(struct mtd_info *mtd)
 {
-	return at91_get_gpio_value(AT91_PIN_PA22);
+	return at91_get_gpio_value(AT91_PIN_PE19);
 }
 
 int board_nand_init(struct nand_chip *nand)
diff -N -r -up ./u-boot-1.3.4.orig/board/atmel/at91sam9g20ek/at91sam9g20ek.c ./u-boot-1.3.4/board/atmel/at91sam9g20ek/at91sam9g20ek.c
--- ./u-boot-1.3.4.orig/board/atmel/at91sam9g20ek/at91sam9g20ek.c	1970-01-01 01:00:00.000000000 +0100
+++ ./u-boot-1.3.4/board/atmel/at91sam9g20ek/at91sam9g20ek.c	2009-06-01 18:05:21.000000000 +0200
@@ -0,0 +1,250 @@
+/*
+ * (C) Copyright 2007-2008
+ * Stelian Pop <stelian.pop@leadtechdesign.com>
+ * Lead Tech Design <www.leadtechdesign.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/arch/at91sam9260.h>
+#include <asm/arch/at91sam9260_matrix.h>
+#include <asm/arch/at91sam9_smc.h>
+#include <asm/arch/at91_pmc.h>
+#include <asm/arch/at91_rstc.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/io.h>
+#if defined(CONFIG_RESET_PHY_R) && defined(CONFIG_MACB)
+#include <net.h>
+#endif
+
+DECLARE_GLOBAL_DATA_PTR;
+
+/* ------------------------------------------------------------------------- */
+/*
+ * Miscelaneous platform dependent initialisations
+ */
+
+static void at91sam9g20ek_serial_hw_init(void)
+{
+#ifdef CONFIG_USART0
+	at91_set_A_periph(AT91_PIN_PB4, 1);		/* TXD0 */
+	at91_set_A_periph(AT91_PIN_PB5, 0);		/* RXD0 */
+	at91_sys_write(AT91_PMC_PCER, 1 << AT91_ID_US0);
+#endif
+
+#ifdef CONFIG_USART1
+	at91_set_A_periph(AT91_PIN_PB6, 1);		/* TXD1 */
+	at91_set_A_periph(AT91_PIN_PB7, 0);		/* RXD1 */
+	at91_sys_write(AT91_PMC_PCER, 1 << AT91_ID_US1);
+#endif
+
+#ifdef CONFIG_USART2
+	at91_set_A_periph(AT91_PIN_PB8, 1);		/* TXD2 */
+	at91_set_A_periph(AT91_PIN_PB9, 0);		/* RXD2 */
+	at91_sys_write(AT91_PMC_PCER, 1 << AT91_ID_US2);
+#endif
+
+#ifdef CONFIG_USART3	/* DBGU */
+	at91_set_A_periph(AT91_PIN_PB14, 0);		/* DRXD */
+	at91_set_A_periph(AT91_PIN_PB15, 1);		/* DTXD */
+	at91_sys_write(AT91_PMC_PCER, 1 << AT91_ID_SYS);
+#endif
+}
+
+#ifdef CONFIG_CMD_NAND
+static void at91sam9g20ek_nand_hw_init(void)
+{
+	unsigned long csa;
+
+	/* Enable CS3 */
+	csa = at91_sys_read(AT91_MATRIX_EBICSA);
+	at91_sys_write(AT91_MATRIX_EBICSA,
+		       csa | AT91_MATRIX_CS3A_SMC_SMARTMEDIA);
+
+	/* Configure SMC CS3 for NAND/SmartMedia */
+	at91_sys_write(AT91_SMC_SETUP(3),
+		       AT91_SMC_NWESETUP_(2) | AT91_SMC_NCS_WRSETUP_(0) |
+		       AT91_SMC_NRDSETUP_(2) | AT91_SMC_NCS_RDSETUP_(0));
+	at91_sys_write(AT91_SMC_PULSE(3),
+		       AT91_SMC_NWEPULSE_(4) | AT91_SMC_NCS_WRPULSE_(3) |
+		       AT91_SMC_NRDPULSE_(4) | AT91_SMC_NCS_RDPULSE_(3));
+	at91_sys_write(AT91_SMC_CYCLE(3),
+		       AT91_SMC_NWECYCLE_(7) | AT91_SMC_NRDCYCLE_(7));
+	at91_sys_write(AT91_SMC_MODE(3),
+		       AT91_SMC_READMODE | AT91_SMC_WRITEMODE |
+		       AT91_SMC_EXNWMODE_DISABLE |
+#ifdef CFG_NAND_DBW_16
+		       AT91_SMC_DBW_16 |
+#else /* CFG_NAND_DBW_8 */
+		       AT91_SMC_DBW_8 |
+#endif
+		       AT91_SMC_TDF_(3));
+
+	at91_sys_write(AT91_PMC_PCER, 1 << AT91SAM9260_ID_PIOC);
+
+	/* Configure RDY/BSY */
+	at91_set_gpio_input(AT91_PIN_PC13, 1);
+
+	/* Enable NandFlash */
+	at91_set_gpio_output(AT91_PIN_PC14, 1);
+}
+#endif
+
+#ifdef CONFIG_HAS_DATAFLASH
+static void at91sam9g20ek_spi_hw_init(void)
+{
+	at91_set_A_periph(AT91_PIN_PA3, 0);	/* SPI0_NPCS0 */
+	at91_set_B_periph(AT91_PIN_PC11, 0);	/* SPI0_NPCS1 */
+
+	at91_set_A_periph(AT91_PIN_PA0, 0);	/* SPI0_MISO */
+	at91_set_A_periph(AT91_PIN_PA1, 0);	/* SPI0_MOSI */
+	at91_set_A_periph(AT91_PIN_PA2, 0);	/* SPI0_SPCK */
+
+	/* Enable clock */
+	at91_sys_write(AT91_PMC_PCER, 1 << AT91SAM9260_ID_SPI0);
+}
+#endif
+
+#ifdef CONFIG_MACB
+static void at91sam9g20ek_macb_hw_init(void)
+{
+	/* Enable clock */
+	at91_sys_write(AT91_PMC_PCER, 1 << AT91SAM9260_ID_EMAC);
+
+	/*
+	 * Disable pull-up on:
+	 *	RXDV (PA17) => PHY normal mode (not Test mode)
+	 *	ERX0 (PA14) => PHY ADDR0
+	 *	ERX1 (PA15) => PHY ADDR1
+	 *	ERX2 (PA25) => PHY ADDR2
+	 *	ERX3 (PA26) => PHY ADDR3
+	 *	ECRS (PA28) => PHY ADDR4  => PHYADDR = 0x0
+	 *
+	 * PHY has internal pull-down
+	 */
+	writel(pin_to_mask(AT91_PIN_PA14) |
+	       pin_to_mask(AT91_PIN_PA15) |
+	       pin_to_mask(AT91_PIN_PA17) |
+	       pin_to_mask(AT91_PIN_PA25) |
+	       pin_to_mask(AT91_PIN_PA26) |
+	       pin_to_mask(AT91_PIN_PA28),
+	       pin_to_controller(AT91_PIN_PA0) + PIO_PUDR);
+
+	/* Need to reset PHY -> 500ms reset */
+	at91_sys_write(AT91_RSTC_MR, AT91_RSTC_KEY |
+				     (AT91_RSTC_ERSTL & (0x0D << 8)) |
+				     AT91_RSTC_URSTEN);
+
+	at91_sys_write(AT91_RSTC_CR, AT91_RSTC_KEY | AT91_RSTC_EXTRST);
+
+	/* Wait for end hardware reset */
+	while (!(at91_sys_read(AT91_RSTC_SR) & AT91_RSTC_NRSTL));
+
+	/* Restore NRST value */
+	at91_sys_write(AT91_RSTC_MR, AT91_RSTC_KEY |
+				     (AT91_RSTC_ERSTL & (0x0 << 8)) |
+				     AT91_RSTC_URSTEN);
+
+	/* Re-enable pull-up */
+	writel(pin_to_mask(AT91_PIN_PA14) |
+	       pin_to_mask(AT91_PIN_PA15) |
+	       pin_to_mask(AT91_PIN_PA17) |
+	       pin_to_mask(AT91_PIN_PA25) |
+	       pin_to_mask(AT91_PIN_PA26) |
+	       pin_to_mask(AT91_PIN_PA28),
+	       pin_to_controller(AT91_PIN_PA0) + PIO_PUER);
+
+	at91_set_A_periph(AT91_PIN_PA19, 0);	/* ETXCK_EREFCK */
+	at91_set_A_periph(AT91_PIN_PA17, 0);	/* ERXDV */
+	at91_set_A_periph(AT91_PIN_PA14, 0);	/* ERX0 */
+	at91_set_A_periph(AT91_PIN_PA15, 0);	/* ERX1 */
+	at91_set_A_periph(AT91_PIN_PA18, 0);	/* ERXER */
+	at91_set_A_periph(AT91_PIN_PA16, 0);	/* ETXEN */
+	at91_set_A_periph(AT91_PIN_PA12, 0);	/* ETX0 */
+	at91_set_A_periph(AT91_PIN_PA13, 0);	/* ETX1 */
+	at91_set_A_periph(AT91_PIN_PA21, 0);	/* EMDIO */
+	at91_set_A_periph(AT91_PIN_PA20, 0);	/* EMDC */
+
+#ifndef CONFIG_RMII
+	at91_set_B_periph(AT91_PIN_PA28, 0);	/* ECRS */
+	at91_set_B_periph(AT91_PIN_PA29, 0);	/* ECOL */
+	at91_set_B_periph(AT91_PIN_PA25, 0);	/* ERX2 */
+	at91_set_B_periph(AT91_PIN_PA26, 0);	/* ERX3 */
+	at91_set_B_periph(AT91_PIN_PA27, 0);	/* ERXCK */
+#if defined(CONFIG_AT91SAM9G20EK)
+	/*
+	 * use PA10, PA11 for ETX2, ETX3.
+	 * PA23 and PA24 are for TWI EEPROM
+	 */
+	at91_set_B_periph(AT91_PIN_PA10, 0);    /* ETX2 */
+	at91_set_B_periph(AT91_PIN_PA11, 0);    /* ETX3 */
+#else
+	at91_set_B_periph(AT91_PIN_PA23, 0);    /* ETX2 */
+	at91_set_B_periph(AT91_PIN_PA24, 0);    /* ETX3 */
+#endif
+	at91_set_B_periph(AT91_PIN_PA22, 0);	/* ETXER */
+#endif
+
+}
+#endif
+
+int board_init(void)
+{
+	/* Enable Ctrlc */
+	console_init_f();
+
+	/* arch number of AT91SAM9G20EK-Board */
+	gd->bd->bi_arch_number = MACH_TYPE_AT91SAM9G20EK;
+	/* adress of boot parameters */
+	gd->bd->bi_boot_params = PHYS_SDRAM + 0x100;
+
+	at91sam9g20ek_serial_hw_init();
+#ifdef CONFIG_CMD_NAND
+	at91sam9g20ek_nand_hw_init();
+#endif
+#ifdef CONFIG_HAS_DATAFLASH
+	at91sam9g20ek_spi_hw_init();
+#endif
+#ifdef CONFIG_MACB
+	at91sam9g20ek_macb_hw_init();
+#endif
+
+	return 0;
+}
+
+int dram_init(void)
+{
+	gd->bd->bi_dram[0].start = PHYS_SDRAM;
+	gd->bd->bi_dram[0].size = PHYS_SDRAM_SIZE;
+	return 0;
+}
+
+#ifdef CONFIG_RESET_PHY_R
+void reset_phy(void)
+{
+#ifdef CONFIG_MACB
+	/*
+	 * Initialize ethernet HW addr prior to starting Linux,
+	 * needed for nfsroot
+	 */
+	eth_init(gd->bd);
+#endif
+}
+#endif
diff -N -r -up ./u-boot-1.3.4.orig/board/atmel/at91sam9g20ek/config.mk ./u-boot-1.3.4/board/atmel/at91sam9g20ek/config.mk
--- ./u-boot-1.3.4.orig/board/atmel/at91sam9g20ek/config.mk	1970-01-01 01:00:00.000000000 +0100
+++ ./u-boot-1.3.4/board/atmel/at91sam9g20ek/config.mk	2009-06-01 18:05:21.000000000 +0200
@@ -0,0 +1 @@
+TEXT_BASE = 0x23f00000
diff -N -r -up ./u-boot-1.3.4.orig/board/atmel/at91sam9g20ek/led.c ./u-boot-1.3.4/board/atmel/at91sam9g20ek/led.c
--- ./u-boot-1.3.4.orig/board/atmel/at91sam9g20ek/led.c	1970-01-01 01:00:00.000000000 +0100
+++ ./u-boot-1.3.4/board/atmel/at91sam9g20ek/led.c	2009-06-01 18:05:21.000000000 +0200
@@ -0,0 +1,64 @@
+/*
+ * (C) Copyright 2007-2008
+ * Stelian Pop <stelian.pop@leadtechdesign.com>
+ * Lead Tech Design <www.leadtechdesign.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/arch/at91sam9260.h>
+#include <asm/arch/at91_pmc.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/io.h>
+
+#define	RED_LED		AT91_PIN_PA9	/* this is the power led */
+#define	GREEN_LED	AT91_PIN_PA6	/* this is the user led */
+
+void red_LED_on(void)
+{
+	at91_set_gpio_value(RED_LED, 1);
+}
+
+void red_LED_off(void)
+{
+	at91_set_gpio_value(RED_LED, 0);
+}
+
+void green_LED_on(void)
+{
+	at91_set_gpio_value(GREEN_LED, 0);
+}
+
+void green_LED_off(void)
+{
+	at91_set_gpio_value(GREEN_LED, 1);
+}
+
+void coloured_LED_init(void)
+{
+	/* Enable clock */
+	at91_sys_write(AT91_PMC_PCER, 1 << AT91SAM9260_ID_PIOA);
+
+	at91_set_gpio_output(RED_LED, 1);
+	at91_set_gpio_output(GREEN_LED, 1);
+
+	at91_set_gpio_value(RED_LED, 0);
+	at91_set_gpio_value(GREEN_LED, 1);
+}
diff -N -r -up ./u-boot-1.3.4.orig/board/atmel/at91sam9g20ek/Makefile ./u-boot-1.3.4/board/atmel/at91sam9g20ek/Makefile
--- ./u-boot-1.3.4.orig/board/atmel/at91sam9g20ek/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ ./u-boot-1.3.4/board/atmel/at91sam9g20ek/Makefile	2009-06-01 18:05:21.000000000 +0200
@@ -0,0 +1,57 @@
+#
+# (C) Copyright 2003-2008
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# (C) Copyright 2008
+# Stelian Pop <stelian.pop@leadtechdesign.com>
+# Lead Tech Design <www.leadtechdesign.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+COBJS-y	+= at91sam9g20ek.o
+COBJS-y	+= led.o
+COBJS-y	+= partition.o
+COBJS-$(CONFIG_CMD_NAND) += nand.o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS-y:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS-y))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak $(obj).depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -N -r -up ./u-boot-1.3.4.orig/board/atmel/at91sam9g20ek/nand.c ./u-boot-1.3.4/board/atmel/at91sam9g20ek/nand.c
--- ./u-boot-1.3.4.orig/board/atmel/at91sam9g20ek/nand.c	1970-01-01 01:00:00.000000000 +0100
+++ ./u-boot-1.3.4/board/atmel/at91sam9g20ek/nand.c	2009-06-01 18:05:21.000000000 +0200
@@ -0,0 +1,79 @@
+/*
+ * (C) Copyright 2007-2008
+ * Stelian Pop <stelian.pop@leadtechdesign.com>
+ * Lead Tech Design <www.leadtechdesign.com>
+ *
+ * (C) Copyright 2006 ATMEL Rousset, Lacressonniere Nicolas
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/arch/at91sam9260.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/at91_pio.h>
+
+#include <nand.h>
+
+/*
+ *	hardware specific access to control-lines
+ */
+#define	MASK_ALE	(1 << 21)	/* our ALE is AD21 */
+#define	MASK_CLE	(1 << 22)	/* our CLE is AD22 */
+
+static void at91sam9g20ek_nand_hwcontrol(struct mtd_info *mtd, int cmd)
+{
+	struct nand_chip *this = mtd->priv;
+	ulong IO_ADDR_W = (ulong) this->IO_ADDR_W;
+
+	IO_ADDR_W &= ~(MASK_ALE|MASK_CLE);
+	switch (cmd) {
+	case NAND_CTL_SETCLE:
+		IO_ADDR_W |= MASK_CLE;
+		break;
+	case NAND_CTL_SETALE:
+		IO_ADDR_W |= MASK_ALE;
+		break;
+	case NAND_CTL_CLRNCE:
+		at91_set_gpio_value(AT91_PIN_PC14, 1);
+		break;
+	case NAND_CTL_SETNCE:
+		at91_set_gpio_value(AT91_PIN_PC14, 0);
+		break;
+	}
+	this->IO_ADDR_W = (void *) IO_ADDR_W;
+}
+
+static int at91sam9g20ek_nand_ready(struct mtd_info *mtd)
+{
+	return at91_get_gpio_value(AT91_PIN_PC13);
+}
+
+int board_nand_init(struct nand_chip *nand)
+{
+	nand->eccmode = NAND_ECC_SOFT;
+#ifdef CFG_NAND_DBW_16
+	nand->options = NAND_BUSWIDTH_16;
+#endif
+	nand->hwcontrol = at91sam9g20ek_nand_hwcontrol;
+	nand->dev_ready = at91sam9g20ek_nand_ready;
+	nand->chip_delay = 20;
+
+	return 0;
+}
diff -N -r -up ./u-boot-1.3.4.orig/board/atmel/at91sam9g20ek/partition.c ./u-boot-1.3.4/board/atmel/at91sam9g20ek/partition.c
--- ./u-boot-1.3.4.orig/board/atmel/at91sam9g20ek/partition.c	1970-01-01 01:00:00.000000000 +0100
+++ ./u-boot-1.3.4/board/atmel/at91sam9g20ek/partition.c	2009-06-01 18:05:21.000000000 +0200
@@ -0,0 +1,40 @@
+/*
+ * (C) Copyright 2008
+ * Ulf Samuelsson <ulf@atmel.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ */
+#include <common.h>
+#include <config.h>
+#include <asm/hardware.h>
+#include <dataflash.h>
+
+AT91S_DATAFLASH_INFO dataflash_info[CFG_MAX_DATAFLASH_BANKS];
+
+struct dataflash_addr cs[CFG_MAX_DATAFLASH_BANKS] = {
+	{CFG_DATAFLASH_LOGIC_ADDR_CS0, 0},	/* Logical adress, CS */
+	{CFG_DATAFLASH_LOGIC_ADDR_CS1, 1}
+};
+
+/*define the area offsets*/
+dataflash_protect_t area_list[NB_DATAFLASH_AREA] = {
+	{0x00000000, 0x000041FF, FLAG_PROTECT_SET,   0, "Bootstrap"},
+	{0x00004200, 0x000083FF, FLAG_PROTECT_CLEAR, 0, "Environment"},
+	{0x00008400, 0x00041FFF, FLAG_PROTECT_SET,   0, "U-Boot"},
+	{0x00042000, 0x00251FFF, FLAG_PROTECT_CLEAR, 0,	"Kernel"},
+	{0x00252000, 0xFFFFFFFF, FLAG_PROTECT_CLEAR, 0,	"FS"},
+};
diff -N -r -up ./u-boot-1.3.4.orig/board/atmel/whiterabbit_mch/config.mk ./u-boot-1.3.4/board/atmel/whiterabbit_mch/config.mk
--- ./u-boot-1.3.4.orig/board/atmel/whiterabbit_mch/config.mk	1970-01-01 01:00:00.000000000 +0100
+++ ./u-boot-1.3.4/board/atmel/whiterabbit_mch/config.mk	2008-08-12 16:08:38.000000000 +0200
@@ -0,0 +1 @@
+TEXT_BASE = 0x23f00000
diff -N -r -up ./u-boot-1.3.4.orig/board/atmel/whiterabbit_mch/led.c ./u-boot-1.3.4/board/atmel/whiterabbit_mch/led.c
--- ./u-boot-1.3.4.orig/board/atmel/whiterabbit_mch/led.c	1970-01-01 01:00:00.000000000 +0100
+++ ./u-boot-1.3.4/board/atmel/whiterabbit_mch/led.c	2008-08-12 16:08:38.000000000 +0200
@@ -0,0 +1,78 @@
+/*
+ * (C) Copyright 2007-2008
+ * Stelian Pop <stelian.pop@leadtechdesign.com>
+ * Lead Tech Design <www.leadtechdesign.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/arch/at91sam9263.h>
+#include <asm/arch/at91_pmc.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/io.h>
+
+#define	RED_LED		AT91_PIN_PB7	/* this is the power led */
+#define	GREEN_LED	AT91_PIN_PB8	/* this is the user1 led */
+#define	YELLOW_LED	AT91_PIN_PC29	/* this is the user2 led */
+
+void red_LED_on(void)
+{
+	at91_set_gpio_value(RED_LED, 1);
+}
+
+void red_LED_off(void)
+{
+	at91_set_gpio_value(RED_LED, 0);
+}
+
+void green_LED_on(void)
+{
+	at91_set_gpio_value(GREEN_LED, 0);
+}
+
+void green_LED_off(void)
+{
+	at91_set_gpio_value(GREEN_LED, 1);
+}
+
+void yellow_LED_on(void)
+{
+	at91_set_gpio_value(YELLOW_LED, 0);
+}
+
+void yellow_LED_off(void)
+{
+	at91_set_gpio_value(YELLOW_LED, 1);
+}
+
+void coloured_LED_init(void)
+{
+	/* Enable clock */
+	at91_sys_write(AT91_PMC_PCER, 1 << AT91SAM9263_ID_PIOB |
+				      1 << AT91SAM9263_ID_PIOCDE);
+
+	at91_set_gpio_output(RED_LED, 1);
+	at91_set_gpio_output(GREEN_LED, 1);
+	at91_set_gpio_output(YELLOW_LED, 1);
+
+	at91_set_gpio_value(RED_LED, 0);
+	at91_set_gpio_value(GREEN_LED, 1);
+	at91_set_gpio_value(YELLOW_LED, 1);
+}
diff -N -r -up ./u-boot-1.3.4.orig/board/atmel/whiterabbit_mch/Makefile ./u-boot-1.3.4/board/atmel/whiterabbit_mch/Makefile
--- ./u-boot-1.3.4.orig/board/atmel/whiterabbit_mch/Makefile	1970-01-01 01:00:00.000000000 +0100
+++ ./u-boot-1.3.4/board/atmel/whiterabbit_mch/Makefile	2009-07-09 05:12:54.000000000 +0200
@@ -0,0 +1,56 @@
+#
+# (C) Copyright 2003-2008
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# (C) Copyright 2008
+# Stelian Pop <stelian.pop@leadtechdesign.com>
+# Lead Tech Design <www.leadtechdesign.com>
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	= $(obj)lib$(BOARD).a
+
+COBJS-y += whiterabbit_mch.o
+COBJS-y	+= partition.o
+COBJS-$(CONFIG_CMD_NAND) += nand.o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS-y:.o=.c)
+OBJS	:= $(addprefix $(obj),$(COBJS-y))
+SOBJS	:= $(addprefix $(obj),$(SOBJS))
+
+$(LIB):	$(obj).depend $(OBJS) $(SOBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS) $(SOBJS)
+
+clean:
+	rm -f $(SOBJS) $(OBJS)
+
+distclean:	clean
+	rm -f $(LIB) core *.bak $(obj).depend
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff -N -r -up ./u-boot-1.3.4.orig/board/atmel/whiterabbit_mch/nand.c ./u-boot-1.3.4/board/atmel/whiterabbit_mch/nand.c
--- ./u-boot-1.3.4.orig/board/atmel/whiterabbit_mch/nand.c	1970-01-01 01:00:00.000000000 +0100
+++ ./u-boot-1.3.4/board/atmel/whiterabbit_mch/nand.c	2009-07-09 05:15:05.000000000 +0200
@@ -0,0 +1,79 @@
+/*
+ * (C) Copyright 2007-2008
+ * Stelian Pop <stelian.pop@leadtechdesign.com>
+ * Lead Tech Design <www.leadtechdesign.com>
+ *
+ * (C) Copyright 2006 ATMEL Rousset, Lacressonniere Nicolas
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/arch/at91sam9263.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/at91_pio.h>
+
+#include <nand.h>
+
+/*
+ *	hardware specific access to control-lines
+ */
+#define	MASK_ALE	(1 << 21)	/* our ALE is AD21 */
+#define	MASK_CLE	(1 << 22)	/* our CLE is AD22 */
+
+static void wr_mch_nand_hwcontrol(struct mtd_info *mtd, int cmd)
+{
+	struct nand_chip *this = mtd->priv;
+	ulong IO_ADDR_W = (ulong) this->IO_ADDR_W;
+
+	IO_ADDR_W &= ~(MASK_ALE|MASK_CLE);
+	switch (cmd) {
+	case NAND_CTL_SETCLE:
+		IO_ADDR_W |= MASK_CLE;
+		break;
+	case NAND_CTL_SETALE:
+		IO_ADDR_W |= MASK_ALE;
+		break;
+	case NAND_CTL_CLRNCE:
+		at91_set_gpio_value(AT91_PIN_PD15, 1);
+		break;
+	case NAND_CTL_SETNCE:
+		at91_set_gpio_value(AT91_PIN_PD15, 0);
+		break;
+	}
+	this->IO_ADDR_W = (void *) IO_ADDR_W;
+}
+
+static int wr_mch_nand_ready(struct mtd_info *mtd)
+{
+	return at91_get_gpio_value(AT91_PIN_PE19);
+}
+
+int board_nand_init(struct nand_chip *nand)
+{
+	nand->eccmode = NAND_ECC_SOFT;
+#ifdef CFG_NAND_DBW_16
+	nand->options = NAND_BUSWIDTH_16;
+#endif
+	nand->hwcontrol = wr_mch_nand_hwcontrol;
+	nand->dev_ready = wr_mch_nand_ready;
+	nand->chip_delay = 20;
+
+	return 0;
+}
diff -N -r -up ./u-boot-1.3.4.orig/board/atmel/whiterabbit_mch/partition.c ./u-boot-1.3.4/board/atmel/whiterabbit_mch/partition.c
--- ./u-boot-1.3.4.orig/board/atmel/whiterabbit_mch/partition.c	1970-01-01 01:00:00.000000000 +0100
+++ ./u-boot-1.3.4/board/atmel/whiterabbit_mch/partition.c	2008-08-12 16:08:38.000000000 +0200
@@ -0,0 +1,39 @@
+/*
+ * (C) Copyright 2008
+ * Ulf Samuelsson <ulf@atmel.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ *
+ */
+#include <common.h>
+#include <config.h>
+#include <asm/hardware.h>
+#include <dataflash.h>
+
+AT91S_DATAFLASH_INFO dataflash_info[CFG_MAX_DATAFLASH_BANKS];
+
+struct dataflash_addr cs[CFG_MAX_DATAFLASH_BANKS] = {
+	{CFG_DATAFLASH_LOGIC_ADDR_CS0, 0},	/* Logical adress, CS */
+};
+
+/*define the area offsets*/
+dataflash_protect_t area_list[NB_DATAFLASH_AREA] = {
+	{0x00000000, 0x000041FF, FLAG_PROTECT_SET,   0, "Bootstrap"},
+	{0x00004200, 0x000083FF, FLAG_PROTECT_CLEAR, 0, "Environment"},
+	{0x00008400, 0x00041FFF, FLAG_PROTECT_SET,   0, "U-Boot"},
+	{0x00042000, 0x00251FFF, FLAG_PROTECT_CLEAR, 0,	"Kernel"},
+	{0x00252000, 0xFFFFFFFF, FLAG_PROTECT_CLEAR, 0,	"FS"},
+};
diff -N -r -up ./u-boot-1.3.4.orig/board/atmel/whiterabbit_mch/whiterabbit_mch.c ./u-boot-1.3.4/board/atmel/whiterabbit_mch/whiterabbit_mch.c
--- ./u-boot-1.3.4.orig/board/atmel/whiterabbit_mch/whiterabbit_mch.c	1970-01-01 01:00:00.000000000 +0100
+++ ./u-boot-1.3.4/board/atmel/whiterabbit_mch/whiterabbit_mch.c	2009-07-09 05:16:02.000000000 +0200
@@ -0,0 +1,238 @@
+/*
+ * (C) Copyright 2007-2008
+ * Stelian Pop <stelian.pop@leadtechdesign.com>
+ * Lead Tech Design <www.leadtechdesign.com>
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+#include <asm/sizes.h>
+#include <asm/arch/at91sam9263.h>
+#include <asm/arch/at91sam9263_matrix.h>
+#include <asm/arch/at91sam9_smc.h>
+#include <asm/arch/at91_pmc.h>
+#include <asm/arch/at91_rstc.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/io.h>
+#include <lcd.h>
+#include <atmel_lcdc.h>
+#if defined(CONFIG_RESET_PHY_R) && defined(CONFIG_MACB)
+#include <net.h>
+#endif
+
+DECLARE_GLOBAL_DATA_PTR;
+
+/* ------------------------------------------------------------------------- */
+/*
+ * Miscelaneous platform dependent initialisations
+ */
+
+static void wr_mch_serial_hw_init(void)
+{
+#ifdef CONFIG_USART0
+	at91_set_A_periph(AT91_PIN_PA26, 1);		/* TXD0 */
+	at91_set_A_periph(AT91_PIN_PA27, 0);		/* RXD0 */
+	at91_sys_write(AT91_PMC_PCER, 1 << AT91_ID_US0);
+#endif
+
+#ifdef CONFIG_USART1
+	at91_set_A_periph(AT91_PIN_PD0, 1);		/* TXD1 */
+	at91_set_A_periph(AT91_PIN_PD1, 0);		/* RXD1 */
+	at91_sys_write(AT91_PMC_PCER, 1 << AT91_ID_US1);
+#endif
+
+#ifdef CONFIG_USART2
+	at91_set_A_periph(AT91_PIN_PD2, 1);		/* TXD2 */
+	at91_set_A_periph(AT91_PIN_PD3, 0);		/* RXD2 */
+	at91_sys_write(AT91_PMC_PCER, 1 << AT91_ID_US2);
+#endif
+
+#ifdef CONFIG_USART3	/* DBGU */
+	at91_set_A_periph(AT91_PIN_PC30, 0);		/* DRXD */
+	at91_set_A_periph(AT91_PIN_PC31, 1);		/* DTXD */
+	at91_sys_write(AT91_PMC_PCER, 1 << AT91_ID_SYS);
+#endif
+}
+
+#ifdef CONFIG_CMD_NAND
+static void wr_mch_nand_hw_init(void)
+{
+	unsigned long csa;
+
+	/* Enable CS3 */
+	csa = at91_sys_read(AT91_MATRIX_EBI0CSA);
+	at91_sys_write(AT91_MATRIX_EBI0CSA,
+		       csa | AT91_MATRIX_EBI0_CS3A_SMC_SMARTMEDIA);
+
+	/* Configure SMC CS3 for NAND/SmartMedia */
+	at91_sys_write(AT91_SMC_SETUP(3),
+		       AT91_SMC_NWESETUP_(1) | AT91_SMC_NCS_WRSETUP_(0) |
+		       AT91_SMC_NRDSETUP_(1) | AT91_SMC_NCS_RDSETUP_(0));
+	at91_sys_write(AT91_SMC_PULSE(3),
+		       AT91_SMC_NWEPULSE_(3) | AT91_SMC_NCS_WRPULSE_(3) |
+		       AT91_SMC_NRDPULSE_(3) | AT91_SMC_NCS_RDPULSE_(3));
+	at91_sys_write(AT91_SMC_CYCLE(3),
+		       AT91_SMC_NWECYCLE_(5) | AT91_SMC_NRDCYCLE_(5));
+	at91_sys_write(AT91_SMC_MODE(3),
+		       AT91_SMC_READMODE | AT91_SMC_WRITEMODE |
+		       AT91_SMC_EXNWMODE_DISABLE |
+#ifdef CFG_NAND_DBW_16
+		       AT91_SMC_DBW_16 |
+#else /* CFG_NAND_DBW_8 */
+		       AT91_SMC_DBW_8 |
+#endif
+		       AT91_SMC_TDF_(2));
+
+	at91_sys_write(AT91_PMC_PCER, 1 << AT91SAM9263_ID_PIOA |
+				      1 << AT91SAM9263_ID_PIOCDE);
+
+	/* Configure RDY/BSY */ 
+
+at91_set_gpio_input(AT91_PIN_PE19, 1);
+
+	/* Enable NandFlash */
+	at91_set_gpio_output(AT91_PIN_PD15, 1);
+}
+#endif
+
+#ifdef CONFIG_HAS_DATAFLASH
+static void wr_mch_spi_hw_init(void)
+{
+	at91_set_B_periph(AT91_PIN_PA5, 0);	/* SPI0_NPCS0 */
+
+	at91_set_B_periph(AT91_PIN_PA0, 0);	/* SPI0_MISO */
+	at91_set_B_periph(AT91_PIN_PA1, 0);	/* SPI0_MOSI */
+	at91_set_B_periph(AT91_PIN_PA2, 0);	/* SPI0_SPCK */
+
+	/* Enable clock */
+	at91_sys_write(AT91_PMC_PCER, 1 << AT91SAM9263_ID_SPI0);
+}
+#endif
+
+#ifdef CONFIG_MACB
+static void wr_mch_macb_hw_init(void)
+{
+	/* Enable clock */
+	at91_sys_write(AT91_PMC_PCER, 1 << AT91SAM9263_ID_EMAC);
+
+	/*
+	 * Disable pull-up on:
+	 *	RXDV (PC25) => PHY normal mode (not Test mode)
+	 * 	ERX0 (PE25) => PHY ADDR0
+	 *	ERX1 (PE26) => PHY ADDR1 => PHYADDR = 0x0
+	 *
+	 * PHY has internal pull-down
+	 */
+	writel(pin_to_mask(AT91_PIN_PC25),
+	       pin_to_controller(AT91_PIN_PC0) + PIO_PUDR);
+	writel(pin_to_mask(AT91_PIN_PE25) |
+	       pin_to_mask(AT91_PIN_PE26),
+	       pin_to_controller(AT91_PIN_PE0) + PIO_PUDR);
+
+	/* Need to reset PHY -> 500ms reset */
+	at91_sys_write(AT91_RSTC_MR, AT91_RSTC_KEY |
+				     (AT91_RSTC_ERSTL & (0x0D << 8)) |
+				     AT91_RSTC_URSTEN);
+
+	at91_sys_write(AT91_RSTC_CR, AT91_RSTC_KEY | AT91_RSTC_EXTRST);
+
+	/* Wait for end hardware reset */
+	while (!(at91_sys_read(AT91_RSTC_SR) & AT91_RSTC_NRSTL));
+
+	/* Restore NRST value */
+	at91_sys_write(AT91_RSTC_MR, AT91_RSTC_KEY |
+				     (AT91_RSTC_ERSTL & (0x0 << 8)) |
+				     AT91_RSTC_URSTEN);
+
+	/* Re-enable pull-up */
+	writel(pin_to_mask(AT91_PIN_PC25),
+	       pin_to_controller(AT91_PIN_PC0) + PIO_PUER);
+	writel(pin_to_mask(AT91_PIN_PE25) |
+	       pin_to_mask(AT91_PIN_PE26),
+	       pin_to_controller(AT91_PIN_PE0) + PIO_PUER);
+
+	at91_set_A_periph(AT91_PIN_PE21, 0);	/* ETXCK_EREFCK */
+	at91_set_B_periph(AT91_PIN_PC25, 0);	/* ERXDV */
+	at91_set_A_periph(AT91_PIN_PE25, 0);	/* ERX0 */
+	at91_set_A_periph(AT91_PIN_PE26, 0);	/* ERX1 */
+	at91_set_A_periph(AT91_PIN_PE27, 0);	/* ERXER */
+	at91_set_A_periph(AT91_PIN_PE28, 0);	/* ETXEN */
+	at91_set_A_periph(AT91_PIN_PE23, 0);	/* ETX0 */
+	at91_set_A_periph(AT91_PIN_PE24, 0);	/* ETX1 */
+	at91_set_A_periph(AT91_PIN_PE30, 0);	/* EMDIO */
+	at91_set_A_periph(AT91_PIN_PE29, 0);	/* EMDC */
+
+#ifndef CONFIG_RMII
+	at91_set_A_periph(AT91_PIN_PE22, 0);	/* ECRS */
+	at91_set_B_periph(AT91_PIN_PC26, 0);	/* ECOL */
+	at91_set_B_periph(AT91_PIN_PC22, 0);	/* ERX2 */
+	at91_set_B_periph(AT91_PIN_PC23, 0);	/* ERX3 */
+	at91_set_B_periph(AT91_PIN_PC27, 0);	/* ERXCK */
+	at91_set_B_periph(AT91_PIN_PC20, 0);	/* ETX2 */
+	at91_set_B_periph(AT91_PIN_PC21, 0);	/* ETX3 */
+	at91_set_B_periph(AT91_PIN_PC24, 0);	/* ETXER */
+#endif
+
+}
+#endif
+
+
+int board_init(void)
+{
+	/* Enable Ctrlc */
+	console_init_f();
+
+	/* arch number of wr_mch-Board */
+	gd->bd->bi_arch_number = MACH_TYPE_WHITERABBIT_MCH;
+	/* adress of boot parameters */
+	gd->bd->bi_boot_params = PHYS_SDRAM + 0x100;
+
+	wr_mch_serial_hw_init();
+#ifdef CONFIG_CMD_NAND
+	wr_mch_nand_hw_init();
+#endif
+#ifdef CONFIG_HAS_DATAFLASH
+	wr_mch_spi_hw_init();
+#endif
+#ifdef CONFIG_MACB
+	wr_mch_macb_hw_init();
+#endif
+	return 0;
+}
+
+int dram_init(void)
+{
+	gd->bd->bi_dram[0].start = PHYS_SDRAM;
+	gd->bd->bi_dram[0].size = PHYS_SDRAM_SIZE;
+	return 0;
+}
+
+#ifdef CONFIG_RESET_PHY_R
+void reset_phy(void)
+{
+#ifdef CONFIG_MACB
+	/*
+	 * Initialize ethernet HW addr prior to starting Linux,
+	 * needed for nfsroot
+	 */
+	eth_init(gd->bd);
+#endif
+}
+#endif
diff -N -r -up ./u-boot-1.3.4.orig/build.sh ./u-boot-1.3.4/build.sh
--- ./u-boot-1.3.4.orig/build.sh	1970-01-01 01:00:00.000000000 +0100
+++ ./u-boot-1.3.4/build.sh	2010-01-14 15:52:47.000000000 +0100
@@ -0,0 +1,10 @@
+#!/bin/sh
+
+. ../build.settings
+
+#make distclean
+#make whiterabbit_mch
+ #at91sam9263ek_dataflash_cs0_config
+make CROSS_COMPILE=$CC_PATH/$CC_PREFIX $1
+
+cp u-boot.bin ../bin
diff -N -r -up ./u-boot-1.3.4.orig/common/main.c ./u-boot-1.3.4/common/main.c
--- ./u-boot-1.3.4.orig/common/main.c	2008-08-12 16:08:38.000000000 +0200
+++ ./u-boot-1.3.4/common/main.c	2010-01-14 16:09:33.000000000 +0100
@@ -47,8 +47,8 @@ DECLARE_GLOBAL_DATA_PTR;
 /*
  * Board-specific Platform code can reimplement show_boot_progress () if needed
  */
-void inline __show_boot_progress (int val) {}
-void inline show_boot_progress (int val) __attribute__((weak, alias("__show_boot_progress")));
+void __show_boot_progress (int val) {}
+void show_boot_progress (int val) __attribute__((weak, alias("__show_boot_progress")));
 
 #if defined(CONFIG_BOOT_RETRY_TIME) && defined(CONFIG_RESET_TO_RETRY)
 extern int do_reset (cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]);		/* for do_reset() prototype */
diff -N -r -up ./u-boot-1.3.4.orig/doc/README.at91 ./u-boot-1.3.4/doc/README.at91
--- ./u-boot-1.3.4.orig/doc/README.at91	1970-01-01 01:00:00.000000000 +0100
+++ ./u-boot-1.3.4/doc/README.at91	2009-06-01 18:05:21.000000000 +0200
@@ -0,0 +1,88 @@
+Atmel AT91 Evaluation kits
+
+http://atmel.com/dyn/products/tools.asp?family_id=605#1443
+
+------------------------------------------------------------------------------
+AT91SAM9260EK
+------------------------------------------------------------------------------
+
+Memory map
+	0x20000000 - 23FFFFFF	SDRAM (64 MB)
+	0xC0000000 - Cxxxxxxx	Atmel Dataflash card (J13)
+	0xD0000000 - Dxxxxxxx	Soldered Atmel Dataflash 
+
+Environment variables
+
+	U-Boot environment variables can be stored at different places:
+		- Dataflash on SPI chip select 1 (default)
+		- Dataflash on SPI chip select 0 (dataflash card)
+		- Nand flash.
+
+	You can choose your storage location at config step (here for at91sam9260ek) :
+		make at91sam9260ek_config		- use data flash (spi cs1) (default)
+	  	make at91sam9260ek_nandflash_config	- use nand flash 
+  		make at91sam9260ek_dataflash_cs0_config	- use data flash (spi cs0)
+	  	make at91sam9260ek_dataflash_cs1_config	- use data flash (spi cs1)
+
+
+------------------------------------------------------------------------------
+AT91SAM9261EK
+------------------------------------------------------------------------------
+
+Memory map
+	0x20000000 - 23FFFFFF	SDRAM (64 MB)
+	0xC0000000 - Cxxxxxxx	Soldered Atmel Dataflash 
+	0xD0000000 - Dxxxxxxx	Atmel Dataflash card (J22)
+
+Environment variables
+
+	U-Boot environment variables can be stored at different places:
+		- Dataflash on SPI chip select 0 (default)
+		- Dataflash on SPI chip select 3 (dataflash card)
+		- Nand flash.
+
+	You can choose your storage location at config step (here for at91sam9260ek) :
+		make at91sam9261ek_config		- use data flash (spi cs0) (default)
+	  	make at91sam9261ek_nandflash_config	- use nand flash 
+  		make at91sam9261ek_dataflash_cs0_config	- use data flash (spi cs0)
+	  	make at91sam9261ek_dataflash_cs3_config	- use data flash (spi cs3)
+
+
+------------------------------------------------------------------------------
+AT91SAM9263EK
+------------------------------------------------------------------------------
+
+Memory map
+	0x20000000 - 23FFFFFF	SDRAM (64 MB)
+	0xC0000000 - Cxxxxxxx	Atmel Dataflash card (J9)
+
+Environment variables
+
+	U-Boot environment variables can be stored at different places:
+		- Dataflash on SPI chip select 0 (dataflash card)
+		- Nand flash.
+
+	You can choose your storage location at config step (here for at91sam9260ek) :
+		make at91sam9263ek_config		- use data flash (spi cs0) (default)
+	  	make at91sam9263ek_nandflash_config	- use nand flash 
+	  	make at91sam9263ek_dataflash_cs0_config	- use data flash (spi cs0)
+
+
+------------------------------------------------------------------------------
+AT91SAM9RLEK
+------------------------------------------------------------------------------
+
+Memory map
+	0x20000000 - 23FFFFFF	SDRAM (64 MB)
+	0xC0000000 - Cxxxxxxx	Soldered Atmel Dataflash
+
+Environment variables
+
+	U-Boot environment variables can be stored at different places:
+		- Dataflash on SPI chip select 0
+		- Nand flash.
+
+	You can choose your storage location at config step (here for at91sam9260ek) :
+		make at91sam9263ek_config		- use data flash (spi cs0) (default)
+	  	make at91sam9263ek_nandflash_config	- use nand flash 
+	  	make at91sam9263ek_dataflash_cs0_config	- use data flash (spi cs0)
diff -N -r -up ./u-boot-1.3.4.orig/drivers/net/macb.c ./u-boot-1.3.4/drivers/net/macb.c
--- ./u-boot-1.3.4.orig/drivers/net/macb.c	2008-08-12 16:08:38.000000000 +0200
+++ ./u-boot-1.3.4/drivers/net/macb.c	2009-06-01 18:05:21.000000000 +0200
@@ -414,18 +414,16 @@ static int macb_init(struct eth_device *
 
 	/* choose RMII or MII mode. This depends on the board */
 #ifdef CONFIG_RMII
-#if defined(CONFIG_AT91CAP9) || defined(CONFIG_AT91SAM9260) || \
-    defined(CONFIG_AT91SAM9263)
-	macb_writel(macb, USRIO, MACB_BIT(RMII) | MACB_BIT(CLKEN));
-#else
+#if defined(CONFIG_AVR32)
 	macb_writel(macb, USRIO, 0);
-#endif
 #else
-#if defined(CONFIG_AT91CAP9) || defined(CONFIG_AT91SAM9260) || \
-    defined(CONFIG_AT91SAM9263)
-	macb_writel(macb, USRIO, MACB_BIT(CLKEN));
+	macb_writel(macb, USRIO, MACB_BIT(RMII) | MACB_BIT(CLKEN));
+#endif
 #else
+#if defined(CONFIG_AVR32)
 	macb_writel(macb, USRIO, MACB_BIT(MII));
+#else
+	macb_writel(macb, USRIO, MACB_BIT(CLKEN));
 #endif
 #endif /* CONFIG_RMII */
 
diff -N -r -up ./u-boot-1.3.4.orig/include/asm-arm/arch-at91sam9/hardware.h ./u-boot-1.3.4/include/asm-arm/arch-at91sam9/hardware.h
--- ./u-boot-1.3.4.orig/include/asm-arm/arch-at91sam9/hardware.h	2008-08-12 16:08:38.000000000 +0200
+++ ./u-boot-1.3.4/include/asm-arm/arch-at91sam9/hardware.h	2009-06-01 18:05:21.000000000 +0200
@@ -18,7 +18,7 @@
 
 #if defined(CONFIG_AT91RM9200)
 #include <asm/arch/at91rm9200.h>
-#elif defined(CONFIG_AT91SAM9260)
+#elif defined(CONFIG_AT91SAM9260) || defined(CONFIG_AT91SAM9G20)
 #include <asm/arch/at91sam9260.h>
 #define AT91_BASE_EMAC	AT91SAM9260_BASE_EMAC
 #define AT91_BASE_SPI	AT91SAM9260_BASE_SPI0
diff -N -r -up ./u-boot-1.3.4.orig/include/asm-arm/mach-types.h ./u-boot-1.3.4/include/asm-arm/mach-types.h
--- ./u-boot-1.3.4.orig/include/asm-arm/mach-types.h	2008-08-12 16:08:38.000000000 +0200
+++ ./u-boot-1.3.4/include/asm-arm/mach-types.h	2009-07-09 05:19:23.000000000 +0200
@@ -377,12 +377,13 @@ extern unsigned int __machine_arch_type;
 #define MACH_TYPE_SE4000               364
 #define MACH_TYPE_QUADRICEPS           365
 #define MACH_TYPE_BRONCO               366
+#define MACH_TYPE_ESL_WIRELESS_TAB     367
 #define MACH_TYPE_ESL_SOFCOMP          368
 #define MACH_TYPE_S5C7375              369
 #define MACH_TYPE_SPEARHEAD            370
 #define MACH_TYPE_PANTERA              371
 #define MACH_TYPE_PRAYOGLITE           372
-#define MACH_TYPE_GUMSTIK              373
+#define MACH_TYPE_GUMSTIX              373
 #define MACH_TYPE_RCUBE                374
 #define MACH_TYPE_REA_OLV              375
 #define MACH_TYPE_PXA_IPHONE           376
@@ -555,7 +556,6 @@ extern unsigned int __machine_arch_type;
 #define MACH_TYPE_BOXER                544
 #define MACH_TYPE_SHEPHERD             545
 #define MACH_TYPE_AML42800AA           546
-#define MACH_TYPE_MACH_TYPE_ML674001   547
 #define MACH_TYPE_LPC2294              548
 #define MACH_TYPE_SWITCHGRASS          549
 #define MACH_TYPE_ENS_CMU              550
@@ -743,7 +743,6 @@ extern unsigned int __machine_arch_type;
 #define MACH_TYPE_ITE8152              735
 #define MACH_TYPE_LPC3XXX              736
 #define MACH_TYPE_PUPPETEER            737
-#define MACH_TYPE_MACH_VADATECH        738
 #define MACH_TYPE_E570                 739
 #define MACH_TYPE_X50                  740
 #define MACH_TYPE_RECON                741
@@ -834,13 +833,13 @@ extern unsigned int __machine_arch_type;
 #define MACH_TYPE_OMAP_GSAMPLE         826
 #define MACH_TYPE_REALVIEW_EB          827
 #define MACH_TYPE_SAMOA                828
-#define MACH_TYPE_T3XSCALE             829
+#define MACH_TYPE_PALMT3               829
 #define MACH_TYPE_I878                 830
 #define MACH_TYPE_BORZOI               831
 #define MACH_TYPE_GECKO                832
 #define MACH_TYPE_DS101                833
 #define MACH_TYPE_OMAP_PALMTT2         834
-#define MACH_TYPE_XSCALE_PALMLD        835
+#define MACH_TYPE_PALMLD               835
 #define MACH_TYPE_CC9C                 836
 #define MACH_TYPE_SBC1670              837
 #define MACH_TYPE_IXDP28X5             838
@@ -849,7 +848,7 @@ extern unsigned int __machine_arch_type;
 #define MACH_TYPE_ARCOM_ZEUS           841
 #define MACH_TYPE_OSIRIS               842
 #define MACH_TYPE_MAESTRO              843
-#define MACH_TYPE_TUNGE2               844
+#define MACH_TYPE_PALMTE2              844
 #define MACH_TYPE_IXBBM                845
 #define MACH_TYPE_MX27ADS              846
 #define MACH_TYPE_AX8004               847
@@ -890,7 +889,7 @@ extern unsigned int __machine_arch_type;
 #define MACH_TYPE_OMI_BOARD            882
 #define MACH_TYPE_MX21CIV              883
 #define MACH_TYPE_MAHI_CDAC            884
-#define MACH_TYPE_XSCALE_PALMTX        885
+#define MACH_TYPE_PALMTX               885
 #define MACH_TYPE_S3C2413              887
 #define MACH_TYPE_SAMSYS_EP0           888
 #define MACH_TYPE_WG302V1              889
@@ -913,7 +912,7 @@ extern unsigned int __machine_arch_type;
 #define MACH_TYPE_APF9328              906
 #define MACH_TYPE_OMAP_WIPOQ           907
 #define MACH_TYPE_OMAP_TWIP            908
-#define MACH_TYPE_XSCALE_PALMTREO650   909
+#define MACH_TYPE_TREO650              909
 #define MACH_TYPE_ACUMEN               910
 #define MACH_TYPE_XP100                911
 #define MACH_TYPE_FS2410               912
@@ -921,8 +920,8 @@ extern unsigned int __machine_arch_type;
 #define MACH_TYPE_SQ2FTLPALM           914
 #define MACH_TYPE_BSEMSERVER           915
 #define MACH_TYPE_NETCLIENT            916
-#define MACH_TYPE_XSCALE_PALMTT5       917
-#define MACH_TYPE_OMAP_PALMTC          918
+#define MACH_TYPE_PALMT5               917
+#define MACH_TYPE_PALMTC               918
 #define MACH_TYPE_OMAP_APOLLON         919
 #define MACH_TYPE_MXC30030EVB          920
 #define MACH_TYPE_REA_2D               921
@@ -1093,7 +1092,7 @@ extern unsigned int __machine_arch_type;
 #define MACH_TYPE_MULTMDW              1087
 #define MACH_TYPE_MBA2440              1088
 #define MACH_TYPE_ECSD                 1089
-#define MACH_TYPE_ZIRE31               1090
+#define MACH_TYPE_PALMZ31              1090
 #define MACH_TYPE_FSG                  1091
 #define MACH_TYPE_RAZOR101             1092
 #define MACH_TYPE_OPERA_TDM            1093
@@ -1215,7 +1214,6 @@ extern unsigned int __machine_arch_type;
 #define MACH_TYPE_EM7210               1212
 #define MACH_TYPE_HTCHERMES            1213
 #define MACH_TYPE_ETI_C1               1214
-#define MACH_TYPE_MACH_DEP2410         1215
 #define MACH_TYPE_AC100                1216
 #define MACH_TYPE_SNEETCH              1217
 #define MACH_TYPE_STUDENTMATE          1218
@@ -1230,7 +1228,7 @@ extern unsigned int __machine_arch_type;
 #define MACH_TYPE_VPAC270              1227
 #define MACH_TYPE_RD129                1228
 #define MACH_TYPE_HTCWIZARD            1229
-#define MACH_TYPE_XSCALE_TREO680       1230
+#define MACH_TYPE_TREO680              1230
 #define MACH_TYPE_TECON_TMEZON         1231
 #define MACH_TYPE_ZYLONITE             1233
 #define MACH_TYPE_GENE1270             1234
@@ -1378,7 +1376,7 @@ extern unsigned int __machine_arch_type;
 #define MACH_TYPE_OLIP8                1378
 #define MACH_TYPE_GHI270HG             1379
 #define MACH_TYPE_DAVINCI_DM6467_EVM   1380
-#define MACH_TYPE_DAVINCI_DM350_EVM    1381
+#define MACH_TYPE_DAVINCI_DM355_EVM    1381
 #define MACH_TYPE_BLACKRIVER           1383
 #define MACH_TYPE_SANDGATEWP           1384
 #define MACH_TYPE_CDOTBWSG             1385
@@ -1416,10 +1414,10 @@ extern unsigned int __machine_arch_type;
 #define MACH_TYPE_CNTY_TITAN           1418
 #define MACH_TYPE_APP3XX               1419
 #define MACH_TYPE_SIDEOATSGRAMA        1420
-#define MACH_TYPE_XSCALE_PALMT700P     1421
-#define MACH_TYPE_XSCALE_PALMT700W     1422
-#define MACH_TYPE_XSCALE_PALMT750      1423
-#define MACH_TYPE_XSCALE_PALMT755P     1424
+#define MACH_TYPE_TREO700P             1421
+#define MACH_TYPE_TREO700W             1422
+#define MACH_TYPE_TREO750              1423
+#define MACH_TYPE_TREO755P             1424
 #define MACH_TYPE_EZREGANUT9200        1425
 #define MACH_TYPE_SARGE                1426
 #define MACH_TYPE_A696                 1427
@@ -1458,7 +1456,7 @@ extern unsigned int __machine_arch_type;
 #define MACH_TYPE_HTCTITAN             1463
 #define MACH_TYPE_QRANIUM              1464
 #define MACH_TYPE_ADX_WSC2             1465
-#define MACH_TYPE_ADX_MEDINET          1466
+#define MACH_TYPE_ADX_MEDCOM           1466
 #define MACH_TYPE_BBOARD               1467
 #define MACH_TYPE_CAMBRIA              1468
 #define MACH_TYPE_MT7XXX               1469
@@ -1514,7 +1512,7 @@ extern unsigned int __machine_arch_type;
 #define MACH_TYPE_CORSICA              1519
 #define MACH_TYPE_BIGEYE               1520
 #define MACH_TYPE_TLL5000              1522
-#define MACH_TYPE_HNI_X270             1523
+#define MACH_TYPE_BEBOT                1523
 #define MACH_TYPE_QONG                 1524
 #define MACH_TYPE_TCOMPACT             1525
 #define MACH_TYPE_PUMA5                1526
@@ -1595,7 +1593,715 @@ extern unsigned int __machine_arch_type;
 #define MACH_TYPE_P300                 1602
 #define MACH_TYPE_XDACOMET             1603
 #define MACH_TYPE_DEXFLEX2             1604
+#define MACH_TYPE_OW                   1605
+#define MACH_TYPE_ARMEBS3              1606
+#define MACH_TYPE_U3                   1607
+#define MACH_TYPE_SMDK2450             1608
+#define MACH_TYPE_RSI_EWS              1609
+#define MACH_TYPE_TNB                  1610
+#define MACH_TYPE_TOEPATH              1611
+#define MACH_TYPE_KB9263               1612
+#define MACH_TYPE_MT7108               1613
+#define MACH_TYPE_SMTR2440             1614
+#define MACH_TYPE_MANAO                1615
+#define MACH_TYPE_CM_X300              1616
+#define MACH_TYPE_GULFSTREAM_KP        1617
+#define MACH_TYPE_LANREADYFN522        1618
+#define MACH_TYPE_ARMA37               1619
+#define MACH_TYPE_MENDEL               1620
+#define MACH_TYPE_PELCO_ILIAD          1621
+#define MACH_TYPE_UNIT2P               1622
+#define MACH_TYPE_INC20OTTER           1623
+#define MACH_TYPE_AT91SAM9G20EK        1624
+#define MACH_TYPE_STORCENTER           1625
+#define MACH_TYPE_SMDK6410             1626
+#define MACH_TYPE_U300                 1627
+#define MACH_TYPE_U500                 1628
+#define MACH_TYPE_DS9260               1629
+#define MACH_TYPE_RIVERROCK            1630
+#define MACH_TYPE_SCIBATH              1631
+#define MACH_TYPE_AT91SAM7SE512EK      1632
+#define MACH_TYPE_WRT350N_V2           1633
+#define MACH_TYPE_MULTIMEDIA           1634
+#define MACH_TYPE_MARVIN               1635
+#define MACH_TYPE_X500                 1636
+#define MACH_TYPE_AWLUG4LCU            1637
+#define MACH_TYPE_PALERMOC             1638
+#define MACH_TYPE_OMAP_LDP             1639
+#define MACH_TYPE_IP500                1640
+#define MACH_TYPE_ASE2                 1642
+#define MACH_TYPE_MX35EVB              1643
+#define MACH_TYPE_AML_M8050            1644
+#define MACH_TYPE_MX35_3DS             1645
+#define MACH_TYPE_MARS                 1646
+#define MACH_TYPE_NTOSD_644XA          1647
+#define MACH_TYPE_BADGER               1648
+#define MACH_TYPE_TRIZEPS4WL           1649
+#define MACH_TYPE_TRIZEPS5             1650
+#define MACH_TYPE_MARLIN               1651
+#define MACH_TYPE_TS78XX               1652
+#define MACH_TYPE_HPIPAQ214            1653
+#define MACH_TYPE_AT572D940DCM         1654
+#define MACH_TYPE_NE1BOARD             1655
+#define MACH_TYPE_ZANTE                1656
 #define MACH_TYPE_SFFSDR               1657
+#define MACH_TYPE_TW2662               1658
+#define MACH_TYPE_VF10XX               1659
+#define MACH_TYPE_ZORAN43XX            1660
+#define MACH_TYPE_SONIX926             1661
+#define MACH_TYPE_CELESTIALSEMI        1662
+#define MACH_TYPE_CC9M2443             1663
+#define MACH_TYPE_TW5334               1664
+#define MACH_TYPE_HTCARTEMIS           1665
+#define MACH_TYPE_NAL_HLITE            1666
+#define MACH_TYPE_HTCVOGUE             1667
+#define MACH_TYPE_SMARTWEB             1668
+#define MACH_TYPE_MV86XX               1669
+#define MACH_TYPE_MV87XX               1670
+#define MACH_TYPE_SONGYOUNGHO          1671
+#define MACH_TYPE_YOUNGHOTEMA          1672
+#define MACH_TYPE_PCM037               1673
+#define MACH_TYPE_MMVP                 1674
+#define MACH_TYPE_MMAP                 1675
+#define MACH_TYPE_PTID2410             1676
+#define MACH_TYPE_JAMES_926            1677
+#define MACH_TYPE_FM6000               1678
+#define MACH_TYPE_DB88F6281_BP         1680
+#define MACH_TYPE_RD88F6192_NAS        1681
+#define MACH_TYPE_RD88F6281            1682
+#define MACH_TYPE_DB78X00_BP           1683
+#define MACH_TYPE_SMDK2416             1685
+#define MACH_TYPE_OCE_SPIDER_SI        1686
+#define MACH_TYPE_OCE_SPIDER_SK        1687
+#define MACH_TYPE_ROVERN6              1688
+#define MACH_TYPE_PELCO_EVOLUTION      1689
+#define MACH_TYPE_WBD111               1690
+#define MACH_TYPE_ELARACPE             1691
+#define MACH_TYPE_MABV3                1692
+#define MACH_TYPE_MV2120               1693
+#define MACH_TYPE_CSB737               1695
+#define MACH_TYPE_MX51_3DS             1696
+#define MACH_TYPE_G900                 1697
+#define MACH_TYPE_APF27                1698
+#define MACH_TYPE_GGUS2000             1699
+#define MACH_TYPE_OMAP_2430_MIMIC      1700
+#define MACH_TYPE_IMX27LITE            1701
+#define MACH_TYPE_ALMEX                1702
+#define MACH_TYPE_CONTROL              1703
+#define MACH_TYPE_MBA2410              1704
+#define MACH_TYPE_VOLCANO              1705
+#define MACH_TYPE_ZENITH               1706
+#define MACH_TYPE_MUCHIP               1707
+#define MACH_TYPE_MAGELLAN             1708
+#define MACH_TYPE_USB_A9260            1709
+#define MACH_TYPE_USB_A9263            1710
+#define MACH_TYPE_QIL_A9260            1711
+#define MACH_TYPE_CME9210              1712
+#define MACH_TYPE_HCZH4                1713
+#define MACH_TYPE_SPEARBASIC           1714
+#define MACH_TYPE_DEP2440              1715
+#define MACH_TYPE_HDL_GXR              1716
+#define MACH_TYPE_HDL_GT               1717
+#define MACH_TYPE_HDL_4G               1718
+#define MACH_TYPE_S3C6000              1719
+#define MACH_TYPE_MMSP2_MDK            1720
+#define MACH_TYPE_MPX220               1721
+#define MACH_TYPE_KZM_ARM11_01         1722
+#define MACH_TYPE_HTC_POLARIS          1723
+#define MACH_TYPE_HTC_KAISER           1724
+#define MACH_TYPE_LG_KS20              1725
+#define MACH_TYPE_HHGPS                1726
+#define MACH_TYPE_NOKIA_N810_WIMAX     1727
+#define MACH_TYPE_INSIGHT              1728
+#define MACH_TYPE_SAPPHIRE             1729
+#define MACH_TYPE_CSB637XO             1730
+#define MACH_TYPE_EVISIONG             1731
+#define MACH_TYPE_STMP37XX             1732
+#define MACH_TYPE_STMP378X             1733
+#define MACH_TYPE_TNT                  1734
+#define MACH_TYPE_TBXT                 1735
+#define MACH_TYPE_PLAYMATE             1736
+#define MACH_TYPE_PNS10                1737
+#define MACH_TYPE_EZNAVI               1738
+#define MACH_TYPE_PS4000               1739
+#define MACH_TYPE_EZX_A780             1740
+#define MACH_TYPE_EZX_E680             1741
+#define MACH_TYPE_EZX_A1200            1742
+#define MACH_TYPE_EZX_E6               1743
+#define MACH_TYPE_EZX_E2               1744
+#define MACH_TYPE_EZX_A910             1745
+#define MACH_TYPE_CWMX31               1746
+#define MACH_TYPE_SL2312               1747
+#define MACH_TYPE_BLENNY               1748
+#define MACH_TYPE_DS107                1749
+#define MACH_TYPE_DSX07                1750
+#define MACH_TYPE_PICOCOM1             1751
+#define MACH_TYPE_LYNX_WOLVERINE       1752
+#define MACH_TYPE_UBISYS_P9_SC19       1753
+#define MACH_TYPE_KRATOS_LOW           1754
+#define MACH_TYPE_M700                 1755
+#define MACH_TYPE_EDMINI_V2            1756
+#define MACH_TYPE_ZIPIT2               1757
+#define MACH_TYPE_HSLFEMTOCELL         1758
+#define MACH_TYPE_DAINTREE_AT91        1759
+#define MACH_TYPE_SG560USB             1760
+#define MACH_TYPE_OMAP3_PANDORA        1761
+#define MACH_TYPE_USR8200              1762
+#define MACH_TYPE_S1S65K               1763
+#define MACH_TYPE_S2S65A               1764
+#define MACH_TYPE_ICORE                1765
+#define MACH_TYPE_MSS2                 1766
+#define MACH_TYPE_BELMONT              1767
+#define MACH_TYPE_ASUSP525             1768
+#define MACH_TYPE_LB88RC8480           1769
+#define MACH_TYPE_HIPXA                1770
+#define MACH_TYPE_MX25_3DS             1771
+#define MACH_TYPE_M800                 1772
+#define MACH_TYPE_OMAP3530_LV_SOM      1773
+#define MACH_TYPE_PRIMA_EVB            1774
+#define MACH_TYPE_MX31BT1              1775
+#define MACH_TYPE_ATLAS4_EVB           1776
+#define MACH_TYPE_MX31CICADA           1777
+#define MACH_TYPE_MI424WR              1778
+#define MACH_TYPE_AXS_ULTRAX           1779
+#define MACH_TYPE_AT572D940DEB         1780
+#define MACH_TYPE_DAVINCI_DA8XX_EVM    1781
+#define MACH_TYPE_EP9302               1782
+#define MACH_TYPE_AT572D940HFEB        1783
+#define MACH_TYPE_CYBOOK3              1784
+#define MACH_TYPE_WDG002               1785
+#define MACH_TYPE_SG560ADSL            1786
+#define MACH_TYPE_NEXTIO_N2800_ICA     1787
+#define MACH_TYPE_MARVELL_NEWDB        1789
+#define MACH_TYPE_VANDIHUD             1790
+#define MACH_TYPE_MAGX_E8              1791
+#define MACH_TYPE_MAGX_Z6              1792
+#define MACH_TYPE_MAGX_V8              1793
+#define MACH_TYPE_MAGX_U9              1794
+#define MACH_TYPE_TOUGHCF08            1795
+#define MACH_TYPE_ZW4400               1796
+#define MACH_TYPE_MARAT91              1797
+#define MACH_TYPE_OVERO                1798
+#define MACH_TYPE_AT2440EVB            1799
+#define MACH_TYPE_NEOCORE926           1800
+#define MACH_TYPE_WNR854T              1801
+#define MACH_TYPE_IMX27                1802
+#define MACH_TYPE_MOOSE_DB             1803
+#define MACH_TYPE_FAB4                 1804
+#define MACH_TYPE_HTCDIAMOND           1805
+#define MACH_TYPE_FIONA                1806
+#define MACH_TYPE_MXC30030_X           1807
+#define MACH_TYPE_BMP1000              1808
+#define MACH_TYPE_LOGI9200             1809
+#define MACH_TYPE_TQMA31               1810
+#define MACH_TYPE_CCW9P9215JS          1811
+#define MACH_TYPE_RD88F5181L_GE        1812
+#define MACH_TYPE_SIFMAIN              1813
+#define MACH_TYPE_SAM9_L9261           1814
+#define MACH_TYPE_CC9M2443JS           1815
+#define MACH_TYPE_XARIA300             1816
+#define MACH_TYPE_IT9200               1817
+#define MACH_TYPE_RD88F5181L_FXO       1818
+#define MACH_TYPE_KRISS_SENSOR         1819
+#define MACH_TYPE_PILZ_PMI5            1820
+#define MACH_TYPE_JADE                 1821
+#define MACH_TYPE_KS8695_SOFTPLC       1822
+#define MACH_TYPE_GPRISC3              1823
+#define MACH_TYPE_STAMP9G20            1824
+#define MACH_TYPE_SMDK6430             1825
+#define MACH_TYPE_SMDKC100             1826
+#define MACH_TYPE_TAVOREVB             1827
+#define MACH_TYPE_SAAR                 1828
+#define MACH_TYPE_DEISTER_EYECAM       1829
+#define MACH_TYPE_AT91SAM9M10G45EK     1830
+#define MACH_TYPE_LINKSTATION_PRODUO   1831
+#define MACH_TYPE_HIT_B0               1832
+#define MACH_TYPE_ADX_RMU              1833
+#define MACH_TYPE_XG_CPE_MAIN          1834
+#define MACH_TYPE_EDB9407A             1835
+#define MACH_TYPE_DTB9608              1836
+#define MACH_TYPE_EM104V1              1837
+#define MACH_TYPE_DEMO                 1838
+#define MACH_TYPE_LOGI9260             1839
+#define MACH_TYPE_MX31_EXM32           1840
+#define MACH_TYPE_USB_A9G20            1841
+#define MACH_TYPE_PICPROJE2008         1842
+#define MACH_TYPE_CS_E9315             1843
+#define MACH_TYPE_QIL_A9G20            1844
+#define MACH_TYPE_SHA_PON020           1845
+#define MACH_TYPE_NAD                  1846
+#define MACH_TYPE_SBC35_A9260          1847
+#define MACH_TYPE_SBC35_A9G20          1848
+#define MACH_TYPE_DAVINCI_BEGINNING    1849
+#define MACH_TYPE_UWC                  1850
+#define MACH_TYPE_MXLADS               1851
+#define MACH_TYPE_HTCNIKE              1852
+#define MACH_TYPE_DEISTER_PXA270       1853
+#define MACH_TYPE_CME9210JS            1854
+#define MACH_TYPE_CC9P9360             1855
+#define MACH_TYPE_MOCHA                1856
+#define MACH_TYPE_WAPD170AG            1857
+#define MACH_TYPE_LINKSTATION_MINI     1858
+#define MACH_TYPE_AFEB9260             1859
+#define MACH_TYPE_W90X900              1860
+#define MACH_TYPE_W90X700              1861
+#define MACH_TYPE_KT300IP              1862
+#define MACH_TYPE_KT300IP_G20          1863
+#define MACH_TYPE_SRCM                 1864
+#define MACH_TYPE_WLNX_9260            1865
+#define MACH_TYPE_OPENMOKO_GTA03       1866
+#define MACH_TYPE_OSPREY2              1867
+#define MACH_TYPE_KBIO9260             1868
+#define MACH_TYPE_GINZA                1869
+#define MACH_TYPE_A636N                1870
+#define MACH_TYPE_IMX27IPCAM           1871
+#define MACH_TYPE_NEMOC                1872
+#define MACH_TYPE_GENEVA               1873
+#define MACH_TYPE_HTCPHAROS            1874
+#define MACH_TYPE_NEONC                1875
+#define MACH_TYPE_NAS7100              1876
+#define MACH_TYPE_TEUPHONE             1877
+#define MACH_TYPE_ANNAX_ETH2           1878
+#define MACH_TYPE_CSB733               1879
+#define MACH_TYPE_BK3                  1880
+#define MACH_TYPE_OMAP_EM32            1881
+#define MACH_TYPE_ET9261CP             1882
+#define MACH_TYPE_JASPERC              1883
+#define MACH_TYPE_ISSI_ARM9            1884
+#define MACH_TYPE_UED                  1885
+#define MACH_TYPE_ESIBLADE             1886
+#define MACH_TYPE_EYE02                1887
+#define MACH_TYPE_IMX27KBD             1888
+#define MACH_TYPE_SST61VC010_FPGA      1889
+#define MACH_TYPE_KIXVP435             1890
+#define MACH_TYPE_KIXNP435             1891
+#define MACH_TYPE_AFRICA               1892
+#define MACH_TYPE_NH233                1893
+#define MACH_TYPE_RD88F6183AP_GE       1894
+#define MACH_TYPE_BCM4760              1895
+#define MACH_TYPE_EDDY_V2              1896
+#define MACH_TYPE_REALVIEW_PBA8        1897
+#define MACH_TYPE_HID_A7               1898
+#define MACH_TYPE_HERO                 1899
+#define MACH_TYPE_OMAP_POSEIDON        1900
+#define MACH_TYPE_REALVIEW_PBX         1901
+#define MACH_TYPE_MICRO9S              1902
+#define MACH_TYPE_MAKO                 1903
+#define MACH_TYPE_XDAFLAME             1904
+#define MACH_TYPE_PHIDGET_SBC2         1905
+#define MACH_TYPE_LIMESTONE            1906
+#define MACH_TYPE_IPROBE_C32           1907
+#define MACH_TYPE_RUT100               1908
+#define MACH_TYPE_ASUSP535             1909
+#define MACH_TYPE_HTCRAPHAEL           1910
+#define MACH_TYPE_SYGDG1               1911
+#define MACH_TYPE_SYGDG2               1912
+#define MACH_TYPE_SEOUL                1913
+#define MACH_TYPE_SALERNO              1914
+#define MACH_TYPE_UCN_S3C64XX          1915
+#define MACH_TYPE_MSM7201A             1916
+#define MACH_TYPE_LPR1                 1917
+#define MACH_TYPE_ARMADILLO500FX       1918
+#define MACH_TYPE_G3EVM                1919
+#define MACH_TYPE_Z3_DM355             1920
+#define MACH_TYPE_W90P910EVB           1921
+#define MACH_TYPE_W90P920EVB           1922
+#define MACH_TYPE_W90P950EVB           1923
+#define MACH_TYPE_W90N960EVB           1924
+#define MACH_TYPE_CAMHD                1925
+#define MACH_TYPE_MVC100               1926
+#define MACH_TYPE_ELECTRUM_200         1927
+#define MACH_TYPE_HTCJADE              1928
+#define MACH_TYPE_MEMPHIS              1929
+#define MACH_TYPE_IMX27SBC             1930
+#define MACH_TYPE_LEXTAR               1931
+#define MACH_TYPE_MV88F6281GTW_GE      1932
+#define MACH_TYPE_NCP                  1933
+#define MACH_TYPE_Z32AN                1934
+#define MACH_TYPE_TMQ_CAPD             1935
+#define MACH_TYPE_OMAP3_WL             1936
+#define MACH_TYPE_CHUMBY               1937
+#define MACH_TYPE_ATSARM9              1938
+#define MACH_TYPE_DAVINCI_DM365_EVM    1939
+#define MACH_TYPE_BAHAMAS              1940
+#define MACH_TYPE_DAS                  1941
+#define MACH_TYPE_MINIDAS              1942
+#define MACH_TYPE_VK1000               1943
+#define MACH_TYPE_CENTRO               1944
+#define MACH_TYPE_CTERA_2BAY           1945
+#define MACH_TYPE_EDGECONNECT          1946
+#define MACH_TYPE_ND27000              1947
+#define MACH_TYPE_GEMALTO_COBRA        1948
+#define MACH_TYPE_INGELABS_COMET       1949
+#define MACH_TYPE_POLLUX_WIZ           1950
+#define MACH_TYPE_BLACKSTONE           1951
+#define MACH_TYPE_TOPAZ                1952
+#define MACH_TYPE_AIXLE                1953
+#define MACH_TYPE_MW998                1954
+#define MACH_TYPE_NOKIA_RX51           1955
+#define MACH_TYPE_VSC5605EV            1956
+#define MACH_TYPE_NT98700DK            1957
+#define MACH_TYPE_ICONTACT             1958
+#define MACH_TYPE_SWARCO_FRCPU         1959
+#define MACH_TYPE_SWARCO_SCPU          1960
+#define MACH_TYPE_BBOX_P16             1961
+#define MACH_TYPE_BSTD                 1962
+#define MACH_TYPE_SBC2440II            1963
+#define MACH_TYPE_PCM034               1964
+#define MACH_TYPE_NESO                 1965
+#define MACH_TYPE_WLNX_9G20            1966
+#define MACH_TYPE_OMAP_ZOOM2           1967
+#define MACH_TYPE_TOTEMNOVA            1968
+#define MACH_TYPE_C5000                1969
+#define MACH_TYPE_UNIPO_AT91SAM9263    1970
+#define MACH_TYPE_ETHERNUT5            1971
+#define MACH_TYPE_ARM11                1972
+#define MACH_TYPE_CPUAT9260            1973
+#define MACH_TYPE_CPUPXA255            1974
+#define MACH_TYPE_CPUIMX27             1975
+#define MACH_TYPE_CHEFLUX              1976
+#define MACH_TYPE_EB_CPUX9K2           1977
+#define MACH_TYPE_OPCOTEC              1978
+#define MACH_TYPE_YT                   1979
+#define MACH_TYPE_MOTOQ                1980
+#define MACH_TYPE_BSB1                 1981
+#define MACH_TYPE_ACS5K                1982
+#define MACH_TYPE_MILAN                1983
+#define MACH_TYPE_QUARTZV2             1984
+#define MACH_TYPE_RSVP                 1985
+#define MACH_TYPE_RMP200               1986
+#define MACH_TYPE_SNAPPER_9260         1987
+#define MACH_TYPE_DSM320               1988
+#define MACH_TYPE_ADSGCM               1989
+#define MACH_TYPE_ASE2_400             1990
+#define MACH_TYPE_PIZZA                1991
+#define MACH_TYPE_SPOT_NGPL            1992
+#define MACH_TYPE_ARMATA               1993
+#define MACH_TYPE_EXEDA                1994
+#define MACH_TYPE_MX31SF005            1995
+#define MACH_TYPE_F5D8231_4_V2         1996
+#define MACH_TYPE_Q2440                1997
+#define MACH_TYPE_QQ2440               1998
+#define MACH_TYPE_MINI2440             1999
+#define MACH_TYPE_COLIBRI300           2000
+#define MACH_TYPE_JADES                2001
+#define MACH_TYPE_SPARK                2002
+#define MACH_TYPE_BENZINA              2003
+#define MACH_TYPE_BLAZE                2004
+#define MACH_TYPE_LINKSTATION_LS_HGL   2005
+#define MACH_TYPE_HTCVENUS             2006
+#define MACH_TYPE_SONY_PRS505          2007
+#define MACH_TYPE_HANLIN_V3            2008
+#define MACH_TYPE_SAPPHIRA             2009
+#define MACH_TYPE_DACK_SDA_01          2010
+#define MACH_TYPE_ARMBOX               2011
+#define MACH_TYPE_HARRIS_RVP           2012
+#define MACH_TYPE_RIBALDO              2013
+#define MACH_TYPE_AGORA                2014
+#define MACH_TYPE_OMAP3_MINI           2015
+#define MACH_TYPE_A9SAM6432_B          2016
+#define MACH_TYPE_USG2410              2017
+#define MACH_TYPE_PC72052_I10_REVB     2018
+#define MACH_TYPE_MX35_EXM32           2019
+#define MACH_TYPE_TOPAS910             2020
+#define MACH_TYPE_HYENA                2021
+#define MACH_TYPE_POSPAX               2022
+#define MACH_TYPE_HDL_GX               2023
+#define MACH_TYPE_CTERA_4BAY           2024
+#define MACH_TYPE_CTERA_PLUG_C         2025
+#define MACH_TYPE_CRWEA_PLUG_I         2026
+#define MACH_TYPE_EGAUGE2              2027
+#define MACH_TYPE_DIDJ                 2028
+#define MACH_TYPE_MEISTER              2029
+#define MACH_TYPE_HTCBLACKSTONE        2030
+#define MACH_TYPE_CPUAT9G20            2031
+#define MACH_TYPE_SMDK6440             2032
+#define MACH_TYPE_OMAP_35XX_MVP        2033
+#define MACH_TYPE_CTERA_PLUG_I         2034
+#define MACH_TYPE_PVG610               2035
+#define MACH_TYPE_HPRW6815             2036
+#define MACH_TYPE_OMAP3_OSWALD         2037
+#define MACH_TYPE_NAS4220B             2038
+#define MACH_TYPE_HTCRAPHAEL_CDMA      2039
+#define MACH_TYPE_HTCDIAMOND_CDMA      2040
+#define MACH_TYPE_SCALER               2041
+#define MACH_TYPE_ZYLONITE2            2042
+#define MACH_TYPE_ASPENITE             2043
+#define MACH_TYPE_TETON                2044
+#define MACH_TYPE_TTC_DKB              2045
+#define MACH_TYPE_BISHOP2              2046
+#define MACH_TYPE_IPPV5                2047
+#define MACH_TYPE_FARM926              2048
+#define MACH_TYPE_MMCCPU               2049
+#define MACH_TYPE_SGMSFL               2050
+#define MACH_TYPE_TT8000               2051
+#define MACH_TYPE_ZRN4300LP            2052
+#define MACH_TYPE_MPTC                 2053
+#define MACH_TYPE_H6051                2054
+#define MACH_TYPE_PVG610_101           2055
+#define MACH_TYPE_STAMP9261_PC_EVB     2056
+#define MACH_TYPE_PELCO_ODYSSEUS       2057
+#define MACH_TYPE_TNY_A9260            2058
+#define MACH_TYPE_TNY_A9G20            2059
+#define MACH_TYPE_AESOP_MP2530F        2060
+#define MACH_TYPE_DX900                2061
+#define MACH_TYPE_CPODC2               2062
+#define MACH_TYPE_TILT_8925            2063
+#define MACH_TYPE_DAVINCI_DM357_EVM    2064
+#define MACH_TYPE_SWORDFISH            2065
+#define MACH_TYPE_CORVUS               2066
+#define MACH_TYPE_TAURUS               2067
+#define MACH_TYPE_AXM                  2068
+#define MACH_TYPE_AXC                  2069
+#define MACH_TYPE_BABY                 2070
+#define MACH_TYPE_MP200                2071
+#define MACH_TYPE_PCM043               2072
+#define MACH_TYPE_HANLIN_V3C           2073
+#define MACH_TYPE_KBK9G20              2074
+#define MACH_TYPE_ADSTURBOG5           2075
+#define MACH_TYPE_AVENGER_LITE1        2076
+#define MACH_TYPE_SUC                  2077
+#define MACH_TYPE_AT91SAM7S256         2078
+#define MACH_TYPE_MENDOZA              2079
+#define MACH_TYPE_KIRA                 2080
+#define MACH_TYPE_MX1HBM               2081
+#define MACH_TYPE_QUATRO43XX           2082
+#define MACH_TYPE_QUATRO4230           2083
+#define MACH_TYPE_NSB400               2084
+#define MACH_TYPE_DRP255               2085
+#define MACH_TYPE_THOTH                2086
+#define MACH_TYPE_FIRESTONE            2087
+#define MACH_TYPE_ASUSP750             2088
+#define MACH_TYPE_CTERA_DL             2089
+#define MACH_TYPE_SOCR                 2090
+#define MACH_TYPE_HTCOXYGEN            2091
+#define MACH_TYPE_HEROC                2092
+#define MACH_TYPE_ZENO6800             2093
+#define MACH_TYPE_SC2MCS               2094
+#define MACH_TYPE_GENE100              2095
+#define MACH_TYPE_AS353X               2096
+#define MACH_TYPE_SHEEVAPLUG           2097
+#define MACH_TYPE_AT91SAM9G20          2098
+#define MACH_TYPE_MV88F6192GTW_FE      2099
+#define MACH_TYPE_CC9200               2100
+#define MACH_TYPE_SM9200               2101
+#define MACH_TYPE_TP9200               2102
+#define MACH_TYPE_SNAPPERDV            2103
+#define MACH_TYPE_AVENGERS_LITE        2104
+#define MACH_TYPE_AVENGERS_LITE1       2105
+#define MACH_TYPE_OMAP3AXON            2106
+#define MACH_TYPE_MA8XX                2107
+#define MACH_TYPE_MP201EK              2108
+#define MACH_TYPE_DAVINCI_TUX          2109
+#define MACH_TYPE_MPA1600              2110
+#define MACH_TYPE_PELCO_TROY           2111
+#define MACH_TYPE_NSB667               2112
+#define MACH_TYPE_ROVERS5_4MPIX        2113
+#define MACH_TYPE_TWOCOM               2114
+#define MACH_TYPE_UBISYS_P9_RCU3R2     2115
+#define MACH_TYPE_HERO_ESPRESSO        2116
+#define MACH_TYPE_AFEUSB               2117
+#define MACH_TYPE_T830                 2118
+#define MACH_TYPE_SPD8020_CC           2119
+#define MACH_TYPE_OM_3D7K              2120
+#define MACH_TYPE_PICOCOM2             2121
+#define MACH_TYPE_UWG4MX27             2122
+#define MACH_TYPE_UWG4MX31             2123
+#define MACH_TYPE_CHERRY               2124
+#define MACH_TYPE_MX51_BABBAGE         2125
+#define MACH_TYPE_S3C2440TURKIYE       2126
+#define MACH_TYPE_TX37                 2127
+#define MACH_TYPE_SBC2800_9G20         2128
+#define MACH_TYPE_BENZGLB              2129
+#define MACH_TYPE_BENZTD               2130
+#define MACH_TYPE_CARTESIO_PLUS        2131
+#define MACH_TYPE_SOLRAD_G20           2132
+#define MACH_TYPE_MX27WALLACE          2133
+#define MACH_TYPE_FMZWEBMODUL          2134
+#define MACH_TYPE_RD78X00_MASA         2135
+#define MACH_TYPE_SMALLOGGER           2136
+#define MACH_TYPE_CCW9P9215            2137
+#define MACH_TYPE_DM355_LEOPARD        2138
+#define MACH_TYPE_TS219                2139
+#define MACH_TYPE_TNY_A9263            2140
+#define MACH_TYPE_APOLLO               2141
+#define MACH_TYPE_AT91CAP9STK          2142
+#define MACH_TYPE_SPC300               2143
+#define MACH_TYPE_EKO                  2144
+#define MACH_TYPE_CCW9M2443            2145
+#define MACH_TYPE_CCW9M2443JS          2146
+#define MACH_TYPE_M2M_ROUTER_DEVICE    2147
+#define MACH_TYPE_STAR9104NAS          2148
+#define MACH_TYPE_PCA100               2149
+#define MACH_TYPE_Z3_DM365_MOD_01      2150
+#define MACH_TYPE_HIPOX                2151
+#define MACH_TYPE_OMAP3_PITEDS         2152
+#define MACH_TYPE_BM150R               2153
+#define MACH_TYPE_TBONE                2154
+#define MACH_TYPE_MERLIN               2155
+#define MACH_TYPE_FALCON               2156
+#define MACH_TYPE_DAVINCI_DA850_EVM    2157
+#define MACH_TYPE_S5P6440              2158
+#define MACH_TYPE_AT91SAM9G10EK        2159
+#define MACH_TYPE_OMAP_4430SDP         2160
+#define MACH_TYPE_LPC313X              2161
+#define MACH_TYPE_MAGX_ZN5             2162
+#define MACH_TYPE_MAGX_EM30            2163
+#define MACH_TYPE_MAGX_VE66            2164
+#define MACH_TYPE_MEESC                2165
+#define MACH_TYPE_OTC570               2166
+#define MACH_TYPE_BCU2412              2167
+#define MACH_TYPE_BEACON               2168
+#define MACH_TYPE_ACTIA_TGW            2169
+#define MACH_TYPE_E4430                2170
+#define MACH_TYPE_QL300                2171
+#define MACH_TYPE_BTMAVB101            2172
+#define MACH_TYPE_BTMAWB101            2173
+#define MACH_TYPE_SQ201                2174
+#define MACH_TYPE_QUATRO45XX           2175
+#define MACH_TYPE_OPENPAD              2176
+#define MACH_TYPE_TX25                 2177
+#define MACH_TYPE_OMAP3_TORPEDO        2178
+#define MACH_TYPE_HTCRAPHAEL_K         2179
+#define MACH_TYPE_LAL43                2181
+#define MACH_TYPE_HTCRAPHAEL_CDMA500   2182
+#define MACH_TYPE_ANW6410              2183
+#define MACH_TYPE_HTCPROPHET           2185
+#define MACH_TYPE_CFA_10022            2186
+#define MACH_TYPE_IMX27_VISSTRIM_M10   2187
+#define MACH_TYPE_PX2IMX27             2188
+#define MACH_TYPE_STM3210E_EVAL        2189
+#define MACH_TYPE_DVS10                2190
+#define MACH_TYPE_PORTUXG20            2191
+#define MACH_TYPE_ARM_SPV              2192
+#define MACH_TYPE_SMDKC110             2193
+#define MACH_TYPE_CABESPRESSO          2194
+#define MACH_TYPE_HMC800               2195
+#define MACH_TYPE_SHOLES               2196
+#define MACH_TYPE_BTMXC31              2197
+#define MACH_TYPE_DT501                2198
+#define MACH_TYPE_KTX                  2199
+#define MACH_TYPE_OMAP3517EVM          2200
+#define MACH_TYPE_NETSPACE_V2          2201
+#define MACH_TYPE_NETSPACE_MAX_V2      2202
+#define MACH_TYPE_D2NET_V2             2203
+#define MACH_TYPE_NET2BIG_V2           2204
+#define MACH_TYPE_NET4BIG_V2           2205
+#define MACH_TYPE_NET5BIG_V2           2206
+#define MACH_TYPE_ENDB2443             2207
+#define MACH_TYPE_INETSPACE_V2         2208
+#define MACH_TYPE_TROS                 2209
+#define MACH_TYPE_PELCO_HOMER          2210
+#define MACH_TYPE_OFSP8                2211
+#define MACH_TYPE_AT91SAM9G45EKES      2212
+#define MACH_TYPE_GUF_CUPID            2213
+#define MACH_TYPE_EAB1R                2214
+#define MACH_TYPE_DESIREC              2215
+#define MACH_TYPE_CORDOBA              2216
+#define MACH_TYPE_IRVINE               2217
+#define MACH_TYPE_SFF772               2218
+#define MACH_TYPE_PELCO_MILANO         2219
+#define MACH_TYPE_PC7302               2220
+#define MACH_TYPE_BIP6000              2221
+#define MACH_TYPE_SILVERMOON           2222
+#define MACH_TYPE_VC0830               2223
+#define MACH_TYPE_DT430                2224
+#define MACH_TYPE_JI42PF               2225
+#define MACH_TYPE_GNET_KSM             2226
+#define MACH_TYPE_GNET_SGM             2227
+#define MACH_TYPE_GNET_SGR             2228
+#define MACH_TYPE_OMAP3_ICETEKEVM      2229
+#define MACH_TYPE_PNP                  2230
+#define MACH_TYPE_CTERA_2BAY_K         2231
+#define MACH_TYPE_CTERA_2BAY_U         2232
+#define MACH_TYPE_SAS_C                2233
+#define MACH_TYPE_VMA2315              2234
+#define MACH_TYPE_VCS                  2235
+#define MACH_TYPE_SPEAR600             2236
+#define MACH_TYPE_SPEAR300             2237
+#define MACH_TYPE_SPEAR1300            2238
+#define MACH_TYPE_LILLY1131            2239
+#define MACH_TYPE_ARVOO_AX301          2240
+#define MACH_TYPE_MAPPHONE             2241
+#define MACH_TYPE_LEGEND               2242
+#define MACH_TYPE_SALSA                2243
+#define MACH_TYPE_LOUNGE               2244
+#define MACH_TYPE_VISION               2245
+#define MACH_TYPE_VMB20                2246
+#define MACH_TYPE_HY2410               2247
+#define MACH_TYPE_HY9315               2248
+#define MACH_TYPE_BULLWINKLE           2249
+#define MACH_TYPE_ARM_ULTIMATOR2       2250
+#define MACH_TYPE_VS_V210              2252
+#define MACH_TYPE_VS_V212              2253
+#define MACH_TYPE_HMT                  2254
+#define MACH_TYPE_SUEN3                2255
+#define MACH_TYPE_VESPER               2256
+#define MACH_TYPE_STR9                 2257
+#define MACH_TYPE_OMAP3_WL_FF          2258
+#define MACH_TYPE_SIMCOM               2259
+#define MACH_TYPE_MCWEBIO              2260
+#define MACH_TYPE_OMAP3_PHRAZER        2261
+#define MACH_TYPE_DARWIN               2262
+#define MACH_TYPE_ORATISCOMU           2263
+#define MACH_TYPE_RTSBC20              2264
+#define MACH_TYPE_I780                 2265
+#define MACH_TYPE_GEMINI324            2266
+#define MACH_TYPE_ORATISLAN            2267
+#define MACH_TYPE_ORATISALOG           2268
+#define MACH_TYPE_ORATISMADI           2269
+#define MACH_TYPE_ORATISOT16           2270
+#define MACH_TYPE_ORATISDESK           2271
+#define MACH_TYPE_V2P_CA9              2272
+#define MACH_TYPE_SINTEXO              2273
+#define MACH_TYPE_CM3389               2274
+#define MACH_TYPE_OMAP3_CIO            2275
+#define MACH_TYPE_SGH_I900             2276
+#define MACH_TYPE_BST100               2277
+#define MACH_TYPE_PASSION              2278
+#define MACH_TYPE_INDESIGN_AT91SAM     2279
+#define MACH_TYPE_C4_BADGER            2280
+#define MACH_TYPE_C4_VIPER             2281
+#define MACH_TYPE_D2NET                2282
+#define MACH_TYPE_BIGDISK              2283
+#define MACH_TYPE_NOTALVISION          2284
+#define MACH_TYPE_OMAP3_KBOC           2285
+#define MACH_TYPE_CYCLONE              2286
+#define MACH_TYPE_NINJA                2287
+#define MACH_TYPE_AT91SAM9G20EK_2MMC   2288
+#define MACH_TYPE_BCMRING              2289
+#define MACH_TYPE_RESOL_DL2            2290
+#define MACH_TYPE_IFOSW                2291
+#define MACH_TYPE_HTCRHODIUM           2292
+#define MACH_TYPE_HTCTOPAZ             2293
+#define MACH_TYPE_MATRIX504            2294
+#define MACH_TYPE_MRFSA                2295
+#define MACH_TYPE_SC_P270              2296
+#define MACH_TYPE_ATLAS5_EVB           2297
+#define MACH_TYPE_PELCO_LOBOX          2298
+#define MACH_TYPE_DILAX_PCU200         2299
+#define MACH_TYPE_LEONARDO             2300
+#define MACH_TYPE_ZORAN_APPROACH7      2301
+#define MACH_TYPE_DP6XX                2302
+#define MACH_TYPE_BCM2153_VESPER       2303
+#define MACH_TYPE_MAHIMAHI             2304
+#define MACH_TYPE_CLICKC               2305
+#define MACH_TYPE_ZB_GATEWAY           2306
+#define MACH_TYPE_TAZCARD              2307
+#define MACH_TYPE_TAZDEV               2308
+#define MACH_TYPE_ANNAX_CB_ARM         2309
+#define MACH_TYPE_ANNAX_DM3            2310
+#define MACH_TYPE_CEREBRIC             2311
+#define MACH_TYPE_ORCA                 2312
+#define MACH_TYPE_PC9260               2313
+#define MACH_TYPE_EMS285A              2314
+#define MACH_TYPE_GEC2410              2315
+#define MACH_TYPE_GEC2440              2316
+#define MACH_TYPE_ARCH_MW903           2317
+#define MACH_TYPE_MW2440               2318
+#define MACH_TYPE_ECAC2378             2319
+#define MACH_TYPE_TAZKIOSK             2320
+#define MACH_TYPE_WHITERABBIT_MCH      2321
 
 #ifdef CONFIG_ARCH_EBSA110
 # ifdef machine_arch_type
@@ -5977,6 +6683,18 @@ extern unsigned int __machine_arch_type;
 # define machine_is_bronco()	(0)
 #endif
 
+#ifdef CONFIG_ARCH_ESL_WIRELESS_TAB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESL_WIRELESS_TAB
+# endif
+# define machine_is_esl_wireless_tab()	(machine_arch_type == MACH_TYPE_ESL_WIRELESS_TAB)
+#else
+# define machine_is_esl_wireless_tab()	(0)
+#endif
+
 #ifdef CONFIG_ARCH_ESL_SOFCOMP
 # ifdef machine_arch_type
 #  undef machine_arch_type
@@ -6037,14 +6755,14 @@ extern unsigned int __machine_arch_type;
 # define machine_is_prayoglite()	(0)
 #endif
 
-#ifdef CONFIG_ARCH_GUMSTIK
+#ifdef CONFIG_ARCH_GUMSTIX
 # ifdef machine_arch_type
 #  undef machine_arch_type
 #  define machine_arch_type	__machine_arch_type
 # else
-#  define machine_arch_type	MACH_TYPE_GUMSTIK
+#  define machine_arch_type	MACH_TYPE_GUMSTIX
 # endif
-# define machine_is_gumstix()	(machine_arch_type == MACH_TYPE_GUMSTIK)
+# define machine_is_gumstix()	(machine_arch_type == MACH_TYPE_GUMSTIX)
 #else
 # define machine_is_gumstix()	(0)
 #endif
@@ -8113,18 +8831,6 @@ extern unsigned int __machine_arch_type;
 # define machine_is_aml42800aa()	(0)
 #endif
 
-#ifdef CONFIG_MACH_MACH_TYPE_ML674001
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_MACH_TYPE_ML674001
-# endif
-# define machine_is_ml674001()	(machine_arch_type == MACH_TYPE_MACH_TYPE_ML674001)
-#else
-# define machine_is_ml674001()	(0)
-#endif
-
 #ifdef CONFIG_MACH_LPC2294
 # ifdef machine_arch_type
 #  undef machine_arch_type
@@ -10369,18 +11075,6 @@ extern unsigned int __machine_arch_type;
 # define machine_is_puppeteer()	(0)
 #endif
 
-#ifdef CONFIG_MACH_MACH_VADATECH
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_MACH_VADATECH
-# endif
-# define machine_is_vt001()	(machine_arch_type == MACH_TYPE_MACH_VADATECH)
-#else
-# define machine_is_vt001()	(0)
-#endif
-
 #ifdef CONFIG_MACH_E570
 # ifdef machine_arch_type
 #  undef machine_arch_type
@@ -11461,16 +12155,16 @@ extern unsigned int __machine_arch_type;
 # define machine_is_samoa()	(0)
 #endif
 
-#ifdef CONFIG_MACH_T3XSCALE
+#ifdef CONFIG_MACH_PALMT3
 # ifdef machine_arch_type
 #  undef machine_arch_type
 #  define machine_arch_type	__machine_arch_type
 # else
-#  define machine_arch_type	MACH_TYPE_T3XSCALE
+#  define machine_arch_type	MACH_TYPE_PALMT3
 # endif
-# define machine_is_t3xscale()	(machine_arch_type == MACH_TYPE_T3XSCALE)
+# define machine_is_palmt3()	(machine_arch_type == MACH_TYPE_PALMT3)
 #else
-# define machine_is_t3xscale()	(0)
+# define machine_is_palmt3()	(0)
 #endif
 
 #ifdef CONFIG_MACH_I878
@@ -11533,16 +12227,16 @@ extern unsigned int __machine_arch_type;
 # define machine_is_omap_palmtt2()	(0)
 #endif
 
-#ifdef CONFIG_MACH_XSCALE_PALMLD
+#ifdef CONFIG_MACH_PALMLD
 # ifdef machine_arch_type
 #  undef machine_arch_type
 #  define machine_arch_type	__machine_arch_type
 # else
-#  define machine_arch_type	MACH_TYPE_XSCALE_PALMLD
+#  define machine_arch_type	MACH_TYPE_PALMLD
 # endif
-# define machine_is_xscale_palmld()	(machine_arch_type == MACH_TYPE_XSCALE_PALMLD)
+# define machine_is_palmld()	(machine_arch_type == MACH_TYPE_PALMLD)
 #else
-# define machine_is_xscale_palmld()	(0)
+# define machine_is_palmld()	(0)
 #endif
 
 #ifdef CONFIG_MACH_CC9C
@@ -11641,16 +12335,16 @@ extern unsigned int __machine_arch_type;
 # define machine_is_maestro()	(0)
 #endif
 
-#ifdef CONFIG_MACH_TUNGE2
+#ifdef CONFIG_MACH_PALMTE2
 # ifdef machine_arch_type
 #  undef machine_arch_type
 #  define machine_arch_type	__machine_arch_type
 # else
-#  define machine_arch_type	MACH_TYPE_TUNGE2
+#  define machine_arch_type	MACH_TYPE_PALMTE2
 # endif
-# define machine_is_tunge2()	(machine_arch_type == MACH_TYPE_TUNGE2)
+# define machine_is_palmte2()	(machine_arch_type == MACH_TYPE_PALMTE2)
 #else
-# define machine_is_tunge2()	(0)
+# define machine_is_palmte2()	(0)
 #endif
 
 #ifdef CONFIG_MACH_IXBBM
@@ -12133,16 +12827,16 @@ extern unsigned int __machine_arch_type;
 # define machine_is_mahi_cdac()	(0)
 #endif
 
-#ifdef CONFIG_MACH_XSCALE_PALMTX
+#ifdef CONFIG_MACH_PALMTX
 # ifdef machine_arch_type
 #  undef machine_arch_type
 #  define machine_arch_type	__machine_arch_type
 # else
-#  define machine_arch_type	MACH_TYPE_XSCALE_PALMTX
+#  define machine_arch_type	MACH_TYPE_PALMTX
 # endif
-# define machine_is_xscale_palmtx()	(machine_arch_type == MACH_TYPE_XSCALE_PALMTX)
+# define machine_is_palmtx()	(machine_arch_type == MACH_TYPE_PALMTX)
 #else
-# define machine_is_xscale_palmtx()	(0)
+# define machine_is_palmtx()	(0)
 #endif
 
 #ifdef CONFIG_MACH_S3C2413
@@ -12409,16 +13103,16 @@ extern unsigned int __machine_arch_type;
 # define machine_is_omap_twip()	(0)
 #endif
 
-#ifdef CONFIG_MACH_XSCALE_PALMTREO650
+#ifdef CONFIG_MACH_TREO650
 # ifdef machine_arch_type
 #  undef machine_arch_type
 #  define machine_arch_type	__machine_arch_type
 # else
-#  define machine_arch_type	MACH_TYPE_XSCALE_PALMTREO650
+#  define machine_arch_type	MACH_TYPE_TREO650
 # endif
-# define machine_is_xscale_treo650()	(machine_arch_type == MACH_TYPE_XSCALE_PALMTREO650)
+# define machine_is_treo650()	(machine_arch_type == MACH_TYPE_TREO650)
 #else
-# define machine_is_xscale_treo650()	(0)
+# define machine_is_treo650()	(0)
 #endif
 
 #ifdef CONFIG_MACH_ACUMEN
@@ -12505,28 +13199,28 @@ extern unsigned int __machine_arch_type;
 # define machine_is_netclient()	(0)
 #endif
 
-#ifdef CONFIG_MACH_XSCALE_PALMTT5
+#ifdef CONFIG_MACH_PALMT5
 # ifdef machine_arch_type
 #  undef machine_arch_type
 #  define machine_arch_type	__machine_arch_type
 # else
-#  define machine_arch_type	MACH_TYPE_XSCALE_PALMTT5
+#  define machine_arch_type	MACH_TYPE_PALMT5
 # endif
-# define machine_is_xscale_palmtt5()	(machine_arch_type == MACH_TYPE_XSCALE_PALMTT5)
+# define machine_is_palmt5()	(machine_arch_type == MACH_TYPE_PALMT5)
 #else
-# define machine_is_xscale_palmtt5()	(0)
+# define machine_is_palmt5()	(0)
 #endif
 
-#ifdef CONFIG_MACH_OMAP_PALMTC
+#ifdef CONFIG_MACH_PALMTC
 # ifdef machine_arch_type
 #  undef machine_arch_type
 #  define machine_arch_type	__machine_arch_type
 # else
-#  define machine_arch_type	MACH_TYPE_OMAP_PALMTC
+#  define machine_arch_type	MACH_TYPE_PALMTC
 # endif
-# define machine_is_xscale_palmtc()	(machine_arch_type == MACH_TYPE_OMAP_PALMTC)
+# define machine_is_palmtc()	(machine_arch_type == MACH_TYPE_PALMTC)
 #else
-# define machine_is_xscale_palmtc()	(0)
+# define machine_is_palmtc()	(0)
 #endif
 
 #ifdef CONFIG_MACH_OMAP_APOLLON
@@ -14569,16 +15263,16 @@ extern unsigned int __machine_arch_type;
 # define machine_is_ecsd()	(0)
 #endif
 
-#ifdef CONFIG_MACH_ZIRE31
+#ifdef CONFIG_MACH_PALMZ31
 # ifdef machine_arch_type
 #  undef machine_arch_type
 #  define machine_arch_type	__machine_arch_type
 # else
-#  define machine_arch_type	MACH_TYPE_ZIRE31
+#  define machine_arch_type	MACH_TYPE_PALMZ31
 # endif
-# define machine_is_zire31()	(machine_arch_type == MACH_TYPE_ZIRE31)
+# define machine_is_palmz31()	(machine_arch_type == MACH_TYPE_PALMZ31)
 #else
-# define machine_is_zire31()	(0)
+# define machine_is_palmz31()	(0)
 #endif
 
 #ifdef CONFIG_MACH_FSG
@@ -16033,18 +16727,6 @@ extern unsigned int __machine_arch_type;
 # define machine_is_eti_c1()	(0)
 #endif
 
-#ifdef CONFIG_MACH_MACH_DEP2410
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_MACH_DEP2410
-# endif
-# define machine_is_mach_dep2410()	(machine_arch_type == MACH_TYPE_MACH_DEP2410)
-#else
-# define machine_is_mach_dep2410()	(0)
-#endif
-
 #ifdef CONFIG_MACH_AC100
 # ifdef machine_arch_type
 #  undef machine_arch_type
@@ -16213,16 +16895,16 @@ extern unsigned int __machine_arch_type;
 # define machine_is_htcwizard()	(0)
 #endif
 
-#ifdef CONFIG_MACH_XSCALE_TREO680
+#ifdef CONFIG_MACH_TREO680
 # ifdef machine_arch_type
 #  undef machine_arch_type
 #  define machine_arch_type	__machine_arch_type
 # else
-#  define machine_arch_type	MACH_TYPE_XSCALE_TREO680
+#  define machine_arch_type	MACH_TYPE_TREO680
 # endif
-# define machine_is_xscale_treo680()	(machine_arch_type == MACH_TYPE_XSCALE_TREO680)
+# define machine_is_treo680()	(machine_arch_type == MACH_TYPE_TREO680)
 #else
-# define machine_is_xscale_treo680()	(0)
+# define machine_is_treo680()	(0)
 #endif
 
 #ifdef CONFIG_MACH_TECON_TMEZON
@@ -16501,18 +17183,6 @@ extern unsigned int __machine_arch_type;
 # define machine_is_schmoogie()	(0)
 #endif
 
-#ifdef CONFIG_MACH_SFFSDR
-# ifdef machine_arch_type
-#  undef machine_arch_type
-#  define machine_arch_type	__machine_arch_type
-# else
-#  define machine_arch_type	MACH_TYPE_SFFSDR
-# endif
-# define machine_is_sffsdr()	(machine_arch_type == MACH_TYPE_SFFSDR)
-#else
-# define machine_is_sffsdr()	(0)
-#endif
-
 #ifdef CONFIG_MACH_AZTOOL
 # ifdef machine_arch_type
 #  undef machine_arch_type
@@ -18001,14 +18671,14 @@ extern unsigned int __machine_arch_type;
 # define machine_is_davinci_dm6467_evm()	(0)
 #endif
 
-#ifdef CONFIG_MACH_DAVINCI_DM350_EVM
+#ifdef CONFIG_MACH_DAVINCI_DM355_EVM
 # ifdef machine_arch_type
 #  undef machine_arch_type
 #  define machine_arch_type	__machine_arch_type
 # else
-#  define machine_arch_type	MACH_TYPE_DAVINCI_DM350_EVM
+#  define machine_arch_type	MACH_TYPE_DAVINCI_DM355_EVM
 # endif
-# define machine_is_davinci_dm355_evm()	(machine_arch_type == MACH_TYPE_DAVINCI_DM350_EVM)
+# define machine_is_davinci_dm355_evm()	(machine_arch_type == MACH_TYPE_DAVINCI_DM355_EVM)
 #else
 # define machine_is_davinci_dm355_evm()	(0)
 #endif
@@ -18457,52 +19127,52 @@ extern unsigned int __machine_arch_type;
 # define machine_is_sideoatsgrama()	(0)
 #endif
 
-#ifdef CONFIG_MACH_XSCALE_PALMT700P
+#ifdef CONFIG_MACH_TREO700P
 # ifdef machine_arch_type
 #  undef machine_arch_type
 #  define machine_arch_type	__machine_arch_type
 # else
-#  define machine_arch_type	MACH_TYPE_XSCALE_PALMT700P
+#  define machine_arch_type	MACH_TYPE_TREO700P
 # endif
-# define machine_is_xscale_palmt700p()	(machine_arch_type == MACH_TYPE_XSCALE_PALMT700P)
+# define machine_is_treo700p()	(machine_arch_type == MACH_TYPE_TREO700P)
 #else
-# define machine_is_xscale_palmt700p()	(0)
+# define machine_is_treo700p()	(0)
 #endif
 
-#ifdef CONFIG_MACH_XSCALE_PALMT700W
+#ifdef CONFIG_MACH_TREO700W
 # ifdef machine_arch_type
 #  undef machine_arch_type
 #  define machine_arch_type	__machine_arch_type
 # else
-#  define machine_arch_type	MACH_TYPE_XSCALE_PALMT700W
+#  define machine_arch_type	MACH_TYPE_TREO700W
 # endif
-# define machine_is_xscale_palmt700w()	(machine_arch_type == MACH_TYPE_XSCALE_PALMT700W)
+# define machine_is_treo700w()	(machine_arch_type == MACH_TYPE_TREO700W)
 #else
-# define machine_is_xscale_palmt700w()	(0)
+# define machine_is_treo700w()	(0)
 #endif
 
-#ifdef CONFIG_MACH_XSCALE_PALMT750
+#ifdef CONFIG_MACH_TREO750
 # ifdef machine_arch_type
 #  undef machine_arch_type
 #  define machine_arch_type	__machine_arch_type
 # else
-#  define machine_arch_type	MACH_TYPE_XSCALE_PALMT750
+#  define machine_arch_type	MACH_TYPE_TREO750
 # endif
-# define machine_is_xscale_palmt750()	(machine_arch_type == MACH_TYPE_XSCALE_PALMT750)
+# define machine_is_treo750()	(machine_arch_type == MACH_TYPE_TREO750)
 #else
-# define machine_is_xscale_palmt750()	(0)
+# define machine_is_treo750()	(0)
 #endif
 
-#ifdef CONFIG_MACH_XSCALE_PALMT755P
+#ifdef CONFIG_MACH_TREO755P
 # ifdef machine_arch_type
 #  undef machine_arch_type
 #  define machine_arch_type	__machine_arch_type
 # else
-#  define machine_arch_type	MACH_TYPE_XSCALE_PALMT755P
+#  define machine_arch_type	MACH_TYPE_TREO755P
 # endif
-# define machine_is_xscale_palmt755p()	(machine_arch_type == MACH_TYPE_XSCALE_PALMT755P)
+# define machine_is_treo755p()	(machine_arch_type == MACH_TYPE_TREO755P)
 #else
-# define machine_is_xscale_palmt755p()	(0)
+# define machine_is_treo755p()	(0)
 #endif
 
 #ifdef CONFIG_MACH_EZREGANUT9200
@@ -18961,16 +19631,16 @@ extern unsigned int __machine_arch_type;
 # define machine_is_adx_wsc2()	(0)
 #endif
 
-#ifdef CONFIG_MACH_ADX_MEDINET
+#ifdef CONFIG_MACH_ADX_MEDCOM
 # ifdef machine_arch_type
 #  undef machine_arch_type
 #  define machine_arch_type	__machine_arch_type
 # else
-#  define machine_arch_type	MACH_TYPE_ADX_MEDINET
+#  define machine_arch_type	MACH_TYPE_ADX_MEDCOM
 # endif
-# define machine_is_adx_medinet()	(machine_arch_type == MACH_TYPE_ADX_MEDINET)
+# define machine_is_adx_medcom()	(machine_arch_type == MACH_TYPE_ADX_MEDCOM)
 #else
-# define machine_is_adx_medinet()	(0)
+# define machine_is_adx_medcom()	(0)
 #endif
 
 #ifdef CONFIG_MACH_BBOARD
@@ -19633,16 +20303,16 @@ extern unsigned int __machine_arch_type;
 # define machine_is_tll5000()	(0)
 #endif
 
-#ifdef CONFIG_MACH_HNI_X270
+#ifdef CONFIG_MACH_BEBOT
 # ifdef machine_arch_type
 #  undef machine_arch_type
 #  define machine_arch_type	__machine_arch_type
 # else
-#  define machine_arch_type	MACH_TYPE_HNI_X270
+#  define machine_arch_type	MACH_TYPE_BEBOT
 # endif
-# define machine_is_hni270()	(machine_arch_type == MACH_TYPE_HNI_X270)
+# define machine_is_bebot()	(machine_arch_type == MACH_TYPE_BEBOT)
 #else
-# define machine_is_hni270()	(0)
+# define machine_is_bebot()	(0)
 #endif
 
 #ifdef CONFIG_MACH_QONG
@@ -20605,11 +21275,8517 @@ extern unsigned int __machine_arch_type;
 # define machine_is_dexflex2()	(0)
 #endif
 
+#ifdef CONFIG_MACH_OW
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OW
+# endif
+# define machine_is_ow()	(machine_arch_type == MACH_TYPE_OW)
+#else
+# define machine_is_ow()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARMEBS3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARMEBS3
+# endif
+# define machine_is_armebs3()	(machine_arch_type == MACH_TYPE_ARMEBS3)
+#else
+# define machine_is_armebs3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_U3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_U3
+# endif
+# define machine_is_u3()	(machine_arch_type == MACH_TYPE_U3)
+#else
+# define machine_is_u3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK2450
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK2450
+# endif
+# define machine_is_smdk2450()	(machine_arch_type == MACH_TYPE_SMDK2450)
+#else
+# define machine_is_smdk2450()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RSI_EWS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RSI_EWS
+# endif
+# define machine_is_rsi_ews()	(machine_arch_type == MACH_TYPE_RSI_EWS)
+#else
+# define machine_is_rsi_ews()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TNB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TNB
+# endif
+# define machine_is_tnb()	(machine_arch_type == MACH_TYPE_TNB)
+#else
+# define machine_is_tnb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TOEPATH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TOEPATH
+# endif
+# define machine_is_toepath()	(machine_arch_type == MACH_TYPE_TOEPATH)
+#else
+# define machine_is_toepath()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KB9263
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KB9263
+# endif
+# define machine_is_kb9263()	(machine_arch_type == MACH_TYPE_KB9263)
+#else
+# define machine_is_kb9263()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MT7108
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MT7108
+# endif
+# define machine_is_mt7108()	(machine_arch_type == MACH_TYPE_MT7108)
+#else
+# define machine_is_mt7108()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMTR2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMTR2440
+# endif
+# define machine_is_smtr2440()	(machine_arch_type == MACH_TYPE_SMTR2440)
+#else
+# define machine_is_smtr2440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MANAO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MANAO
+# endif
+# define machine_is_manao()	(machine_arch_type == MACH_TYPE_MANAO)
+#else
+# define machine_is_manao()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CM_X300
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CM_X300
+# endif
+# define machine_is_cm_x300()	(machine_arch_type == MACH_TYPE_CM_X300)
+#else
+# define machine_is_cm_x300()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GULFSTREAM_KP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GULFSTREAM_KP
+# endif
+# define machine_is_gulfstream_kp()	(machine_arch_type == MACH_TYPE_GULFSTREAM_KP)
+#else
+# define machine_is_gulfstream_kp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LANREADYFN522
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LANREADYFN522
+# endif
+# define machine_is_lanreadyfn522()	(machine_arch_type == MACH_TYPE_LANREADYFN522)
+#else
+# define machine_is_lanreadyfn522()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARMA37
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARMA37
+# endif
+# define machine_is_arma37()	(machine_arch_type == MACH_TYPE_ARMA37)
+#else
+# define machine_is_arma37()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MENDEL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MENDEL
+# endif
+# define machine_is_mendel()	(machine_arch_type == MACH_TYPE_MENDEL)
+#else
+# define machine_is_mendel()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PELCO_ILIAD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PELCO_ILIAD
+# endif
+# define machine_is_pelco_iliad()	(machine_arch_type == MACH_TYPE_PELCO_ILIAD)
+#else
+# define machine_is_pelco_iliad()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UNIT2P
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UNIT2P
+# endif
+# define machine_is_unit2p()	(machine_arch_type == MACH_TYPE_UNIT2P)
+#else
+# define machine_is_unit2p()	(0)
+#endif
+
+#ifdef CONFIG_MACH_INC20OTTER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INC20OTTER
+# endif
+# define machine_is_inc20otter()	(machine_arch_type == MACH_TYPE_INC20OTTER)
+#else
+# define machine_is_inc20otter()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9G20EK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9G20EK
+# endif
+# define machine_is_at91sam9g20ek()	(machine_arch_type == MACH_TYPE_AT91SAM9G20EK)
+#else
+# define machine_is_at91sam9g20ek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STORCENTER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STORCENTER
+# endif
+# define machine_is_sc_ge2()	(machine_arch_type == MACH_TYPE_STORCENTER)
+#else
+# define machine_is_sc_ge2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK6410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK6410
+# endif
+# define machine_is_smdk6410()	(machine_arch_type == MACH_TYPE_SMDK6410)
+#else
+# define machine_is_smdk6410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_U300
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_U300
+# endif
+# define machine_is_u300()	(machine_arch_type == MACH_TYPE_U300)
+#else
+# define machine_is_u300()	(0)
+#endif
+
+#ifdef CONFIG_MACH_U500
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_U500
+# endif
+# define machine_is_u500()	(machine_arch_type == MACH_TYPE_U500)
+#else
+# define machine_is_u500()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DS9260
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DS9260
+# endif
+# define machine_is_ds9260()	(machine_arch_type == MACH_TYPE_DS9260)
+#else
+# define machine_is_ds9260()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RIVERROCK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RIVERROCK
+# endif
+# define machine_is_riverrock()	(machine_arch_type == MACH_TYPE_RIVERROCK)
+#else
+# define machine_is_riverrock()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SCIBATH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SCIBATH
+# endif
+# define machine_is_scibath()	(machine_arch_type == MACH_TYPE_SCIBATH)
+#else
+# define machine_is_scibath()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM7SE512EK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM7SE512EK
+# endif
+# define machine_is_at91sam7se()	(machine_arch_type == MACH_TYPE_AT91SAM7SE512EK)
+#else
+# define machine_is_at91sam7se()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WRT350N_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WRT350N_V2
+# endif
+# define machine_is_wrt350n_v2()	(machine_arch_type == MACH_TYPE_WRT350N_V2)
+#else
+# define machine_is_wrt350n_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MULTIMEDIA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MULTIMEDIA
+# endif
+# define machine_is_multimedia()	(machine_arch_type == MACH_TYPE_MULTIMEDIA)
+#else
+# define machine_is_multimedia()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MARVIN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MARVIN
+# endif
+# define machine_is_marvin()	(machine_arch_type == MACH_TYPE_MARVIN)
+#else
+# define machine_is_marvin()	(0)
+#endif
+
+#ifdef CONFIG_MACH_X500
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_X500
+# endif
+# define machine_is_x500()	(machine_arch_type == MACH_TYPE_X500)
+#else
+# define machine_is_x500()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AWLUG4LCU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AWLUG4LCU
+# endif
+# define machine_is_awlug4lcu()	(machine_arch_type == MACH_TYPE_AWLUG4LCU)
+#else
+# define machine_is_awlug4lcu()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PALERMOC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PALERMOC
+# endif
+# define machine_is_palermoc()	(machine_arch_type == MACH_TYPE_PALERMOC)
+#else
+# define machine_is_palermoc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_LDP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_LDP
+# endif
+# define machine_is_omap_ldp()	(machine_arch_type == MACH_TYPE_OMAP_LDP)
+#else
+# define machine_is_omap_ldp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IP500
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IP500
+# endif
+# define machine_is_ip500()	(machine_arch_type == MACH_TYPE_IP500)
+#else
+# define machine_is_ip500()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ASE2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ASE2
+# endif
+# define machine_is_ase2()	(machine_arch_type == MACH_TYPE_ASE2)
+#else
+# define machine_is_ase2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX35EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX35EVB
+# endif
+# define machine_is_mx35evb()	(machine_arch_type == MACH_TYPE_MX35EVB)
+#else
+# define machine_is_mx35evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AML_M8050
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AML_M8050
+# endif
+# define machine_is_aml_m8050()	(machine_arch_type == MACH_TYPE_AML_M8050)
+#else
+# define machine_is_aml_m8050()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX35_3DS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX35_3DS
+# endif
+# define machine_is_mx35_3ds()	(machine_arch_type == MACH_TYPE_MX35_3DS)
+#else
+# define machine_is_mx35_3ds()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MARS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MARS
+# endif
+# define machine_is_mars()	(machine_arch_type == MACH_TYPE_MARS)
+#else
+# define machine_is_mars()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NTOSD_644XA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NTOSD_644XA
+# endif
+# define machine_is_ntosd_644xa()	(machine_arch_type == MACH_TYPE_NTOSD_644XA)
+#else
+# define machine_is_ntosd_644xa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BADGER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BADGER
+# endif
+# define machine_is_badger()	(machine_arch_type == MACH_TYPE_BADGER)
+#else
+# define machine_is_badger()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TRIZEPS4WL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TRIZEPS4WL
+# endif
+# define machine_is_trizeps4wl()	(machine_arch_type == MACH_TYPE_TRIZEPS4WL)
+#else
+# define machine_is_trizeps4wl()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TRIZEPS5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TRIZEPS5
+# endif
+# define machine_is_trizeps5()	(machine_arch_type == MACH_TYPE_TRIZEPS5)
+#else
+# define machine_is_trizeps5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MARLIN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MARLIN
+# endif
+# define machine_is_marlin()	(machine_arch_type == MACH_TYPE_MARLIN)
+#else
+# define machine_is_marlin()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TS78XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TS78XX
+# endif
+# define machine_is_ts78xx()	(machine_arch_type == MACH_TYPE_TS78XX)
+#else
+# define machine_is_ts78xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HPIPAQ214
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HPIPAQ214
+# endif
+# define machine_is_hpipaq214()	(machine_arch_type == MACH_TYPE_HPIPAQ214)
+#else
+# define machine_is_hpipaq214()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT572D940DCM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT572D940DCM
+# endif
+# define machine_is_at572d940dcm()	(machine_arch_type == MACH_TYPE_AT572D940DCM)
+#else
+# define machine_is_at572d940dcm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NE1BOARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NE1BOARD
+# endif
+# define machine_is_ne1board()	(machine_arch_type == MACH_TYPE_NE1BOARD)
+#else
+# define machine_is_ne1board()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZANTE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZANTE
+# endif
+# define machine_is_zante()	(machine_arch_type == MACH_TYPE_ZANTE)
+#else
+# define machine_is_zante()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SFFSDR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SFFSDR
+# endif
+# define machine_is_sffsdr()	(machine_arch_type == MACH_TYPE_SFFSDR)
+#else
+# define machine_is_sffsdr()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TW2662
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TW2662
+# endif
+# define machine_is_tw2662()	(machine_arch_type == MACH_TYPE_TW2662)
+#else
+# define machine_is_tw2662()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VF10XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VF10XX
+# endif
+# define machine_is_vf10xx()	(machine_arch_type == MACH_TYPE_VF10XX)
+#else
+# define machine_is_vf10xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZORAN43XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZORAN43XX
+# endif
+# define machine_is_zoran43xx()	(machine_arch_type == MACH_TYPE_ZORAN43XX)
+#else
+# define machine_is_zoran43xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SONIX926
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SONIX926
+# endif
+# define machine_is_sonix926()	(machine_arch_type == MACH_TYPE_SONIX926)
+#else
+# define machine_is_sonix926()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CELESTIALSEMI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CELESTIALSEMI
+# endif
+# define machine_is_celestialsemi()	(machine_arch_type == MACH_TYPE_CELESTIALSEMI)
+#else
+# define machine_is_celestialsemi()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CC9M2443
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CC9M2443
+# endif
+# define machine_is_cc9m2443()	(machine_arch_type == MACH_TYPE_CC9M2443)
+#else
+# define machine_is_cc9m2443()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TW5334
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TW5334
+# endif
+# define machine_is_tw5334()	(machine_arch_type == MACH_TYPE_TW5334)
+#else
+# define machine_is_tw5334()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCARTEMIS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCARTEMIS
+# endif
+# define machine_is_omap_htcartemis()	(machine_arch_type == MACH_TYPE_HTCARTEMIS)
+#else
+# define machine_is_omap_htcartemis()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NAL_HLITE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NAL_HLITE
+# endif
+# define machine_is_nal_hlite()	(machine_arch_type == MACH_TYPE_NAL_HLITE)
+#else
+# define machine_is_nal_hlite()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCVOGUE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCVOGUE
+# endif
+# define machine_is_htcvogue()	(machine_arch_type == MACH_TYPE_HTCVOGUE)
+#else
+# define machine_is_htcvogue()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMARTWEB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMARTWEB
+# endif
+# define machine_is_smartweb()	(machine_arch_type == MACH_TYPE_SMARTWEB)
+#else
+# define machine_is_smartweb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MV86XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MV86XX
+# endif
+# define machine_is_mv86xx()	(machine_arch_type == MACH_TYPE_MV86XX)
+#else
+# define machine_is_mv86xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MV87XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MV87XX
+# endif
+# define machine_is_mv87xx()	(machine_arch_type == MACH_TYPE_MV87XX)
+#else
+# define machine_is_mv87xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SONGYOUNGHO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SONGYOUNGHO
+# endif
+# define machine_is_songyoungho()	(machine_arch_type == MACH_TYPE_SONGYOUNGHO)
+#else
+# define machine_is_songyoungho()	(0)
+#endif
+
+#ifdef CONFIG_MACH_YOUNGHOTEMA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_YOUNGHOTEMA
+# endif
+# define machine_is_younghotema()	(machine_arch_type == MACH_TYPE_YOUNGHOTEMA)
+#else
+# define machine_is_younghotema()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PCM037
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PCM037
+# endif
+# define machine_is_pcm037()	(machine_arch_type == MACH_TYPE_PCM037)
+#else
+# define machine_is_pcm037()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MMVP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MMVP
+# endif
+# define machine_is_mmvp()	(machine_arch_type == MACH_TYPE_MMVP)
+#else
+# define machine_is_mmvp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MMAP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MMAP
+# endif
+# define machine_is_mmap()	(machine_arch_type == MACH_TYPE_MMAP)
+#else
+# define machine_is_mmap()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PTID2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PTID2410
+# endif
+# define machine_is_ptid2410()	(machine_arch_type == MACH_TYPE_PTID2410)
+#else
+# define machine_is_ptid2410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_JAMES_926
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JAMES_926
+# endif
+# define machine_is_james_926()	(machine_arch_type == MACH_TYPE_JAMES_926)
+#else
+# define machine_is_james_926()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FM6000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FM6000
+# endif
+# define machine_is_fm6000()	(machine_arch_type == MACH_TYPE_FM6000)
+#else
+# define machine_is_fm6000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DB88F6281_BP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DB88F6281_BP
+# endif
+# define machine_is_db88f6281_bp()	(machine_arch_type == MACH_TYPE_DB88F6281_BP)
+#else
+# define machine_is_db88f6281_bp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RD88F6192_NAS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RD88F6192_NAS
+# endif
+# define machine_is_rd88f6192_nas()	(machine_arch_type == MACH_TYPE_RD88F6192_NAS)
+#else
+# define machine_is_rd88f6192_nas()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RD88F6281
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RD88F6281
+# endif
+# define machine_is_rd88f6281()	(machine_arch_type == MACH_TYPE_RD88F6281)
+#else
+# define machine_is_rd88f6281()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DB78X00_BP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DB78X00_BP
+# endif
+# define machine_is_db78x00_bp()	(machine_arch_type == MACH_TYPE_DB78X00_BP)
+#else
+# define machine_is_db78x00_bp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK2416
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK2416
+# endif
+# define machine_is_smdk2416()	(machine_arch_type == MACH_TYPE_SMDK2416)
+#else
+# define machine_is_smdk2416()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OCE_SPIDER_SI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OCE_SPIDER_SI
+# endif
+# define machine_is_oce_spider_si()	(machine_arch_type == MACH_TYPE_OCE_SPIDER_SI)
+#else
+# define machine_is_oce_spider_si()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OCE_SPIDER_SK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OCE_SPIDER_SK
+# endif
+# define machine_is_oce_spider_sk()	(machine_arch_type == MACH_TYPE_OCE_SPIDER_SK)
+#else
+# define machine_is_oce_spider_sk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ROVERN6
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ROVERN6
+# endif
+# define machine_is_rovern6()	(machine_arch_type == MACH_TYPE_ROVERN6)
+#else
+# define machine_is_rovern6()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PELCO_EVOLUTION
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PELCO_EVOLUTION
+# endif
+# define machine_is_pelco_evolution()	(machine_arch_type == MACH_TYPE_PELCO_EVOLUTION)
+#else
+# define machine_is_pelco_evolution()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WBD111
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WBD111
+# endif
+# define machine_is_wbd111()	(machine_arch_type == MACH_TYPE_WBD111)
+#else
+# define machine_is_wbd111()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ELARACPE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ELARACPE
+# endif
+# define machine_is_elaracpe()	(machine_arch_type == MACH_TYPE_ELARACPE)
+#else
+# define machine_is_elaracpe()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MABV3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MABV3
+# endif
+# define machine_is_mabv3()	(machine_arch_type == MACH_TYPE_MABV3)
+#else
+# define machine_is_mabv3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MV2120
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MV2120
+# endif
+# define machine_is_mv2120()	(machine_arch_type == MACH_TYPE_MV2120)
+#else
+# define machine_is_mv2120()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CSB737
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSB737
+# endif
+# define machine_is_csb737()	(machine_arch_type == MACH_TYPE_CSB737)
+#else
+# define machine_is_csb737()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX51_3DS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX51_3DS
+# endif
+# define machine_is_mx51_3ds()	(machine_arch_type == MACH_TYPE_MX51_3DS)
+#else
+# define machine_is_mx51_3ds()	(0)
+#endif
+
+#ifdef CONFIG_MACH_G900
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_G900
+# endif
+# define machine_is_g900()	(machine_arch_type == MACH_TYPE_G900)
+#else
+# define machine_is_g900()	(0)
+#endif
+
+#ifdef CONFIG_MACH_APF27
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_APF27
+# endif
+# define machine_is_apf27()	(machine_arch_type == MACH_TYPE_APF27)
+#else
+# define machine_is_apf27()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GGUS2000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GGUS2000
+# endif
+# define machine_is_ggus2000()	(machine_arch_type == MACH_TYPE_GGUS2000)
+#else
+# define machine_is_ggus2000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_2430_MIMIC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_2430_MIMIC
+# endif
+# define machine_is_omap_2430_mimic()	(machine_arch_type == MACH_TYPE_OMAP_2430_MIMIC)
+#else
+# define machine_is_omap_2430_mimic()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IMX27LITE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IMX27LITE
+# endif
+# define machine_is_imx27lite()	(machine_arch_type == MACH_TYPE_IMX27LITE)
+#else
+# define machine_is_imx27lite()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ALMEX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ALMEX
+# endif
+# define machine_is_almex()	(machine_arch_type == MACH_TYPE_ALMEX)
+#else
+# define machine_is_almex()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CONTROL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CONTROL
+# endif
+# define machine_is_control()	(machine_arch_type == MACH_TYPE_CONTROL)
+#else
+# define machine_is_control()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MBA2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MBA2410
+# endif
+# define machine_is_mba2410()	(machine_arch_type == MACH_TYPE_MBA2410)
+#else
+# define machine_is_mba2410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VOLCANO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VOLCANO
+# endif
+# define machine_is_volcano()	(machine_arch_type == MACH_TYPE_VOLCANO)
+#else
+# define machine_is_volcano()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZENITH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZENITH
+# endif
+# define machine_is_zenith()	(machine_arch_type == MACH_TYPE_ZENITH)
+#else
+# define machine_is_zenith()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MUCHIP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MUCHIP
+# endif
+# define machine_is_muchip()	(machine_arch_type == MACH_TYPE_MUCHIP)
+#else
+# define machine_is_muchip()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAGELLAN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAGELLAN
+# endif
+# define machine_is_magellan()	(machine_arch_type == MACH_TYPE_MAGELLAN)
+#else
+# define machine_is_magellan()	(0)
+#endif
+
+#ifdef CONFIG_MACH_USB_A9260
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_USB_A9260
+# endif
+# define machine_is_usb_a9260()	(machine_arch_type == MACH_TYPE_USB_A9260)
+#else
+# define machine_is_usb_a9260()	(0)
+#endif
+
+#ifdef CONFIG_MACH_USB_A9263
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_USB_A9263
+# endif
+# define machine_is_usb_a9263()	(machine_arch_type == MACH_TYPE_USB_A9263)
+#else
+# define machine_is_usb_a9263()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QIL_A9260
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QIL_A9260
+# endif
+# define machine_is_qil_a9260()	(machine_arch_type == MACH_TYPE_QIL_A9260)
+#else
+# define machine_is_qil_a9260()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CME9210
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CME9210
+# endif
+# define machine_is_cme9210()	(machine_arch_type == MACH_TYPE_CME9210)
+#else
+# define machine_is_cme9210()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HCZH4
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HCZH4
+# endif
+# define machine_is_hczh4()	(machine_arch_type == MACH_TYPE_HCZH4)
+#else
+# define machine_is_hczh4()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPEARBASIC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPEARBASIC
+# endif
+# define machine_is_spearbasic()	(machine_arch_type == MACH_TYPE_SPEARBASIC)
+#else
+# define machine_is_spearbasic()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DEP2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DEP2440
+# endif
+# define machine_is_dep2440()	(machine_arch_type == MACH_TYPE_DEP2440)
+#else
+# define machine_is_dep2440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HDL_GXR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HDL_GXR
+# endif
+# define machine_is_hdl_gxr()	(machine_arch_type == MACH_TYPE_HDL_GXR)
+#else
+# define machine_is_hdl_gxr()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HDL_GT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HDL_GT
+# endif
+# define machine_is_hdl_gt()	(machine_arch_type == MACH_TYPE_HDL_GT)
+#else
+# define machine_is_hdl_gt()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HDL_4G
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HDL_4G
+# endif
+# define machine_is_hdl_4g()	(machine_arch_type == MACH_TYPE_HDL_4G)
+#else
+# define machine_is_hdl_4g()	(0)
+#endif
+
+#ifdef CONFIG_MACH_S3C6000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S3C6000
+# endif
+# define machine_is_s3c6000()	(machine_arch_type == MACH_TYPE_S3C6000)
+#else
+# define machine_is_s3c6000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MMSP2_MDK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MMSP2_MDK
+# endif
+# define machine_is_mmsp2_mdk()	(machine_arch_type == MACH_TYPE_MMSP2_MDK)
+#else
+# define machine_is_mmsp2_mdk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MPX220
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MPX220
+# endif
+# define machine_is_mpx220()	(machine_arch_type == MACH_TYPE_MPX220)
+#else
+# define machine_is_mpx220()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KZM_ARM11_01
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KZM_ARM11_01
+# endif
+# define machine_is_kzm_arm11_01()	(machine_arch_type == MACH_TYPE_KZM_ARM11_01)
+#else
+# define machine_is_kzm_arm11_01()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTC_POLARIS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTC_POLARIS
+# endif
+# define machine_is_htc_polaris()	(machine_arch_type == MACH_TYPE_HTC_POLARIS)
+#else
+# define machine_is_htc_polaris()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTC_KAISER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTC_KAISER
+# endif
+# define machine_is_htc_kaiser()	(machine_arch_type == MACH_TYPE_HTC_KAISER)
+#else
+# define machine_is_htc_kaiser()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LG_KS20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LG_KS20
+# endif
+# define machine_is_lg_ks20()	(machine_arch_type == MACH_TYPE_LG_KS20)
+#else
+# define machine_is_lg_ks20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HHGPS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HHGPS
+# endif
+# define machine_is_hhgps()	(machine_arch_type == MACH_TYPE_HHGPS)
+#else
+# define machine_is_hhgps()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NOKIA_N810_WIMAX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NOKIA_N810_WIMAX
+# endif
+# define machine_is_nokia_n810_wimax()	(machine_arch_type == MACH_TYPE_NOKIA_N810_WIMAX)
+#else
+# define machine_is_nokia_n810_wimax()	(0)
+#endif
+
+#ifdef CONFIG_MACH_INSIGHT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INSIGHT
+# endif
+# define machine_is_insight()	(machine_arch_type == MACH_TYPE_INSIGHT)
+#else
+# define machine_is_insight()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SAPPHIRE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SAPPHIRE
+# endif
+# define machine_is_sapphire()	(machine_arch_type == MACH_TYPE_SAPPHIRE)
+#else
+# define machine_is_sapphire()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CSB637XO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSB637XO
+# endif
+# define machine_is_csb637xo()	(machine_arch_type == MACH_TYPE_CSB637XO)
+#else
+# define machine_is_csb637xo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EVISIONG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EVISIONG
+# endif
+# define machine_is_evisiong()	(machine_arch_type == MACH_TYPE_EVISIONG)
+#else
+# define machine_is_evisiong()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STMP37XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STMP37XX
+# endif
+# define machine_is_stmp37xx()	(machine_arch_type == MACH_TYPE_STMP37XX)
+#else
+# define machine_is_stmp37xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STMP378X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STMP378X
+# endif
+# define machine_is_stmp378x()	(machine_arch_type == MACH_TYPE_STMP378X)
+#else
+# define machine_is_stmp378x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TNT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TNT
+# endif
+# define machine_is_tnt()	(machine_arch_type == MACH_TYPE_TNT)
+#else
+# define machine_is_tnt()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TBXT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TBXT
+# endif
+# define machine_is_tbxt()	(machine_arch_type == MACH_TYPE_TBXT)
+#else
+# define machine_is_tbxt()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PLAYMATE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PLAYMATE
+# endif
+# define machine_is_playmate()	(machine_arch_type == MACH_TYPE_PLAYMATE)
+#else
+# define machine_is_playmate()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PNS10
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PNS10
+# endif
+# define machine_is_pns10()	(machine_arch_type == MACH_TYPE_PNS10)
+#else
+# define machine_is_pns10()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EZNAVI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EZNAVI
+# endif
+# define machine_is_eznavi()	(machine_arch_type == MACH_TYPE_EZNAVI)
+#else
+# define machine_is_eznavi()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PS4000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PS4000
+# endif
+# define machine_is_ps4000()	(machine_arch_type == MACH_TYPE_PS4000)
+#else
+# define machine_is_ps4000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EZX_A780
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EZX_A780
+# endif
+# define machine_is_ezx_a780()	(machine_arch_type == MACH_TYPE_EZX_A780)
+#else
+# define machine_is_ezx_a780()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EZX_E680
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EZX_E680
+# endif
+# define machine_is_ezx_e680()	(machine_arch_type == MACH_TYPE_EZX_E680)
+#else
+# define machine_is_ezx_e680()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EZX_A1200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EZX_A1200
+# endif
+# define machine_is_ezx_a1200()	(machine_arch_type == MACH_TYPE_EZX_A1200)
+#else
+# define machine_is_ezx_a1200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EZX_E6
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EZX_E6
+# endif
+# define machine_is_ezx_e6()	(machine_arch_type == MACH_TYPE_EZX_E6)
+#else
+# define machine_is_ezx_e6()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EZX_E2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EZX_E2
+# endif
+# define machine_is_ezx_e2()	(machine_arch_type == MACH_TYPE_EZX_E2)
+#else
+# define machine_is_ezx_e2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EZX_A910
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EZX_A910
+# endif
+# define machine_is_ezx_a910()	(machine_arch_type == MACH_TYPE_EZX_A910)
+#else
+# define machine_is_ezx_a910()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CWMX31
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CWMX31
+# endif
+# define machine_is_cwmx31()	(machine_arch_type == MACH_TYPE_CWMX31)
+#else
+# define machine_is_cwmx31()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SL2312
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SL2312
+# endif
+# define machine_is_sl2312()	(machine_arch_type == MACH_TYPE_SL2312)
+#else
+# define machine_is_sl2312()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BLENNY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BLENNY
+# endif
+# define machine_is_blenny()	(machine_arch_type == MACH_TYPE_BLENNY)
+#else
+# define machine_is_blenny()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DS107
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DS107
+# endif
+# define machine_is_ds107()	(machine_arch_type == MACH_TYPE_DS107)
+#else
+# define machine_is_ds107()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DSX07
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DSX07
+# endif
+# define machine_is_dsx07()	(machine_arch_type == MACH_TYPE_DSX07)
+#else
+# define machine_is_dsx07()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PICOCOM1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PICOCOM1
+# endif
+# define machine_is_picocom1()	(machine_arch_type == MACH_TYPE_PICOCOM1)
+#else
+# define machine_is_picocom1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LYNX_WOLVERINE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LYNX_WOLVERINE
+# endif
+# define machine_is_lynx_wolverine()	(machine_arch_type == MACH_TYPE_LYNX_WOLVERINE)
+#else
+# define machine_is_lynx_wolverine()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UBISYS_P9_SC19
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UBISYS_P9_SC19
+# endif
+# define machine_is_ubisys_p9_sc19()	(machine_arch_type == MACH_TYPE_UBISYS_P9_SC19)
+#else
+# define machine_is_ubisys_p9_sc19()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KRATOS_LOW
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KRATOS_LOW
+# endif
+# define machine_is_kratos_low()	(machine_arch_type == MACH_TYPE_KRATOS_LOW)
+#else
+# define machine_is_kratos_low()	(0)
+#endif
+
+#ifdef CONFIG_MACH_M700
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_M700
+# endif
+# define machine_is_m700()	(machine_arch_type == MACH_TYPE_M700)
+#else
+# define machine_is_m700()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDMINI_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDMINI_V2
+# endif
+# define machine_is_edmini_v2()	(machine_arch_type == MACH_TYPE_EDMINI_V2)
+#else
+# define machine_is_edmini_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZIPIT2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZIPIT2
+# endif
+# define machine_is_zipit2()	(machine_arch_type == MACH_TYPE_ZIPIT2)
+#else
+# define machine_is_zipit2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HSLFEMTOCELL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HSLFEMTOCELL
+# endif
+# define machine_is_hslfemtocell()	(machine_arch_type == MACH_TYPE_HSLFEMTOCELL)
+#else
+# define machine_is_hslfemtocell()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAINTREE_AT91
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAINTREE_AT91
+# endif
+# define machine_is_daintree_at91()	(machine_arch_type == MACH_TYPE_DAINTREE_AT91)
+#else
+# define machine_is_daintree_at91()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SG560USB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SG560USB
+# endif
+# define machine_is_sg560usb()	(machine_arch_type == MACH_TYPE_SG560USB)
+#else
+# define machine_is_sg560usb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3_PANDORA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3_PANDORA
+# endif
+# define machine_is_omap3_pandora()	(machine_arch_type == MACH_TYPE_OMAP3_PANDORA)
+#else
+# define machine_is_omap3_pandora()	(0)
+#endif
+
+#ifdef CONFIG_MACH_USR8200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_USR8200
+# endif
+# define machine_is_usr8200()	(machine_arch_type == MACH_TYPE_USR8200)
+#else
+# define machine_is_usr8200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_S1S65K
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S1S65K
+# endif
+# define machine_is_s1s65k()	(machine_arch_type == MACH_TYPE_S1S65K)
+#else
+# define machine_is_s1s65k()	(0)
+#endif
+
+#ifdef CONFIG_MACH_S2S65A
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S2S65A
+# endif
+# define machine_is_s2s65a()	(machine_arch_type == MACH_TYPE_S2S65A)
+#else
+# define machine_is_s2s65a()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ICORE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ICORE
+# endif
+# define machine_is_icore()	(machine_arch_type == MACH_TYPE_ICORE)
+#else
+# define machine_is_icore()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSS2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSS2
+# endif
+# define machine_is_mss2()	(machine_arch_type == MACH_TYPE_MSS2)
+#else
+# define machine_is_mss2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BELMONT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BELMONT
+# endif
+# define machine_is_belmont()	(machine_arch_type == MACH_TYPE_BELMONT)
+#else
+# define machine_is_belmont()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ASUSP525
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ASUSP525
+# endif
+# define machine_is_asusp525()	(machine_arch_type == MACH_TYPE_ASUSP525)
+#else
+# define machine_is_asusp525()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LB88RC8480
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LB88RC8480
+# endif
+# define machine_is_lb88rc8480()	(machine_arch_type == MACH_TYPE_LB88RC8480)
+#else
+# define machine_is_lb88rc8480()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HIPXA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HIPXA
+# endif
+# define machine_is_hipxa()	(machine_arch_type == MACH_TYPE_HIPXA)
+#else
+# define machine_is_hipxa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX25_3DS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX25_3DS
+# endif
+# define machine_is_mx25_3ds()	(machine_arch_type == MACH_TYPE_MX25_3DS)
+#else
+# define machine_is_mx25_3ds()	(0)
+#endif
+
+#ifdef CONFIG_MACH_M800
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_M800
+# endif
+# define machine_is_m800()	(machine_arch_type == MACH_TYPE_M800)
+#else
+# define machine_is_m800()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3530_LV_SOM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3530_LV_SOM
+# endif
+# define machine_is_omap3530_lv_som()	(machine_arch_type == MACH_TYPE_OMAP3530_LV_SOM)
+#else
+# define machine_is_omap3530_lv_som()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PRIMA_EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PRIMA_EVB
+# endif
+# define machine_is_prima_evb()	(machine_arch_type == MACH_TYPE_PRIMA_EVB)
+#else
+# define machine_is_prima_evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX31BT1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX31BT1
+# endif
+# define machine_is_mx31bt1()	(machine_arch_type == MACH_TYPE_MX31BT1)
+#else
+# define machine_is_mx31bt1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ATLAS4_EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ATLAS4_EVB
+# endif
+# define machine_is_atlas4_evb()	(machine_arch_type == MACH_TYPE_ATLAS4_EVB)
+#else
+# define machine_is_atlas4_evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX31CICADA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX31CICADA
+# endif
+# define machine_is_mx31cicada()	(machine_arch_type == MACH_TYPE_MX31CICADA)
+#else
+# define machine_is_mx31cicada()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MI424WR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MI424WR
+# endif
+# define machine_is_mi424wr()	(machine_arch_type == MACH_TYPE_MI424WR)
+#else
+# define machine_is_mi424wr()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AXS_ULTRAX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AXS_ULTRAX
+# endif
+# define machine_is_axs_ultrax()	(machine_arch_type == MACH_TYPE_AXS_ULTRAX)
+#else
+# define machine_is_axs_ultrax()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT572D940DEB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT572D940DEB
+# endif
+# define machine_is_at572d940deb()	(machine_arch_type == MACH_TYPE_AT572D940DEB)
+#else
+# define machine_is_at572d940deb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_DA8XX_EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_DA8XX_EVM
+# endif
+# define machine_is_davinci_da8xx_evm()	(machine_arch_type == MACH_TYPE_DAVINCI_DA8XX_EVM)
+#else
+# define machine_is_davinci_da8xx_evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EP9302
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EP9302
+# endif
+# define machine_is_ep9302()	(machine_arch_type == MACH_TYPE_EP9302)
+#else
+# define machine_is_ep9302()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT572D940HFEB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT572D940HFEB
+# endif
+# define machine_is_at572d940hfek()	(machine_arch_type == MACH_TYPE_AT572D940HFEB)
+#else
+# define machine_is_at572d940hfek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CYBOOK3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CYBOOK3
+# endif
+# define machine_is_cybook3()	(machine_arch_type == MACH_TYPE_CYBOOK3)
+#else
+# define machine_is_cybook3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WDG002
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WDG002
+# endif
+# define machine_is_wdg002()	(machine_arch_type == MACH_TYPE_WDG002)
+#else
+# define machine_is_wdg002()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SG560ADSL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SG560ADSL
+# endif
+# define machine_is_sg560adsl()	(machine_arch_type == MACH_TYPE_SG560ADSL)
+#else
+# define machine_is_sg560adsl()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NEXTIO_N2800_ICA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEXTIO_N2800_ICA
+# endif
+# define machine_is_nextio_n2800_ica()	(machine_arch_type == MACH_TYPE_NEXTIO_N2800_ICA)
+#else
+# define machine_is_nextio_n2800_ica()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MARVELL_NEWDB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MARVELL_NEWDB
+# endif
+# define machine_is_marvell_newdb()	(machine_arch_type == MACH_TYPE_MARVELL_NEWDB)
+#else
+# define machine_is_marvell_newdb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VANDIHUD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VANDIHUD
+# endif
+# define machine_is_vandihud()	(machine_arch_type == MACH_TYPE_VANDIHUD)
+#else
+# define machine_is_vandihud()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAGX_E8
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAGX_E8
+# endif
+# define machine_is_magx_e8()	(machine_arch_type == MACH_TYPE_MAGX_E8)
+#else
+# define machine_is_magx_e8()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAGX_Z6
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAGX_Z6
+# endif
+# define machine_is_magx_z6()	(machine_arch_type == MACH_TYPE_MAGX_Z6)
+#else
+# define machine_is_magx_z6()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAGX_V8
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAGX_V8
+# endif
+# define machine_is_magx_v8()	(machine_arch_type == MACH_TYPE_MAGX_V8)
+#else
+# define machine_is_magx_v8()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAGX_U9
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAGX_U9
+# endif
+# define machine_is_magx_u9()	(machine_arch_type == MACH_TYPE_MAGX_U9)
+#else
+# define machine_is_magx_u9()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TOUGHCF08
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TOUGHCF08
+# endif
+# define machine_is_toughcf08()	(machine_arch_type == MACH_TYPE_TOUGHCF08)
+#else
+# define machine_is_toughcf08()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZW4400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZW4400
+# endif
+# define machine_is_zw4400()	(machine_arch_type == MACH_TYPE_ZW4400)
+#else
+# define machine_is_zw4400()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MARAT91
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MARAT91
+# endif
+# define machine_is_marat91()	(machine_arch_type == MACH_TYPE_MARAT91)
+#else
+# define machine_is_marat91()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OVERO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OVERO
+# endif
+# define machine_is_overo()	(machine_arch_type == MACH_TYPE_OVERO)
+#else
+# define machine_is_overo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT2440EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT2440EVB
+# endif
+# define machine_is_at2440evb()	(machine_arch_type == MACH_TYPE_AT2440EVB)
+#else
+# define machine_is_at2440evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NEOCORE926
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEOCORE926
+# endif
+# define machine_is_neocore926()	(machine_arch_type == MACH_TYPE_NEOCORE926)
+#else
+# define machine_is_neocore926()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WNR854T
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WNR854T
+# endif
+# define machine_is_wnr854t()	(machine_arch_type == MACH_TYPE_WNR854T)
+#else
+# define machine_is_wnr854t()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IMX27
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IMX27
+# endif
+# define machine_is_imx27()	(machine_arch_type == MACH_TYPE_IMX27)
+#else
+# define machine_is_imx27()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MOOSE_DB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MOOSE_DB
+# endif
+# define machine_is_moose_db()	(machine_arch_type == MACH_TYPE_MOOSE_DB)
+#else
+# define machine_is_moose_db()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FAB4
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FAB4
+# endif
+# define machine_is_fab4()	(machine_arch_type == MACH_TYPE_FAB4)
+#else
+# define machine_is_fab4()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCDIAMOND
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCDIAMOND
+# endif
+# define machine_is_htcdiamond()	(machine_arch_type == MACH_TYPE_HTCDIAMOND)
+#else
+# define machine_is_htcdiamond()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FIONA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FIONA
+# endif
+# define machine_is_fiona()	(machine_arch_type == MACH_TYPE_FIONA)
+#else
+# define machine_is_fiona()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MXC30030_X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MXC30030_X
+# endif
+# define machine_is_mxc30030_x()	(machine_arch_type == MACH_TYPE_MXC30030_X)
+#else
+# define machine_is_mxc30030_x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BMP1000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BMP1000
+# endif
+# define machine_is_bmp1000()	(machine_arch_type == MACH_TYPE_BMP1000)
+#else
+# define machine_is_bmp1000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LOGI9200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LOGI9200
+# endif
+# define machine_is_logi9200()	(machine_arch_type == MACH_TYPE_LOGI9200)
+#else
+# define machine_is_logi9200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TQMA31
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TQMA31
+# endif
+# define machine_is_tqma31()	(machine_arch_type == MACH_TYPE_TQMA31)
+#else
+# define machine_is_tqma31()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CCW9P9215JS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CCW9P9215JS
+# endif
+# define machine_is_ccw9p9215js()	(machine_arch_type == MACH_TYPE_CCW9P9215JS)
+#else
+# define machine_is_ccw9p9215js()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RD88F5181L_GE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RD88F5181L_GE
+# endif
+# define machine_is_rd88f5181l_ge()	(machine_arch_type == MACH_TYPE_RD88F5181L_GE)
+#else
+# define machine_is_rd88f5181l_ge()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SIFMAIN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SIFMAIN
+# endif
+# define machine_is_sifmain()	(machine_arch_type == MACH_TYPE_SIFMAIN)
+#else
+# define machine_is_sifmain()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SAM9_L9261
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SAM9_L9261
+# endif
+# define machine_is_sam9_l9261()	(machine_arch_type == MACH_TYPE_SAM9_L9261)
+#else
+# define machine_is_sam9_l9261()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CC9M2443JS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CC9M2443JS
+# endif
+# define machine_is_cc9m2443js()	(machine_arch_type == MACH_TYPE_CC9M2443JS)
+#else
+# define machine_is_cc9m2443js()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XARIA300
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XARIA300
+# endif
+# define machine_is_xaria300()	(machine_arch_type == MACH_TYPE_XARIA300)
+#else
+# define machine_is_xaria300()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IT9200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IT9200
+# endif
+# define machine_is_it9200()	(machine_arch_type == MACH_TYPE_IT9200)
+#else
+# define machine_is_it9200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RD88F5181L_FXO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RD88F5181L_FXO
+# endif
+# define machine_is_rd88f5181l_fxo()	(machine_arch_type == MACH_TYPE_RD88F5181L_FXO)
+#else
+# define machine_is_rd88f5181l_fxo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KRISS_SENSOR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KRISS_SENSOR
+# endif
+# define machine_is_kriss_sensor()	(machine_arch_type == MACH_TYPE_KRISS_SENSOR)
+#else
+# define machine_is_kriss_sensor()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PILZ_PMI5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PILZ_PMI5
+# endif
+# define machine_is_pilz_pmi5()	(machine_arch_type == MACH_TYPE_PILZ_PMI5)
+#else
+# define machine_is_pilz_pmi5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_JADE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JADE
+# endif
+# define machine_is_jade()	(machine_arch_type == MACH_TYPE_JADE)
+#else
+# define machine_is_jade()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KS8695_SOFTPLC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KS8695_SOFTPLC
+# endif
+# define machine_is_ks8695_softplc()	(machine_arch_type == MACH_TYPE_KS8695_SOFTPLC)
+#else
+# define machine_is_ks8695_softplc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GPRISC3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GPRISC3
+# endif
+# define machine_is_gprisc3()	(machine_arch_type == MACH_TYPE_GPRISC3)
+#else
+# define machine_is_gprisc3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STAMP9G20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STAMP9G20
+# endif
+# define machine_is_stamp9g20()	(machine_arch_type == MACH_TYPE_STAMP9G20)
+#else
+# define machine_is_stamp9g20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK6430
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK6430
+# endif
+# define machine_is_smdk6430()	(machine_arch_type == MACH_TYPE_SMDK6430)
+#else
+# define machine_is_smdk6430()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDKC100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDKC100
+# endif
+# define machine_is_smdkc100()	(machine_arch_type == MACH_TYPE_SMDKC100)
+#else
+# define machine_is_smdkc100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TAVOREVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TAVOREVB
+# endif
+# define machine_is_tavorevb()	(machine_arch_type == MACH_TYPE_TAVOREVB)
+#else
+# define machine_is_tavorevb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SAAR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SAAR
+# endif
+# define machine_is_saar()	(machine_arch_type == MACH_TYPE_SAAR)
+#else
+# define machine_is_saar()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DEISTER_EYECAM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DEISTER_EYECAM
+# endif
+# define machine_is_deister_eyecam()	(machine_arch_type == MACH_TYPE_DEISTER_EYECAM)
+#else
+# define machine_is_deister_eyecam()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9M10G45EK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9M10G45EK
+# endif
+# define machine_is_at91sam9m10g45ek()	(machine_arch_type == MACH_TYPE_AT91SAM9M10G45EK)
+#else
+# define machine_is_at91sam9m10g45ek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LINKSTATION_PRODUO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LINKSTATION_PRODUO
+# endif
+# define machine_is_linkstation_produo()	(machine_arch_type == MACH_TYPE_LINKSTATION_PRODUO)
+#else
+# define machine_is_linkstation_produo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HIT_B0
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HIT_B0
+# endif
+# define machine_is_hit_b0()	(machine_arch_type == MACH_TYPE_HIT_B0)
+#else
+# define machine_is_hit_b0()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ADX_RMU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADX_RMU
+# endif
+# define machine_is_adx_rmu()	(machine_arch_type == MACH_TYPE_ADX_RMU)
+#else
+# define machine_is_adx_rmu()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XG_CPE_MAIN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XG_CPE_MAIN
+# endif
+# define machine_is_xg_cpe_main()	(machine_arch_type == MACH_TYPE_XG_CPE_MAIN)
+#else
+# define machine_is_xg_cpe_main()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDB9407A
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDB9407A
+# endif
+# define machine_is_edb9407a()	(machine_arch_type == MACH_TYPE_EDB9407A)
+#else
+# define machine_is_edb9407a()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DTB9608
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DTB9608
+# endif
+# define machine_is_dtb9608()	(machine_arch_type == MACH_TYPE_DTB9608)
+#else
+# define machine_is_dtb9608()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EM104V1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EM104V1
+# endif
+# define machine_is_em104v1()	(machine_arch_type == MACH_TYPE_EM104V1)
+#else
+# define machine_is_em104v1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DEMO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DEMO
+# endif
+# define machine_is_demo()	(machine_arch_type == MACH_TYPE_DEMO)
+#else
+# define machine_is_demo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LOGI9260
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LOGI9260
+# endif
+# define machine_is_logi9260()	(machine_arch_type == MACH_TYPE_LOGI9260)
+#else
+# define machine_is_logi9260()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX31_EXM32
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX31_EXM32
+# endif
+# define machine_is_mx31_exm32()	(machine_arch_type == MACH_TYPE_MX31_EXM32)
+#else
+# define machine_is_mx31_exm32()	(0)
+#endif
+
+#ifdef CONFIG_MACH_USB_A9G20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_USB_A9G20
+# endif
+# define machine_is_usb_a9g20()	(machine_arch_type == MACH_TYPE_USB_A9G20)
+#else
+# define machine_is_usb_a9g20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PICPROJE2008
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PICPROJE2008
+# endif
+# define machine_is_picproje2008()	(machine_arch_type == MACH_TYPE_PICPROJE2008)
+#else
+# define machine_is_picproje2008()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CS_E9315
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CS_E9315
+# endif
+# define machine_is_cs_e9315()	(machine_arch_type == MACH_TYPE_CS_E9315)
+#else
+# define machine_is_cs_e9315()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QIL_A9G20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QIL_A9G20
+# endif
+# define machine_is_qil_a9g20()	(machine_arch_type == MACH_TYPE_QIL_A9G20)
+#else
+# define machine_is_qil_a9g20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SHA_PON020
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHA_PON020
+# endif
+# define machine_is_sha_pon020()	(machine_arch_type == MACH_TYPE_SHA_PON020)
+#else
+# define machine_is_sha_pon020()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NAD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NAD
+# endif
+# define machine_is_nad()	(machine_arch_type == MACH_TYPE_NAD)
+#else
+# define machine_is_nad()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SBC35_A9260
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SBC35_A9260
+# endif
+# define machine_is_sbc35_a9260()	(machine_arch_type == MACH_TYPE_SBC35_A9260)
+#else
+# define machine_is_sbc35_a9260()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SBC35_A9G20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SBC35_A9G20
+# endif
+# define machine_is_sbc35_a9g20()	(machine_arch_type == MACH_TYPE_SBC35_A9G20)
+#else
+# define machine_is_sbc35_a9g20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_BEGINNING
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_BEGINNING
+# endif
+# define machine_is_davinci_beginning()	(machine_arch_type == MACH_TYPE_DAVINCI_BEGINNING)
+#else
+# define machine_is_davinci_beginning()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UWC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UWC
+# endif
+# define machine_is_uwc()	(machine_arch_type == MACH_TYPE_UWC)
+#else
+# define machine_is_uwc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MXLADS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MXLADS
+# endif
+# define machine_is_mxlads()	(machine_arch_type == MACH_TYPE_MXLADS)
+#else
+# define machine_is_mxlads()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCNIKE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCNIKE
+# endif
+# define machine_is_htcnike()	(machine_arch_type == MACH_TYPE_HTCNIKE)
+#else
+# define machine_is_htcnike()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DEISTER_PXA270
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DEISTER_PXA270
+# endif
+# define machine_is_deister_pxa270()	(machine_arch_type == MACH_TYPE_DEISTER_PXA270)
+#else
+# define machine_is_deister_pxa270()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CME9210JS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CME9210JS
+# endif
+# define machine_is_cme9210js()	(machine_arch_type == MACH_TYPE_CME9210JS)
+#else
+# define machine_is_cme9210js()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CC9P9360
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CC9P9360
+# endif
+# define machine_is_cc9p9360()	(machine_arch_type == MACH_TYPE_CC9P9360)
+#else
+# define machine_is_cc9p9360()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MOCHA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MOCHA
+# endif
+# define machine_is_mocha()	(machine_arch_type == MACH_TYPE_MOCHA)
+#else
+# define machine_is_mocha()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WAPD170AG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WAPD170AG
+# endif
+# define machine_is_wapd170ag()	(machine_arch_type == MACH_TYPE_WAPD170AG)
+#else
+# define machine_is_wapd170ag()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LINKSTATION_MINI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LINKSTATION_MINI
+# endif
+# define machine_is_linkstation_mini()	(machine_arch_type == MACH_TYPE_LINKSTATION_MINI)
+#else
+# define machine_is_linkstation_mini()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AFEB9260
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AFEB9260
+# endif
+# define machine_is_afeb9260()	(machine_arch_type == MACH_TYPE_AFEB9260)
+#else
+# define machine_is_afeb9260()	(0)
+#endif
+
+#ifdef CONFIG_MACH_W90X900
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_W90X900
+# endif
+# define machine_is_w90x900()	(machine_arch_type == MACH_TYPE_W90X900)
+#else
+# define machine_is_w90x900()	(0)
+#endif
+
+#ifdef CONFIG_MACH_W90X700
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_W90X700
+# endif
+# define machine_is_w90x700()	(machine_arch_type == MACH_TYPE_W90X700)
+#else
+# define machine_is_w90x700()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KT300IP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KT300IP
+# endif
+# define machine_is_kt300ip()	(machine_arch_type == MACH_TYPE_KT300IP)
+#else
+# define machine_is_kt300ip()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KT300IP_G20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KT300IP_G20
+# endif
+# define machine_is_kt300ip_g20()	(machine_arch_type == MACH_TYPE_KT300IP_G20)
+#else
+# define machine_is_kt300ip_g20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SRCM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SRCM
+# endif
+# define machine_is_srcm()	(machine_arch_type == MACH_TYPE_SRCM)
+#else
+# define machine_is_srcm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WLNX_9260
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WLNX_9260
+# endif
+# define machine_is_wlnx_9260()	(machine_arch_type == MACH_TYPE_WLNX_9260)
+#else
+# define machine_is_wlnx_9260()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OPENMOKO_GTA03
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OPENMOKO_GTA03
+# endif
+# define machine_is_openmoko_gta03()	(machine_arch_type == MACH_TYPE_OPENMOKO_GTA03)
+#else
+# define machine_is_openmoko_gta03()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OSPREY2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OSPREY2
+# endif
+# define machine_is_osprey2()	(machine_arch_type == MACH_TYPE_OSPREY2)
+#else
+# define machine_is_osprey2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KBIO9260
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KBIO9260
+# endif
+# define machine_is_kbio9260()	(machine_arch_type == MACH_TYPE_KBIO9260)
+#else
+# define machine_is_kbio9260()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GINZA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GINZA
+# endif
+# define machine_is_ginza()	(machine_arch_type == MACH_TYPE_GINZA)
+#else
+# define machine_is_ginza()	(0)
+#endif
+
+#ifdef CONFIG_MACH_A636N
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_A636N
+# endif
+# define machine_is_a636n()	(machine_arch_type == MACH_TYPE_A636N)
+#else
+# define machine_is_a636n()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IMX27IPCAM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IMX27IPCAM
+# endif
+# define machine_is_imx27ipcam()	(machine_arch_type == MACH_TYPE_IMX27IPCAM)
+#else
+# define machine_is_imx27ipcam()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NEMOC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEMOC
+# endif
+# define machine_is_nemoc()	(machine_arch_type == MACH_TYPE_NEMOC)
+#else
+# define machine_is_nemoc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GENEVA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GENEVA
+# endif
+# define machine_is_geneva()	(machine_arch_type == MACH_TYPE_GENEVA)
+#else
+# define machine_is_geneva()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCPHAROS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCPHAROS
+# endif
+# define machine_is_htcpharos()	(machine_arch_type == MACH_TYPE_HTCPHAROS)
+#else
+# define machine_is_htcpharos()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NEONC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NEONC
+# endif
+# define machine_is_neonc()	(machine_arch_type == MACH_TYPE_NEONC)
+#else
+# define machine_is_neonc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NAS7100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NAS7100
+# endif
+# define machine_is_nas7100()	(machine_arch_type == MACH_TYPE_NAS7100)
+#else
+# define machine_is_nas7100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TEUPHONE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TEUPHONE
+# endif
+# define machine_is_teuphone()	(machine_arch_type == MACH_TYPE_TEUPHONE)
+#else
+# define machine_is_teuphone()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ANNAX_ETH2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ANNAX_ETH2
+# endif
+# define machine_is_annax_eth2()	(machine_arch_type == MACH_TYPE_ANNAX_ETH2)
+#else
+# define machine_is_annax_eth2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CSB733
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CSB733
+# endif
+# define machine_is_csb733()	(machine_arch_type == MACH_TYPE_CSB733)
+#else
+# define machine_is_csb733()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BK3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BK3
+# endif
+# define machine_is_bk3()	(machine_arch_type == MACH_TYPE_BK3)
+#else
+# define machine_is_bk3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_EM32
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_EM32
+# endif
+# define machine_is_omap_em32()	(machine_arch_type == MACH_TYPE_OMAP_EM32)
+#else
+# define machine_is_omap_em32()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ET9261CP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ET9261CP
+# endif
+# define machine_is_et9261cp()	(machine_arch_type == MACH_TYPE_ET9261CP)
+#else
+# define machine_is_et9261cp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_JASPERC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JASPERC
+# endif
+# define machine_is_jasperc()	(machine_arch_type == MACH_TYPE_JASPERC)
+#else
+# define machine_is_jasperc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ISSI_ARM9
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ISSI_ARM9
+# endif
+# define machine_is_issi_arm9()	(machine_arch_type == MACH_TYPE_ISSI_ARM9)
+#else
+# define machine_is_issi_arm9()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UED
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UED
+# endif
+# define machine_is_ued()	(machine_arch_type == MACH_TYPE_UED)
+#else
+# define machine_is_ued()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ESIBLADE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ESIBLADE
+# endif
+# define machine_is_esiblade()	(machine_arch_type == MACH_TYPE_ESIBLADE)
+#else
+# define machine_is_esiblade()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EYE02
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EYE02
+# endif
+# define machine_is_eye02()	(machine_arch_type == MACH_TYPE_EYE02)
+#else
+# define machine_is_eye02()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IMX27KBD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IMX27KBD
+# endif
+# define machine_is_imx27kbd()	(machine_arch_type == MACH_TYPE_IMX27KBD)
+#else
+# define machine_is_imx27kbd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SST61VC010_FPGA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SST61VC010_FPGA
+# endif
+# define machine_is_sst61vc010_fpga()	(machine_arch_type == MACH_TYPE_SST61VC010_FPGA)
+#else
+# define machine_is_sst61vc010_fpga()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KIXVP435
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KIXVP435
+# endif
+# define machine_is_kixvp435()	(machine_arch_type == MACH_TYPE_KIXVP435)
+#else
+# define machine_is_kixvp435()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KIXNP435
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KIXNP435
+# endif
+# define machine_is_kixnp435()	(machine_arch_type == MACH_TYPE_KIXNP435)
+#else
+# define machine_is_kixnp435()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AFRICA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AFRICA
+# endif
+# define machine_is_africa()	(machine_arch_type == MACH_TYPE_AFRICA)
+#else
+# define machine_is_africa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NH233
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NH233
+# endif
+# define machine_is_nh233()	(machine_arch_type == MACH_TYPE_NH233)
+#else
+# define machine_is_nh233()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RD88F6183AP_GE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RD88F6183AP_GE
+# endif
+# define machine_is_rd88f6183ap_ge()	(machine_arch_type == MACH_TYPE_RD88F6183AP_GE)
+#else
+# define machine_is_rd88f6183ap_ge()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BCM4760
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BCM4760
+# endif
+# define machine_is_bcm4760()	(machine_arch_type == MACH_TYPE_BCM4760)
+#else
+# define machine_is_bcm4760()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDDY_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDDY_V2
+# endif
+# define machine_is_eddy_v2()	(machine_arch_type == MACH_TYPE_EDDY_V2)
+#else
+# define machine_is_eddy_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_REALVIEW_PBA8
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_REALVIEW_PBA8
+# endif
+# define machine_is_realview_pba8()	(machine_arch_type == MACH_TYPE_REALVIEW_PBA8)
+#else
+# define machine_is_realview_pba8()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HID_A7
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HID_A7
+# endif
+# define machine_is_hid_a7()	(machine_arch_type == MACH_TYPE_HID_A7)
+#else
+# define machine_is_hid_a7()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HERO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HERO
+# endif
+# define machine_is_hero()	(machine_arch_type == MACH_TYPE_HERO)
+#else
+# define machine_is_hero()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_POSEIDON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_POSEIDON
+# endif
+# define machine_is_omap_poseidon()	(machine_arch_type == MACH_TYPE_OMAP_POSEIDON)
+#else
+# define machine_is_omap_poseidon()	(0)
+#endif
+
+#ifdef CONFIG_MACH_REALVIEW_PBX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_REALVIEW_PBX
+# endif
+# define machine_is_realview_pbx()	(machine_arch_type == MACH_TYPE_REALVIEW_PBX)
+#else
+# define machine_is_realview_pbx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MICRO9S
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MICRO9S
+# endif
+# define machine_is_micro9s()	(machine_arch_type == MACH_TYPE_MICRO9S)
+#else
+# define machine_is_micro9s()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAKO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAKO
+# endif
+# define machine_is_mako()	(machine_arch_type == MACH_TYPE_MAKO)
+#else
+# define machine_is_mako()	(0)
+#endif
+
+#ifdef CONFIG_MACH_XDAFLAME
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_XDAFLAME
+# endif
+# define machine_is_xdaflame()	(machine_arch_type == MACH_TYPE_XDAFLAME)
+#else
+# define machine_is_xdaflame()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PHIDGET_SBC2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PHIDGET_SBC2
+# endif
+# define machine_is_phidget_sbc2()	(machine_arch_type == MACH_TYPE_PHIDGET_SBC2)
+#else
+# define machine_is_phidget_sbc2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LIMESTONE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LIMESTONE
+# endif
+# define machine_is_limestone()	(machine_arch_type == MACH_TYPE_LIMESTONE)
+#else
+# define machine_is_limestone()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IPROBE_C32
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IPROBE_C32
+# endif
+# define machine_is_iprobe_c32()	(machine_arch_type == MACH_TYPE_IPROBE_C32)
+#else
+# define machine_is_iprobe_c32()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RUT100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RUT100
+# endif
+# define machine_is_rut100()	(machine_arch_type == MACH_TYPE_RUT100)
+#else
+# define machine_is_rut100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ASUSP535
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ASUSP535
+# endif
+# define machine_is_asusp535()	(machine_arch_type == MACH_TYPE_ASUSP535)
+#else
+# define machine_is_asusp535()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCRAPHAEL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCRAPHAEL
+# endif
+# define machine_is_htcraphael()	(machine_arch_type == MACH_TYPE_HTCRAPHAEL)
+#else
+# define machine_is_htcraphael()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SYGDG1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SYGDG1
+# endif
+# define machine_is_sygdg1()	(machine_arch_type == MACH_TYPE_SYGDG1)
+#else
+# define machine_is_sygdg1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SYGDG2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SYGDG2
+# endif
+# define machine_is_sygdg2()	(machine_arch_type == MACH_TYPE_SYGDG2)
+#else
+# define machine_is_sygdg2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SEOUL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SEOUL
+# endif
+# define machine_is_seoul()	(machine_arch_type == MACH_TYPE_SEOUL)
+#else
+# define machine_is_seoul()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SALERNO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SALERNO
+# endif
+# define machine_is_salerno()	(machine_arch_type == MACH_TYPE_SALERNO)
+#else
+# define machine_is_salerno()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UCN_S3C64XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UCN_S3C64XX
+# endif
+# define machine_is_ucn_s3c64xx()	(machine_arch_type == MACH_TYPE_UCN_S3C64XX)
+#else
+# define machine_is_ucn_s3c64xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MSM7201A
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MSM7201A
+# endif
+# define machine_is_msm7201a()	(machine_arch_type == MACH_TYPE_MSM7201A)
+#else
+# define machine_is_msm7201a()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LPR1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LPR1
+# endif
+# define machine_is_lpr1()	(machine_arch_type == MACH_TYPE_LPR1)
+#else
+# define machine_is_lpr1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARMADILLO500FX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARMADILLO500FX
+# endif
+# define machine_is_armadillo500fx()	(machine_arch_type == MACH_TYPE_ARMADILLO500FX)
+#else
+# define machine_is_armadillo500fx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_G3EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_G3EVM
+# endif
+# define machine_is_g3evm()	(machine_arch_type == MACH_TYPE_G3EVM)
+#else
+# define machine_is_g3evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_Z3_DM355
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_Z3_DM355
+# endif
+# define machine_is_z3_dm355()	(machine_arch_type == MACH_TYPE_Z3_DM355)
+#else
+# define machine_is_z3_dm355()	(0)
+#endif
+
+#ifdef CONFIG_MACH_W90P910EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_W90P910EVB
+# endif
+# define machine_is_w90p910evb()	(machine_arch_type == MACH_TYPE_W90P910EVB)
+#else
+# define machine_is_w90p910evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_W90P920EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_W90P920EVB
+# endif
+# define machine_is_w90p920evb()	(machine_arch_type == MACH_TYPE_W90P920EVB)
+#else
+# define machine_is_w90p920evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_W90P950EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_W90P950EVB
+# endif
+# define machine_is_w90p950evb()	(machine_arch_type == MACH_TYPE_W90P950EVB)
+#else
+# define machine_is_w90p950evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_W90N960EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_W90N960EVB
+# endif
+# define machine_is_w90n960evb()	(machine_arch_type == MACH_TYPE_W90N960EVB)
+#else
+# define machine_is_w90n960evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CAMHD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CAMHD
+# endif
+# define machine_is_camhd()	(machine_arch_type == MACH_TYPE_CAMHD)
+#else
+# define machine_is_camhd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MVC100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MVC100
+# endif
+# define machine_is_mvc100()	(machine_arch_type == MACH_TYPE_MVC100)
+#else
+# define machine_is_mvc100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ELECTRUM_200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ELECTRUM_200
+# endif
+# define machine_is_electrum_200()	(machine_arch_type == MACH_TYPE_ELECTRUM_200)
+#else
+# define machine_is_electrum_200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCJADE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCJADE
+# endif
+# define machine_is_htcjade()	(machine_arch_type == MACH_TYPE_HTCJADE)
+#else
+# define machine_is_htcjade()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MEMPHIS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MEMPHIS
+# endif
+# define machine_is_memphis()	(machine_arch_type == MACH_TYPE_MEMPHIS)
+#else
+# define machine_is_memphis()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IMX27SBC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IMX27SBC
+# endif
+# define machine_is_imx27sbc()	(machine_arch_type == MACH_TYPE_IMX27SBC)
+#else
+# define machine_is_imx27sbc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LEXTAR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LEXTAR
+# endif
+# define machine_is_lextar()	(machine_arch_type == MACH_TYPE_LEXTAR)
+#else
+# define machine_is_lextar()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MV88F6281GTW_GE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MV88F6281GTW_GE
+# endif
+# define machine_is_mv88f6281gtw_ge()	(machine_arch_type == MACH_TYPE_MV88F6281GTW_GE)
+#else
+# define machine_is_mv88f6281gtw_ge()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NCP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NCP
+# endif
+# define machine_is_ncp()	(machine_arch_type == MACH_TYPE_NCP)
+#else
+# define machine_is_ncp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_Z32AN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_Z32AN
+# endif
+# define machine_is_z32an_series()	(machine_arch_type == MACH_TYPE_Z32AN)
+#else
+# define machine_is_z32an_series()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TMQ_CAPD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TMQ_CAPD
+# endif
+# define machine_is_tmq_capd()	(machine_arch_type == MACH_TYPE_TMQ_CAPD)
+#else
+# define machine_is_tmq_capd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3_WL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3_WL
+# endif
+# define machine_is_omap3_wl()	(machine_arch_type == MACH_TYPE_OMAP3_WL)
+#else
+# define machine_is_omap3_wl()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CHUMBY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CHUMBY
+# endif
+# define machine_is_chumby()	(machine_arch_type == MACH_TYPE_CHUMBY)
+#else
+# define machine_is_chumby()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ATSARM9
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ATSARM9
+# endif
+# define machine_is_atsarm9()	(machine_arch_type == MACH_TYPE_ATSARM9)
+#else
+# define machine_is_atsarm9()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_DM365_EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_DM365_EVM
+# endif
+# define machine_is_davinci_dm365_evm()	(machine_arch_type == MACH_TYPE_DAVINCI_DM365_EVM)
+#else
+# define machine_is_davinci_dm365_evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BAHAMAS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BAHAMAS
+# endif
+# define machine_is_bahamas()	(machine_arch_type == MACH_TYPE_BAHAMAS)
+#else
+# define machine_is_bahamas()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAS
+# endif
+# define machine_is_das()	(machine_arch_type == MACH_TYPE_DAS)
+#else
+# define machine_is_das()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MINIDAS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MINIDAS
+# endif
+# define machine_is_minidas()	(machine_arch_type == MACH_TYPE_MINIDAS)
+#else
+# define machine_is_minidas()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VK1000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VK1000
+# endif
+# define machine_is_vk1000()	(machine_arch_type == MACH_TYPE_VK1000)
+#else
+# define machine_is_vk1000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CENTRO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CENTRO
+# endif
+# define machine_is_centro()	(machine_arch_type == MACH_TYPE_CENTRO)
+#else
+# define machine_is_centro()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CTERA_2BAY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CTERA_2BAY
+# endif
+# define machine_is_ctera_2bay()	(machine_arch_type == MACH_TYPE_CTERA_2BAY)
+#else
+# define machine_is_ctera_2bay()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EDGECONNECT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EDGECONNECT
+# endif
+# define machine_is_edgeconnect()	(machine_arch_type == MACH_TYPE_EDGECONNECT)
+#else
+# define machine_is_edgeconnect()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ND27000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ND27000
+# endif
+# define machine_is_nd27000()	(machine_arch_type == MACH_TYPE_ND27000)
+#else
+# define machine_is_nd27000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GEMALTO_COBRA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GEMALTO_COBRA
+# endif
+# define machine_is_cobra()	(machine_arch_type == MACH_TYPE_GEMALTO_COBRA)
+#else
+# define machine_is_cobra()	(0)
+#endif
+
+#ifdef CONFIG_MACH_INGELABS_COMET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INGELABS_COMET
+# endif
+# define machine_is_ingelabs_comet()	(machine_arch_type == MACH_TYPE_INGELABS_COMET)
+#else
+# define machine_is_ingelabs_comet()	(0)
+#endif
+
+#ifdef CONFIG_MACH_POLLUX_WIZ
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_POLLUX_WIZ
+# endif
+# define machine_is_pollux_wiz()	(machine_arch_type == MACH_TYPE_POLLUX_WIZ)
+#else
+# define machine_is_pollux_wiz()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BLACKSTONE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BLACKSTONE
+# endif
+# define machine_is_blackstone()	(machine_arch_type == MACH_TYPE_BLACKSTONE)
+#else
+# define machine_is_blackstone()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TOPAZ
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TOPAZ
+# endif
+# define machine_is_topaz()	(machine_arch_type == MACH_TYPE_TOPAZ)
+#else
+# define machine_is_topaz()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AIXLE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AIXLE
+# endif
+# define machine_is_aixle()	(machine_arch_type == MACH_TYPE_AIXLE)
+#else
+# define machine_is_aixle()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MW998
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MW998
+# endif
+# define machine_is_mw998()	(machine_arch_type == MACH_TYPE_MW998)
+#else
+# define machine_is_mw998()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NOKIA_RX51
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NOKIA_RX51
+# endif
+# define machine_is_nokia_rx51()	(machine_arch_type == MACH_TYPE_NOKIA_RX51)
+#else
+# define machine_is_nokia_rx51()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VSC5605EV
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VSC5605EV
+# endif
+# define machine_is_vsc5605ev()	(machine_arch_type == MACH_TYPE_VSC5605EV)
+#else
+# define machine_is_vsc5605ev()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NT98700DK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NT98700DK
+# endif
+# define machine_is_nt98700dk()	(machine_arch_type == MACH_TYPE_NT98700DK)
+#else
+# define machine_is_nt98700dk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ICONTACT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ICONTACT
+# endif
+# define machine_is_icontact()	(machine_arch_type == MACH_TYPE_ICONTACT)
+#else
+# define machine_is_icontact()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SWARCO_FRCPU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SWARCO_FRCPU
+# endif
+# define machine_is_swarco_frcpu()	(machine_arch_type == MACH_TYPE_SWARCO_FRCPU)
+#else
+# define machine_is_swarco_frcpu()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SWARCO_SCPU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SWARCO_SCPU
+# endif
+# define machine_is_swarco_scpu()	(machine_arch_type == MACH_TYPE_SWARCO_SCPU)
+#else
+# define machine_is_swarco_scpu()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BBOX_P16
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BBOX_P16
+# endif
+# define machine_is_bbox_p16()	(machine_arch_type == MACH_TYPE_BBOX_P16)
+#else
+# define machine_is_bbox_p16()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BSTD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BSTD
+# endif
+# define machine_is_bstd()	(machine_arch_type == MACH_TYPE_BSTD)
+#else
+# define machine_is_bstd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SBC2440II
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SBC2440II
+# endif
+# define machine_is_sbc2440ii()	(machine_arch_type == MACH_TYPE_SBC2440II)
+#else
+# define machine_is_sbc2440ii()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PCM034
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PCM034
+# endif
+# define machine_is_pcm034()	(machine_arch_type == MACH_TYPE_PCM034)
+#else
+# define machine_is_pcm034()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NESO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NESO
+# endif
+# define machine_is_neso()	(machine_arch_type == MACH_TYPE_NESO)
+#else
+# define machine_is_neso()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WLNX_9G20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WLNX_9G20
+# endif
+# define machine_is_wlnx_9g20()	(machine_arch_type == MACH_TYPE_WLNX_9G20)
+#else
+# define machine_is_wlnx_9g20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_ZOOM2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_ZOOM2
+# endif
+# define machine_is_omap_zoom2()	(machine_arch_type == MACH_TYPE_OMAP_ZOOM2)
+#else
+# define machine_is_omap_zoom2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TOTEMNOVA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TOTEMNOVA
+# endif
+# define machine_is_totemnova()	(machine_arch_type == MACH_TYPE_TOTEMNOVA)
+#else
+# define machine_is_totemnova()	(0)
+#endif
+
+#ifdef CONFIG_MACH_C5000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_C5000
+# endif
+# define machine_is_c5000()	(machine_arch_type == MACH_TYPE_C5000)
+#else
+# define machine_is_c5000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UNIPO_AT91SAM9263
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UNIPO_AT91SAM9263
+# endif
+# define machine_is_unipo_at91sam9263()	(machine_arch_type == MACH_TYPE_UNIPO_AT91SAM9263)
+#else
+# define machine_is_unipo_at91sam9263()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ETHERNUT5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ETHERNUT5
+# endif
+# define machine_is_ethernut5()	(machine_arch_type == MACH_TYPE_ETHERNUT5)
+#else
+# define machine_is_ethernut5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARM11
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARM11
+# endif
+# define machine_is_arm11()	(machine_arch_type == MACH_TYPE_ARM11)
+#else
+# define machine_is_arm11()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CPUAT9260
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CPUAT9260
+# endif
+# define machine_is_cpuat9260()	(machine_arch_type == MACH_TYPE_CPUAT9260)
+#else
+# define machine_is_cpuat9260()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CPUPXA255
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CPUPXA255
+# endif
+# define machine_is_cpupxa255()	(machine_arch_type == MACH_TYPE_CPUPXA255)
+#else
+# define machine_is_cpupxa255()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CPUIMX27
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CPUIMX27
+# endif
+# define machine_is_cpuimx27()	(machine_arch_type == MACH_TYPE_CPUIMX27)
+#else
+# define machine_is_cpuimx27()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CHEFLUX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CHEFLUX
+# endif
+# define machine_is_cheflux()	(machine_arch_type == MACH_TYPE_CHEFLUX)
+#else
+# define machine_is_cheflux()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EB_CPUX9K2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EB_CPUX9K2
+# endif
+# define machine_is_eb_cpux9k2()	(machine_arch_type == MACH_TYPE_EB_CPUX9K2)
+#else
+# define machine_is_eb_cpux9k2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OPCOTEC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OPCOTEC
+# endif
+# define machine_is_opcotec()	(machine_arch_type == MACH_TYPE_OPCOTEC)
+#else
+# define machine_is_opcotec()	(0)
+#endif
+
+#ifdef CONFIG_MACH_YT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_YT
+# endif
+# define machine_is_yt()	(machine_arch_type == MACH_TYPE_YT)
+#else
+# define machine_is_yt()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MOTOQ
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MOTOQ
+# endif
+# define machine_is_motoq()	(machine_arch_type == MACH_TYPE_MOTOQ)
+#else
+# define machine_is_motoq()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BSB1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BSB1
+# endif
+# define machine_is_bsb1()	(machine_arch_type == MACH_TYPE_BSB1)
+#else
+# define machine_is_bsb1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACS5K
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACS5K
+# endif
+# define machine_is_acs5k()	(machine_arch_type == MACH_TYPE_ACS5K)
+#else
+# define machine_is_acs5k()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MILAN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MILAN
+# endif
+# define machine_is_milan()	(machine_arch_type == MACH_TYPE_MILAN)
+#else
+# define machine_is_milan()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QUARTZV2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QUARTZV2
+# endif
+# define machine_is_quartzv2()	(machine_arch_type == MACH_TYPE_QUARTZV2)
+#else
+# define machine_is_quartzv2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RSVP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RSVP
+# endif
+# define machine_is_rsvp()	(machine_arch_type == MACH_TYPE_RSVP)
+#else
+# define machine_is_rsvp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RMP200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RMP200
+# endif
+# define machine_is_rmp200()	(machine_arch_type == MACH_TYPE_RMP200)
+#else
+# define machine_is_rmp200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SNAPPER_9260
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SNAPPER_9260
+# endif
+# define machine_is_snapper_9260()	(machine_arch_type == MACH_TYPE_SNAPPER_9260)
+#else
+# define machine_is_snapper_9260()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DSM320
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DSM320
+# endif
+# define machine_is_dsm320()	(machine_arch_type == MACH_TYPE_DSM320)
+#else
+# define machine_is_dsm320()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ADSGCM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADSGCM
+# endif
+# define machine_is_adsgcm()	(machine_arch_type == MACH_TYPE_ADSGCM)
+#else
+# define machine_is_adsgcm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ASE2_400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ASE2_400
+# endif
+# define machine_is_ase2_400()	(machine_arch_type == MACH_TYPE_ASE2_400)
+#else
+# define machine_is_ase2_400()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PIZZA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PIZZA
+# endif
+# define machine_is_pizza()	(machine_arch_type == MACH_TYPE_PIZZA)
+#else
+# define machine_is_pizza()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPOT_NGPL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPOT_NGPL
+# endif
+# define machine_is_spot_ngpl()	(machine_arch_type == MACH_TYPE_SPOT_NGPL)
+#else
+# define machine_is_spot_ngpl()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARMATA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARMATA
+# endif
+# define machine_is_armata()	(machine_arch_type == MACH_TYPE_ARMATA)
+#else
+# define machine_is_armata()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EXEDA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EXEDA
+# endif
+# define machine_is_exeda()	(machine_arch_type == MACH_TYPE_EXEDA)
+#else
+# define machine_is_exeda()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX31SF005
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX31SF005
+# endif
+# define machine_is_mx31sf005()	(machine_arch_type == MACH_TYPE_MX31SF005)
+#else
+# define machine_is_mx31sf005()	(0)
+#endif
+
+#ifdef CONFIG_MACH_F5D8231_4_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_F5D8231_4_V2
+# endif
+# define machine_is_f5d8231_4_v2()	(machine_arch_type == MACH_TYPE_F5D8231_4_V2)
+#else
+# define machine_is_f5d8231_4_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_Q2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_Q2440
+# endif
+# define machine_is_q2440()	(machine_arch_type == MACH_TYPE_Q2440)
+#else
+# define machine_is_q2440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QQ2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QQ2440
+# endif
+# define machine_is_qq2440()	(machine_arch_type == MACH_TYPE_QQ2440)
+#else
+# define machine_is_qq2440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MINI2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MINI2440
+# endif
+# define machine_is_mini2440()	(machine_arch_type == MACH_TYPE_MINI2440)
+#else
+# define machine_is_mini2440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_COLIBRI300
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_COLIBRI300
+# endif
+# define machine_is_colibri300()	(machine_arch_type == MACH_TYPE_COLIBRI300)
+#else
+# define machine_is_colibri300()	(0)
+#endif
+
+#ifdef CONFIG_MACH_JADES
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JADES
+# endif
+# define machine_is_jades()	(machine_arch_type == MACH_TYPE_JADES)
+#else
+# define machine_is_jades()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPARK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPARK
+# endif
+# define machine_is_spark()	(machine_arch_type == MACH_TYPE_SPARK)
+#else
+# define machine_is_spark()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BENZINA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BENZINA
+# endif
+# define machine_is_benzina()	(machine_arch_type == MACH_TYPE_BENZINA)
+#else
+# define machine_is_benzina()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BLAZE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BLAZE
+# endif
+# define machine_is_blaze()	(machine_arch_type == MACH_TYPE_BLAZE)
+#else
+# define machine_is_blaze()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LINKSTATION_LS_HGL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LINKSTATION_LS_HGL
+# endif
+# define machine_is_linkstation_ls_hgl()	(machine_arch_type == MACH_TYPE_LINKSTATION_LS_HGL)
+#else
+# define machine_is_linkstation_ls_hgl()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCVENUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCVENUS
+# endif
+# define machine_is_htckovsky()	(machine_arch_type == MACH_TYPE_HTCVENUS)
+#else
+# define machine_is_htckovsky()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SONY_PRS505
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SONY_PRS505
+# endif
+# define machine_is_sony_prs505()	(machine_arch_type == MACH_TYPE_SONY_PRS505)
+#else
+# define machine_is_sony_prs505()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HANLIN_V3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HANLIN_V3
+# endif
+# define machine_is_hanlin_v3()	(machine_arch_type == MACH_TYPE_HANLIN_V3)
+#else
+# define machine_is_hanlin_v3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SAPPHIRA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SAPPHIRA
+# endif
+# define machine_is_sapphira()	(machine_arch_type == MACH_TYPE_SAPPHIRA)
+#else
+# define machine_is_sapphira()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DACK_SDA_01
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DACK_SDA_01
+# endif
+# define machine_is_dack_sda_01()	(machine_arch_type == MACH_TYPE_DACK_SDA_01)
+#else
+# define machine_is_dack_sda_01()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARMBOX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARMBOX
+# endif
+# define machine_is_armbox()	(machine_arch_type == MACH_TYPE_ARMBOX)
+#else
+# define machine_is_armbox()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HARRIS_RVP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HARRIS_RVP
+# endif
+# define machine_is_harris_rvp()	(machine_arch_type == MACH_TYPE_HARRIS_RVP)
+#else
+# define machine_is_harris_rvp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RIBALDO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RIBALDO
+# endif
+# define machine_is_ribaldo()	(machine_arch_type == MACH_TYPE_RIBALDO)
+#else
+# define machine_is_ribaldo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AGORA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AGORA
+# endif
+# define machine_is_agora()	(machine_arch_type == MACH_TYPE_AGORA)
+#else
+# define machine_is_agora()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3_MINI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3_MINI
+# endif
+# define machine_is_omap3_mini()	(machine_arch_type == MACH_TYPE_OMAP3_MINI)
+#else
+# define machine_is_omap3_mini()	(0)
+#endif
+
+#ifdef CONFIG_MACH_A9SAM6432_B
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_A9SAM6432_B
+# endif
+# define machine_is_a9sam6432_b()	(machine_arch_type == MACH_TYPE_A9SAM6432_B)
+#else
+# define machine_is_a9sam6432_b()	(0)
+#endif
+
+#ifdef CONFIG_MACH_USG2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_USG2410
+# endif
+# define machine_is_usg2410()	(machine_arch_type == MACH_TYPE_USG2410)
+#else
+# define machine_is_usg2410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PC72052_I10_REVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PC72052_I10_REVB
+# endif
+# define machine_is_pc72052_i10_revb()	(machine_arch_type == MACH_TYPE_PC72052_I10_REVB)
+#else
+# define machine_is_pc72052_i10_revb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX35_EXM32
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX35_EXM32
+# endif
+# define machine_is_mx35_exm32()	(machine_arch_type == MACH_TYPE_MX35_EXM32)
+#else
+# define machine_is_mx35_exm32()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TOPAS910
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TOPAS910
+# endif
+# define machine_is_topas910()	(machine_arch_type == MACH_TYPE_TOPAS910)
+#else
+# define machine_is_topas910()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HYENA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HYENA
+# endif
+# define machine_is_hyena()	(machine_arch_type == MACH_TYPE_HYENA)
+#else
+# define machine_is_hyena()	(0)
+#endif
+
+#ifdef CONFIG_MACH_POSPAX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_POSPAX
+# endif
+# define machine_is_pospax()	(machine_arch_type == MACH_TYPE_POSPAX)
+#else
+# define machine_is_pospax()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HDL_GX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HDL_GX
+# endif
+# define machine_is_hdl_gx()	(machine_arch_type == MACH_TYPE_HDL_GX)
+#else
+# define machine_is_hdl_gx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CTERA_4BAY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CTERA_4BAY
+# endif
+# define machine_is_ctera_4bay()	(machine_arch_type == MACH_TYPE_CTERA_4BAY)
+#else
+# define machine_is_ctera_4bay()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CTERA_PLUG_C
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CTERA_PLUG_C
+# endif
+# define machine_is_ctera_plug_c()	(machine_arch_type == MACH_TYPE_CTERA_PLUG_C)
+#else
+# define machine_is_ctera_plug_c()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CRWEA_PLUG_I
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CRWEA_PLUG_I
+# endif
+# define machine_is_crwea_plug_i()	(machine_arch_type == MACH_TYPE_CRWEA_PLUG_I)
+#else
+# define machine_is_crwea_plug_i()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EGAUGE2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EGAUGE2
+# endif
+# define machine_is_egauge2()	(machine_arch_type == MACH_TYPE_EGAUGE2)
+#else
+# define machine_is_egauge2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DIDJ
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DIDJ
+# endif
+# define machine_is_didj()	(machine_arch_type == MACH_TYPE_DIDJ)
+#else
+# define machine_is_didj()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MEISTER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MEISTER
+# endif
+# define machine_is_m_s3c2443()	(machine_arch_type == MACH_TYPE_MEISTER)
+#else
+# define machine_is_m_s3c2443()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCBLACKSTONE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCBLACKSTONE
+# endif
+# define machine_is_htcblackstone()	(machine_arch_type == MACH_TYPE_HTCBLACKSTONE)
+#else
+# define machine_is_htcblackstone()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CPUAT9G20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CPUAT9G20
+# endif
+# define machine_is_cpuat9g20()	(machine_arch_type == MACH_TYPE_CPUAT9G20)
+#else
+# define machine_is_cpuat9g20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDK6440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDK6440
+# endif
+# define machine_is_smdk6440()	(machine_arch_type == MACH_TYPE_SMDK6440)
+#else
+# define machine_is_smdk6440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_35XX_MVP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_35XX_MVP
+# endif
+# define machine_is_omap_35xx_mvp()	(machine_arch_type == MACH_TYPE_OMAP_35XX_MVP)
+#else
+# define machine_is_omap_35xx_mvp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CTERA_PLUG_I
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CTERA_PLUG_I
+# endif
+# define machine_is_ctera_plug_i()	(machine_arch_type == MACH_TYPE_CTERA_PLUG_I)
+#else
+# define machine_is_ctera_plug_i()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PVG610
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PVG610
+# endif
+# define machine_is_pvg610_100()	(machine_arch_type == MACH_TYPE_PVG610)
+#else
+# define machine_is_pvg610_100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HPRW6815
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HPRW6815
+# endif
+# define machine_is_hprw6815()	(machine_arch_type == MACH_TYPE_HPRW6815)
+#else
+# define machine_is_hprw6815()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3_OSWALD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3_OSWALD
+# endif
+# define machine_is_omap3_oswald()	(machine_arch_type == MACH_TYPE_OMAP3_OSWALD)
+#else
+# define machine_is_omap3_oswald()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NAS4220B
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NAS4220B
+# endif
+# define machine_is_nas4220b()	(machine_arch_type == MACH_TYPE_NAS4220B)
+#else
+# define machine_is_nas4220b()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCRAPHAEL_CDMA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCRAPHAEL_CDMA
+# endif
+# define machine_is_htcraphael_cdma()	(machine_arch_type == MACH_TYPE_HTCRAPHAEL_CDMA)
+#else
+# define machine_is_htcraphael_cdma()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCDIAMOND_CDMA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCDIAMOND_CDMA
+# endif
+# define machine_is_htcdiamond_cdma()	(machine_arch_type == MACH_TYPE_HTCDIAMOND_CDMA)
+#else
+# define machine_is_htcdiamond_cdma()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SCALER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SCALER
+# endif
+# define machine_is_scaler()	(machine_arch_type == MACH_TYPE_SCALER)
+#else
+# define machine_is_scaler()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZYLONITE2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZYLONITE2
+# endif
+# define machine_is_zylonite2()	(machine_arch_type == MACH_TYPE_ZYLONITE2)
+#else
+# define machine_is_zylonite2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ASPENITE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ASPENITE
+# endif
+# define machine_is_aspenite()	(machine_arch_type == MACH_TYPE_ASPENITE)
+#else
+# define machine_is_aspenite()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TETON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TETON
+# endif
+# define machine_is_teton()	(machine_arch_type == MACH_TYPE_TETON)
+#else
+# define machine_is_teton()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TTC_DKB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TTC_DKB
+# endif
+# define machine_is_ttc_dkb()	(machine_arch_type == MACH_TYPE_TTC_DKB)
+#else
+# define machine_is_ttc_dkb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BISHOP2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BISHOP2
+# endif
+# define machine_is_bishop2()	(machine_arch_type == MACH_TYPE_BISHOP2)
+#else
+# define machine_is_bishop2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IPPV5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IPPV5
+# endif
+# define machine_is_ippv5()	(machine_arch_type == MACH_TYPE_IPPV5)
+#else
+# define machine_is_ippv5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FARM926
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FARM926
+# endif
+# define machine_is_farm926()	(machine_arch_type == MACH_TYPE_FARM926)
+#else
+# define machine_is_farm926()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MMCCPU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MMCCPU
+# endif
+# define machine_is_mmccpu()	(machine_arch_type == MACH_TYPE_MMCCPU)
+#else
+# define machine_is_mmccpu()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SGMSFL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SGMSFL
+# endif
+# define machine_is_sgmsfl()	(machine_arch_type == MACH_TYPE_SGMSFL)
+#else
+# define machine_is_sgmsfl()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TT8000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TT8000
+# endif
+# define machine_is_tt8000()	(machine_arch_type == MACH_TYPE_TT8000)
+#else
+# define machine_is_tt8000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZRN4300LP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZRN4300LP
+# endif
+# define machine_is_zrn4300lp()	(machine_arch_type == MACH_TYPE_ZRN4300LP)
+#else
+# define machine_is_zrn4300lp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MPTC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MPTC
+# endif
+# define machine_is_mptc()	(machine_arch_type == MACH_TYPE_MPTC)
+#else
+# define machine_is_mptc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_H6051
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_H6051
+# endif
+# define machine_is_h6051()	(machine_arch_type == MACH_TYPE_H6051)
+#else
+# define machine_is_h6051()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PVG610_101
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PVG610_101
+# endif
+# define machine_is_pvg610_101()	(machine_arch_type == MACH_TYPE_PVG610_101)
+#else
+# define machine_is_pvg610_101()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STAMP9261_PC_EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STAMP9261_PC_EVB
+# endif
+# define machine_is_stamp9261_pc_evb()	(machine_arch_type == MACH_TYPE_STAMP9261_PC_EVB)
+#else
+# define machine_is_stamp9261_pc_evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PELCO_ODYSSEUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PELCO_ODYSSEUS
+# endif
+# define machine_is_pelco_odysseus()	(machine_arch_type == MACH_TYPE_PELCO_ODYSSEUS)
+#else
+# define machine_is_pelco_odysseus()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TNY_A9260
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TNY_A9260
+# endif
+# define machine_is_tny_a9260()	(machine_arch_type == MACH_TYPE_TNY_A9260)
+#else
+# define machine_is_tny_a9260()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TNY_A9G20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TNY_A9G20
+# endif
+# define machine_is_tny_a9g20()	(machine_arch_type == MACH_TYPE_TNY_A9G20)
+#else
+# define machine_is_tny_a9g20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AESOP_MP2530F
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AESOP_MP2530F
+# endif
+# define machine_is_aesop_mp2530f()	(machine_arch_type == MACH_TYPE_AESOP_MP2530F)
+#else
+# define machine_is_aesop_mp2530f()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DX900
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DX900
+# endif
+# define machine_is_dx900()	(machine_arch_type == MACH_TYPE_DX900)
+#else
+# define machine_is_dx900()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CPODC2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CPODC2
+# endif
+# define machine_is_cpodc2()	(machine_arch_type == MACH_TYPE_CPODC2)
+#else
+# define machine_is_cpodc2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TILT_8925
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TILT_8925
+# endif
+# define machine_is_tilt_8925()	(machine_arch_type == MACH_TYPE_TILT_8925)
+#else
+# define machine_is_tilt_8925()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_DM357_EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_DM357_EVM
+# endif
+# define machine_is_davinci_dm357_evm()	(machine_arch_type == MACH_TYPE_DAVINCI_DM357_EVM)
+#else
+# define machine_is_davinci_dm357_evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SWORDFISH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SWORDFISH
+# endif
+# define machine_is_swordfish()	(machine_arch_type == MACH_TYPE_SWORDFISH)
+#else
+# define machine_is_swordfish()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CORVUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CORVUS
+# endif
+# define machine_is_corvus()	(machine_arch_type == MACH_TYPE_CORVUS)
+#else
+# define machine_is_corvus()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TAURUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TAURUS
+# endif
+# define machine_is_taurus()	(machine_arch_type == MACH_TYPE_TAURUS)
+#else
+# define machine_is_taurus()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AXM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AXM
+# endif
+# define machine_is_axm()	(machine_arch_type == MACH_TYPE_AXM)
+#else
+# define machine_is_axm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AXC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AXC
+# endif
+# define machine_is_axc()	(machine_arch_type == MACH_TYPE_AXC)
+#else
+# define machine_is_axc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BABY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BABY
+# endif
+# define machine_is_baby()	(machine_arch_type == MACH_TYPE_BABY)
+#else
+# define machine_is_baby()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MP200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MP200
+# endif
+# define machine_is_mp200()	(machine_arch_type == MACH_TYPE_MP200)
+#else
+# define machine_is_mp200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PCM043
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PCM043
+# endif
+# define machine_is_pcm043()	(machine_arch_type == MACH_TYPE_PCM043)
+#else
+# define machine_is_pcm043()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HANLIN_V3C
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HANLIN_V3C
+# endif
+# define machine_is_hanlin_v3c()	(machine_arch_type == MACH_TYPE_HANLIN_V3C)
+#else
+# define machine_is_hanlin_v3c()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KBK9G20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KBK9G20
+# endif
+# define machine_is_kbk9g20()	(machine_arch_type == MACH_TYPE_KBK9G20)
+#else
+# define machine_is_kbk9g20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ADSTURBOG5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ADSTURBOG5
+# endif
+# define machine_is_adsturbog5()	(machine_arch_type == MACH_TYPE_ADSTURBOG5)
+#else
+# define machine_is_adsturbog5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AVENGER_LITE1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AVENGER_LITE1
+# endif
+# define machine_is_avenger_lite1()	(machine_arch_type == MACH_TYPE_AVENGER_LITE1)
+#else
+# define machine_is_avenger_lite1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SUC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SUC
+# endif
+# define machine_is_suc82x()	(machine_arch_type == MACH_TYPE_SUC)
+#else
+# define machine_is_suc82x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM7S256
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM7S256
+# endif
+# define machine_is_at91sam7s256()	(machine_arch_type == MACH_TYPE_AT91SAM7S256)
+#else
+# define machine_is_at91sam7s256()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MENDOZA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MENDOZA
+# endif
+# define machine_is_mendoza()	(machine_arch_type == MACH_TYPE_MENDOZA)
+#else
+# define machine_is_mendoza()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KIRA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KIRA
+# endif
+# define machine_is_kira()	(machine_arch_type == MACH_TYPE_KIRA)
+#else
+# define machine_is_kira()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX1HBM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX1HBM
+# endif
+# define machine_is_mx1hbm()	(machine_arch_type == MACH_TYPE_MX1HBM)
+#else
+# define machine_is_mx1hbm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QUATRO43XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QUATRO43XX
+# endif
+# define machine_is_quatro43xx()	(machine_arch_type == MACH_TYPE_QUATRO43XX)
+#else
+# define machine_is_quatro43xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QUATRO4230
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QUATRO4230
+# endif
+# define machine_is_quatro4230()	(machine_arch_type == MACH_TYPE_QUATRO4230)
+#else
+# define machine_is_quatro4230()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NSB400
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NSB400
+# endif
+# define machine_is_nsb400()	(machine_arch_type == MACH_TYPE_NSB400)
+#else
+# define machine_is_nsb400()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DRP255
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DRP255
+# endif
+# define machine_is_drp255()	(machine_arch_type == MACH_TYPE_DRP255)
+#else
+# define machine_is_drp255()	(0)
+#endif
+
+#ifdef CONFIG_MACH_THOTH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_THOTH
+# endif
+# define machine_is_thoth()	(machine_arch_type == MACH_TYPE_THOTH)
+#else
+# define machine_is_thoth()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FIRESTONE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FIRESTONE
+# endif
+# define machine_is_firestone()	(machine_arch_type == MACH_TYPE_FIRESTONE)
+#else
+# define machine_is_firestone()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ASUSP750
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ASUSP750
+# endif
+# define machine_is_asusp750()	(machine_arch_type == MACH_TYPE_ASUSP750)
+#else
+# define machine_is_asusp750()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CTERA_DL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CTERA_DL
+# endif
+# define machine_is_ctera_dl()	(machine_arch_type == MACH_TYPE_CTERA_DL)
+#else
+# define machine_is_ctera_dl()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SOCR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SOCR
+# endif
+# define machine_is_socr()	(machine_arch_type == MACH_TYPE_SOCR)
+#else
+# define machine_is_socr()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCOXYGEN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCOXYGEN
+# endif
+# define machine_is_htcoxygen()	(machine_arch_type == MACH_TYPE_HTCOXYGEN)
+#else
+# define machine_is_htcoxygen()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HEROC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HEROC
+# endif
+# define machine_is_heroc()	(machine_arch_type == MACH_TYPE_HEROC)
+#else
+# define machine_is_heroc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZENO6800
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZENO6800
+# endif
+# define machine_is_zeno6800()	(machine_arch_type == MACH_TYPE_ZENO6800)
+#else
+# define machine_is_zeno6800()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SC2MCS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SC2MCS
+# endif
+# define machine_is_sc2mcs()	(machine_arch_type == MACH_TYPE_SC2MCS)
+#else
+# define machine_is_sc2mcs()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GENE100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GENE100
+# endif
+# define machine_is_gene100()	(machine_arch_type == MACH_TYPE_GENE100)
+#else
+# define machine_is_gene100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AS353X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AS353X
+# endif
+# define machine_is_as353x()	(machine_arch_type == MACH_TYPE_AS353X)
+#else
+# define machine_is_as353x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SHEEVAPLUG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHEEVAPLUG
+# endif
+# define machine_is_sheevaplug()	(machine_arch_type == MACH_TYPE_SHEEVAPLUG)
+#else
+# define machine_is_sheevaplug()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9G20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9G20
+# endif
+# define machine_is_at91sam9g20()	(machine_arch_type == MACH_TYPE_AT91SAM9G20)
+#else
+# define machine_is_at91sam9g20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MV88F6192GTW_FE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MV88F6192GTW_FE
+# endif
+# define machine_is_mv88f6192gtw_fe()	(machine_arch_type == MACH_TYPE_MV88F6192GTW_FE)
+#else
+# define machine_is_mv88f6192gtw_fe()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CC9200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CC9200
+# endif
+# define machine_is_cc9200()	(machine_arch_type == MACH_TYPE_CC9200)
+#else
+# define machine_is_cc9200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SM9200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SM9200
+# endif
+# define machine_is_sm9200()	(machine_arch_type == MACH_TYPE_SM9200)
+#else
+# define machine_is_sm9200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TP9200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TP9200
+# endif
+# define machine_is_tp9200()	(machine_arch_type == MACH_TYPE_TP9200)
+#else
+# define machine_is_tp9200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SNAPPERDV
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SNAPPERDV
+# endif
+# define machine_is_snapperdv()	(machine_arch_type == MACH_TYPE_SNAPPERDV)
+#else
+# define machine_is_snapperdv()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AVENGERS_LITE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AVENGERS_LITE
+# endif
+# define machine_is_avengers_lite()	(machine_arch_type == MACH_TYPE_AVENGERS_LITE)
+#else
+# define machine_is_avengers_lite()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AVENGERS_LITE1
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AVENGERS_LITE1
+# endif
+# define machine_is_avengers_lite1()	(machine_arch_type == MACH_TYPE_AVENGERS_LITE1)
+#else
+# define machine_is_avengers_lite1()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3AXON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3AXON
+# endif
+# define machine_is_omap3axon()	(machine_arch_type == MACH_TYPE_OMAP3AXON)
+#else
+# define machine_is_omap3axon()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MA8XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MA8XX
+# endif
+# define machine_is_ma8xx()	(machine_arch_type == MACH_TYPE_MA8XX)
+#else
+# define machine_is_ma8xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MP201EK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MP201EK
+# endif
+# define machine_is_mp201ek()	(machine_arch_type == MACH_TYPE_MP201EK)
+#else
+# define machine_is_mp201ek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_TUX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_TUX
+# endif
+# define machine_is_davinci_tux()	(machine_arch_type == MACH_TYPE_DAVINCI_TUX)
+#else
+# define machine_is_davinci_tux()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MPA1600
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MPA1600
+# endif
+# define machine_is_mpa1600()	(machine_arch_type == MACH_TYPE_MPA1600)
+#else
+# define machine_is_mpa1600()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PELCO_TROY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PELCO_TROY
+# endif
+# define machine_is_pelco_troy()	(machine_arch_type == MACH_TYPE_PELCO_TROY)
+#else
+# define machine_is_pelco_troy()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NSB667
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NSB667
+# endif
+# define machine_is_nsb667()	(machine_arch_type == MACH_TYPE_NSB667)
+#else
+# define machine_is_nsb667()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ROVERS5_4MPIX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ROVERS5_4MPIX
+# endif
+# define machine_is_rovers5_4mpix()	(machine_arch_type == MACH_TYPE_ROVERS5_4MPIX)
+#else
+# define machine_is_rovers5_4mpix()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TWOCOM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TWOCOM
+# endif
+# define machine_is_twocom()	(machine_arch_type == MACH_TYPE_TWOCOM)
+#else
+# define machine_is_twocom()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UBISYS_P9_RCU3R2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UBISYS_P9_RCU3R2
+# endif
+# define machine_is_ubisys_p9_rcu3r2()	(machine_arch_type == MACH_TYPE_UBISYS_P9_RCU3R2)
+#else
+# define machine_is_ubisys_p9_rcu3r2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HERO_ESPRESSO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HERO_ESPRESSO
+# endif
+# define machine_is_hero_espresso()	(machine_arch_type == MACH_TYPE_HERO_ESPRESSO)
+#else
+# define machine_is_hero_espresso()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AFEUSB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AFEUSB
+# endif
+# define machine_is_afeusb()	(machine_arch_type == MACH_TYPE_AFEUSB)
+#else
+# define machine_is_afeusb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_T830
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_T830
+# endif
+# define machine_is_t830()	(machine_arch_type == MACH_TYPE_T830)
+#else
+# define machine_is_t830()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPD8020_CC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPD8020_CC
+# endif
+# define machine_is_spd8020_cc()	(machine_arch_type == MACH_TYPE_SPD8020_CC)
+#else
+# define machine_is_spd8020_cc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OM_3D7K
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OM_3D7K
+# endif
+# define machine_is_om_3d7k()	(machine_arch_type == MACH_TYPE_OM_3D7K)
+#else
+# define machine_is_om_3d7k()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PICOCOM2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PICOCOM2
+# endif
+# define machine_is_picocom2()	(machine_arch_type == MACH_TYPE_PICOCOM2)
+#else
+# define machine_is_picocom2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UWG4MX27
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UWG4MX27
+# endif
+# define machine_is_uwg4mx27()	(machine_arch_type == MACH_TYPE_UWG4MX27)
+#else
+# define machine_is_uwg4mx27()	(0)
+#endif
+
+#ifdef CONFIG_MACH_UWG4MX31
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_UWG4MX31
+# endif
+# define machine_is_uwg4mx31()	(machine_arch_type == MACH_TYPE_UWG4MX31)
+#else
+# define machine_is_uwg4mx31()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CHERRY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CHERRY
+# endif
+# define machine_is_cherry()	(machine_arch_type == MACH_TYPE_CHERRY)
+#else
+# define machine_is_cherry()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX51_BABBAGE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX51_BABBAGE
+# endif
+# define machine_is_mx51_babbage()	(machine_arch_type == MACH_TYPE_MX51_BABBAGE)
+#else
+# define machine_is_mx51_babbage()	(0)
+#endif
+
+#ifdef CONFIG_MACH_S3C2440TURKIYE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S3C2440TURKIYE
+# endif
+# define machine_is_s3c2440turkiye()	(machine_arch_type == MACH_TYPE_S3C2440TURKIYE)
+#else
+# define machine_is_s3c2440turkiye()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TX37
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TX37
+# endif
+# define machine_is_tx37()	(machine_arch_type == MACH_TYPE_TX37)
+#else
+# define machine_is_tx37()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SBC2800_9G20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SBC2800_9G20
+# endif
+# define machine_is_sbc2800_9g20()	(machine_arch_type == MACH_TYPE_SBC2800_9G20)
+#else
+# define machine_is_sbc2800_9g20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BENZGLB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BENZGLB
+# endif
+# define machine_is_benzglb()	(machine_arch_type == MACH_TYPE_BENZGLB)
+#else
+# define machine_is_benzglb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BENZTD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BENZTD
+# endif
+# define machine_is_benztd()	(machine_arch_type == MACH_TYPE_BENZTD)
+#else
+# define machine_is_benztd()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CARTESIO_PLUS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CARTESIO_PLUS
+# endif
+# define machine_is_cartesio_plus()	(machine_arch_type == MACH_TYPE_CARTESIO_PLUS)
+#else
+# define machine_is_cartesio_plus()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SOLRAD_G20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SOLRAD_G20
+# endif
+# define machine_is_solrad_g20()	(machine_arch_type == MACH_TYPE_SOLRAD_G20)
+#else
+# define machine_is_solrad_g20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MX27WALLACE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MX27WALLACE
+# endif
+# define machine_is_mx27wallace()	(machine_arch_type == MACH_TYPE_MX27WALLACE)
+#else
+# define machine_is_mx27wallace()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FMZWEBMODUL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FMZWEBMODUL
+# endif
+# define machine_is_fmzwebmodul()	(machine_arch_type == MACH_TYPE_FMZWEBMODUL)
+#else
+# define machine_is_fmzwebmodul()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RD78X00_MASA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RD78X00_MASA
+# endif
+# define machine_is_rd78x00_masa()	(machine_arch_type == MACH_TYPE_RD78X00_MASA)
+#else
+# define machine_is_rd78x00_masa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMALLOGGER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMALLOGGER
+# endif
+# define machine_is_smallogger()	(machine_arch_type == MACH_TYPE_SMALLOGGER)
+#else
+# define machine_is_smallogger()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CCW9P9215
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CCW9P9215
+# endif
+# define machine_is_ccw9p9215()	(machine_arch_type == MACH_TYPE_CCW9P9215)
+#else
+# define machine_is_ccw9p9215()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DM355_LEOPARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DM355_LEOPARD
+# endif
+# define machine_is_dm355_leopard()	(machine_arch_type == MACH_TYPE_DM355_LEOPARD)
+#else
+# define machine_is_dm355_leopard()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TS219
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TS219
+# endif
+# define machine_is_ts219()	(machine_arch_type == MACH_TYPE_TS219)
+#else
+# define machine_is_ts219()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TNY_A9263
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TNY_A9263
+# endif
+# define machine_is_tny_a9263()	(machine_arch_type == MACH_TYPE_TNY_A9263)
+#else
+# define machine_is_tny_a9263()	(0)
+#endif
+
+#ifdef CONFIG_MACH_APOLLO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_APOLLO
+# endif
+# define machine_is_apollo()	(machine_arch_type == MACH_TYPE_APOLLO)
+#else
+# define machine_is_apollo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91CAP9STK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91CAP9STK
+# endif
+# define machine_is_at91cap9stk()	(machine_arch_type == MACH_TYPE_AT91CAP9STK)
+#else
+# define machine_is_at91cap9stk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPC300
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPC300
+# endif
+# define machine_is_spc300()	(machine_arch_type == MACH_TYPE_SPC300)
+#else
+# define machine_is_spc300()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EKO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EKO
+# endif
+# define machine_is_eko()	(machine_arch_type == MACH_TYPE_EKO)
+#else
+# define machine_is_eko()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CCW9M2443
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CCW9M2443
+# endif
+# define machine_is_ccw9m2443()	(machine_arch_type == MACH_TYPE_CCW9M2443)
+#else
+# define machine_is_ccw9m2443()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CCW9M2443JS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CCW9M2443JS
+# endif
+# define machine_is_ccw9m2443js()	(machine_arch_type == MACH_TYPE_CCW9M2443JS)
+#else
+# define machine_is_ccw9m2443js()	(0)
+#endif
+
+#ifdef CONFIG_MACH_M2M_ROUTER_DEVICE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_M2M_ROUTER_DEVICE
+# endif
+# define machine_is_m2m_router_device()	(machine_arch_type == MACH_TYPE_M2M_ROUTER_DEVICE)
+#else
+# define machine_is_m2m_router_device()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STAR9104NAS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STAR9104NAS
+# endif
+# define machine_is_str9104nas()	(machine_arch_type == MACH_TYPE_STAR9104NAS)
+#else
+# define machine_is_str9104nas()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PCA100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PCA100
+# endif
+# define machine_is_pca100()	(machine_arch_type == MACH_TYPE_PCA100)
+#else
+# define machine_is_pca100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_Z3_DM365_MOD_01
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_Z3_DM365_MOD_01
+# endif
+# define machine_is_z3_dm365_mod_01()	(machine_arch_type == MACH_TYPE_Z3_DM365_MOD_01)
+#else
+# define machine_is_z3_dm365_mod_01()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HIPOX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HIPOX
+# endif
+# define machine_is_hipox()	(machine_arch_type == MACH_TYPE_HIPOX)
+#else
+# define machine_is_hipox()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3_PITEDS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3_PITEDS
+# endif
+# define machine_is_omap3_piteds()	(machine_arch_type == MACH_TYPE_OMAP3_PITEDS)
+#else
+# define machine_is_omap3_piteds()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BM150R
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BM150R
+# endif
+# define machine_is_bm150r()	(machine_arch_type == MACH_TYPE_BM150R)
+#else
+# define machine_is_bm150r()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TBONE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TBONE
+# endif
+# define machine_is_tbone()	(machine_arch_type == MACH_TYPE_TBONE)
+#else
+# define machine_is_tbone()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MERLIN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MERLIN
+# endif
+# define machine_is_merlin()	(machine_arch_type == MACH_TYPE_MERLIN)
+#else
+# define machine_is_merlin()	(0)
+#endif
+
+#ifdef CONFIG_MACH_FALCON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_FALCON
+# endif
+# define machine_is_falcon()	(machine_arch_type == MACH_TYPE_FALCON)
+#else
+# define machine_is_falcon()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DAVINCI_DA850_EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DAVINCI_DA850_EVM
+# endif
+# define machine_is_davinci_da850_evm()	(machine_arch_type == MACH_TYPE_DAVINCI_DA850_EVM)
+#else
+# define machine_is_davinci_da850_evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_S5P6440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_S5P6440
+# endif
+# define machine_is_s5p6440()	(machine_arch_type == MACH_TYPE_S5P6440)
+#else
+# define machine_is_s5p6440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9G10EK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9G10EK
+# endif
+# define machine_is_at91sam9g10ek()	(machine_arch_type == MACH_TYPE_AT91SAM9G10EK)
+#else
+# define machine_is_at91sam9g10ek()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP_4430SDP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP_4430SDP
+# endif
+# define machine_is_omap_4430sdp()	(machine_arch_type == MACH_TYPE_OMAP_4430SDP)
+#else
+# define machine_is_omap_4430sdp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LPC313X
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LPC313X
+# endif
+# define machine_is_lpc313x()	(machine_arch_type == MACH_TYPE_LPC313X)
+#else
+# define machine_is_lpc313x()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAGX_ZN5
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAGX_ZN5
+# endif
+# define machine_is_magx_zn5()	(machine_arch_type == MACH_TYPE_MAGX_ZN5)
+#else
+# define machine_is_magx_zn5()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAGX_EM30
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAGX_EM30
+# endif
+# define machine_is_magx_em30()	(machine_arch_type == MACH_TYPE_MAGX_EM30)
+#else
+# define machine_is_magx_em30()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAGX_VE66
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAGX_VE66
+# endif
+# define machine_is_magx_ve66()	(machine_arch_type == MACH_TYPE_MAGX_VE66)
+#else
+# define machine_is_magx_ve66()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MEESC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MEESC
+# endif
+# define machine_is_meesc()	(machine_arch_type == MACH_TYPE_MEESC)
+#else
+# define machine_is_meesc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OTC570
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OTC570
+# endif
+# define machine_is_otc570()	(machine_arch_type == MACH_TYPE_OTC570)
+#else
+# define machine_is_otc570()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BCU2412
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BCU2412
+# endif
+# define machine_is_bcu2412()	(machine_arch_type == MACH_TYPE_BCU2412)
+#else
+# define machine_is_bcu2412()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BEACON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BEACON
+# endif
+# define machine_is_beacon()	(machine_arch_type == MACH_TYPE_BEACON)
+#else
+# define machine_is_beacon()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ACTIA_TGW
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ACTIA_TGW
+# endif
+# define machine_is_actia_tgw()	(machine_arch_type == MACH_TYPE_ACTIA_TGW)
+#else
+# define machine_is_actia_tgw()	(0)
+#endif
+
+#ifdef CONFIG_MACH_E4430
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_E4430
+# endif
+# define machine_is_e4430()	(machine_arch_type == MACH_TYPE_E4430)
+#else
+# define machine_is_e4430()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QL300
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QL300
+# endif
+# define machine_is_ql300()	(machine_arch_type == MACH_TYPE_QL300)
+#else
+# define machine_is_ql300()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BTMAVB101
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BTMAVB101
+# endif
+# define machine_is_btmavb101()	(machine_arch_type == MACH_TYPE_BTMAVB101)
+#else
+# define machine_is_btmavb101()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BTMAWB101
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BTMAWB101
+# endif
+# define machine_is_btmawb101()	(machine_arch_type == MACH_TYPE_BTMAWB101)
+#else
+# define machine_is_btmawb101()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SQ201
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SQ201
+# endif
+# define machine_is_sq201()	(machine_arch_type == MACH_TYPE_SQ201)
+#else
+# define machine_is_sq201()	(0)
+#endif
+
+#ifdef CONFIG_MACH_QUATRO45XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_QUATRO45XX
+# endif
+# define machine_is_quatro45xx()	(machine_arch_type == MACH_TYPE_QUATRO45XX)
+#else
+# define machine_is_quatro45xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OPENPAD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OPENPAD
+# endif
+# define machine_is_openpad()	(machine_arch_type == MACH_TYPE_OPENPAD)
+#else
+# define machine_is_openpad()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TX25
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TX25
+# endif
+# define machine_is_tx25()	(machine_arch_type == MACH_TYPE_TX25)
+#else
+# define machine_is_tx25()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3_TORPEDO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3_TORPEDO
+# endif
+# define machine_is_omap3_torpedo()	(machine_arch_type == MACH_TYPE_OMAP3_TORPEDO)
+#else
+# define machine_is_omap3_torpedo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCRAPHAEL_K
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCRAPHAEL_K
+# endif
+# define machine_is_htcraphael_k()	(machine_arch_type == MACH_TYPE_HTCRAPHAEL_K)
+#else
+# define machine_is_htcraphael_k()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LAL43
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LAL43
+# endif
+# define machine_is_lal43()	(machine_arch_type == MACH_TYPE_LAL43)
+#else
+# define machine_is_lal43()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCRAPHAEL_CDMA500
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCRAPHAEL_CDMA500
+# endif
+# define machine_is_htcraphael_cdma500()	(machine_arch_type == MACH_TYPE_HTCRAPHAEL_CDMA500)
+#else
+# define machine_is_htcraphael_cdma500()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ANW6410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ANW6410
+# endif
+# define machine_is_anw6410()	(machine_arch_type == MACH_TYPE_ANW6410)
+#else
+# define machine_is_anw6410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCPROPHET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCPROPHET
+# endif
+# define machine_is_htcprophet()	(machine_arch_type == MACH_TYPE_HTCPROPHET)
+#else
+# define machine_is_htcprophet()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CFA_10022
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CFA_10022
+# endif
+# define machine_is_cfa_10022()	(machine_arch_type == MACH_TYPE_CFA_10022)
+#else
+# define machine_is_cfa_10022()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IMX27_VISSTRIM_M10
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IMX27_VISSTRIM_M10
+# endif
+# define machine_is_imx27_visstrim_m10()	(machine_arch_type == MACH_TYPE_IMX27_VISSTRIM_M10)
+#else
+# define machine_is_imx27_visstrim_m10()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PX2IMX27
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PX2IMX27
+# endif
+# define machine_is_px2imx27()	(machine_arch_type == MACH_TYPE_PX2IMX27)
+#else
+# define machine_is_px2imx27()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STM3210E_EVAL
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STM3210E_EVAL
+# endif
+# define machine_is_stm3210e_eval()	(machine_arch_type == MACH_TYPE_STM3210E_EVAL)
+#else
+# define machine_is_stm3210e_eval()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DVS10
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DVS10
+# endif
+# define machine_is_dvs10()	(machine_arch_type == MACH_TYPE_DVS10)
+#else
+# define machine_is_dvs10()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PORTUXG20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PORTUXG20
+# endif
+# define machine_is_portuxg20()	(machine_arch_type == MACH_TYPE_PORTUXG20)
+#else
+# define machine_is_portuxg20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARM_SPV
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARM_SPV
+# endif
+# define machine_is_arm_spv()	(machine_arch_type == MACH_TYPE_ARM_SPV)
+#else
+# define machine_is_arm_spv()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SMDKC110
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SMDKC110
+# endif
+# define machine_is_smdkc110()	(machine_arch_type == MACH_TYPE_SMDKC110)
+#else
+# define machine_is_smdkc110()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CABESPRESSO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CABESPRESSO
+# endif
+# define machine_is_cabespresso()	(machine_arch_type == MACH_TYPE_CABESPRESSO)
+#else
+# define machine_is_cabespresso()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HMC800
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HMC800
+# endif
+# define machine_is_hmc800()	(machine_arch_type == MACH_TYPE_HMC800)
+#else
+# define machine_is_hmc800()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SHOLES
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SHOLES
+# endif
+# define machine_is_sholes()	(machine_arch_type == MACH_TYPE_SHOLES)
+#else
+# define machine_is_sholes()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BTMXC31
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BTMXC31
+# endif
+# define machine_is_btmxc31()	(machine_arch_type == MACH_TYPE_BTMXC31)
+#else
+# define machine_is_btmxc31()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DT501
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DT501
+# endif
+# define machine_is_dt501()	(machine_arch_type == MACH_TYPE_DT501)
+#else
+# define machine_is_dt501()	(0)
+#endif
+
+#ifdef CONFIG_MACH_KTX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_KTX
+# endif
+# define machine_is_ktx()	(machine_arch_type == MACH_TYPE_KTX)
+#else
+# define machine_is_ktx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3517EVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3517EVM
+# endif
+# define machine_is_omap3517evm()	(machine_arch_type == MACH_TYPE_OMAP3517EVM)
+#else
+# define machine_is_omap3517evm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NETSPACE_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NETSPACE_V2
+# endif
+# define machine_is_netspace_v2()	(machine_arch_type == MACH_TYPE_NETSPACE_V2)
+#else
+# define machine_is_netspace_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NETSPACE_MAX_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NETSPACE_MAX_V2
+# endif
+# define machine_is_netspace_max_v2()	(machine_arch_type == MACH_TYPE_NETSPACE_MAX_V2)
+#else
+# define machine_is_netspace_max_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_D2NET_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_D2NET_V2
+# endif
+# define machine_is_d2net_v2()	(machine_arch_type == MACH_TYPE_D2NET_V2)
+#else
+# define machine_is_d2net_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NET2BIG_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NET2BIG_V2
+# endif
+# define machine_is_net2big_v2()	(machine_arch_type == MACH_TYPE_NET2BIG_V2)
+#else
+# define machine_is_net2big_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NET4BIG_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NET4BIG_V2
+# endif
+# define machine_is_net4big_v2()	(machine_arch_type == MACH_TYPE_NET4BIG_V2)
+#else
+# define machine_is_net4big_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NET5BIG_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NET5BIG_V2
+# endif
+# define machine_is_net5big_v2()	(machine_arch_type == MACH_TYPE_NET5BIG_V2)
+#else
+# define machine_is_net5big_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ENDB2443
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ENDB2443
+# endif
+# define machine_is_endb2443()	(machine_arch_type == MACH_TYPE_ENDB2443)
+#else
+# define machine_is_endb2443()	(0)
+#endif
+
+#ifdef CONFIG_MACH_INETSPACE_V2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INETSPACE_V2
+# endif
+# define machine_is_inetspace_v2()	(machine_arch_type == MACH_TYPE_INETSPACE_V2)
+#else
+# define machine_is_inetspace_v2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TROS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TROS
+# endif
+# define machine_is_tros()	(machine_arch_type == MACH_TYPE_TROS)
+#else
+# define machine_is_tros()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PELCO_HOMER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PELCO_HOMER
+# endif
+# define machine_is_pelco_homer()	(machine_arch_type == MACH_TYPE_PELCO_HOMER)
+#else
+# define machine_is_pelco_homer()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OFSP8
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OFSP8
+# endif
+# define machine_is_ofsp8()	(machine_arch_type == MACH_TYPE_OFSP8)
+#else
+# define machine_is_ofsp8()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9G45EKES
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9G45EKES
+# endif
+# define machine_is_at91sam9g45ekes()	(machine_arch_type == MACH_TYPE_AT91SAM9G45EKES)
+#else
+# define machine_is_at91sam9g45ekes()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GUF_CUPID
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GUF_CUPID
+# endif
+# define machine_is_guf_cupid()	(machine_arch_type == MACH_TYPE_GUF_CUPID)
+#else
+# define machine_is_guf_cupid()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EAB1R
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EAB1R
+# endif
+# define machine_is_eab1r()	(machine_arch_type == MACH_TYPE_EAB1R)
+#else
+# define machine_is_eab1r()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DESIREC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DESIREC
+# endif
+# define machine_is_desirec()	(machine_arch_type == MACH_TYPE_DESIREC)
+#else
+# define machine_is_desirec()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CORDOBA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CORDOBA
+# endif
+# define machine_is_cordoba()	(machine_arch_type == MACH_TYPE_CORDOBA)
+#else
+# define machine_is_cordoba()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IRVINE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IRVINE
+# endif
+# define machine_is_irvine()	(machine_arch_type == MACH_TYPE_IRVINE)
+#else
+# define machine_is_irvine()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SFF772
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SFF772
+# endif
+# define machine_is_sff772()	(machine_arch_type == MACH_TYPE_SFF772)
+#else
+# define machine_is_sff772()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PELCO_MILANO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PELCO_MILANO
+# endif
+# define machine_is_pelco_milano()	(machine_arch_type == MACH_TYPE_PELCO_MILANO)
+#else
+# define machine_is_pelco_milano()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PC7302
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PC7302
+# endif
+# define machine_is_pc7302()	(machine_arch_type == MACH_TYPE_PC7302)
+#else
+# define machine_is_pc7302()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BIP6000
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BIP6000
+# endif
+# define machine_is_bip6000()	(machine_arch_type == MACH_TYPE_BIP6000)
+#else
+# define machine_is_bip6000()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SILVERMOON
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SILVERMOON
+# endif
+# define machine_is_silvermoon()	(machine_arch_type == MACH_TYPE_SILVERMOON)
+#else
+# define machine_is_silvermoon()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VC0830
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VC0830
+# endif
+# define machine_is_vc0830()	(machine_arch_type == MACH_TYPE_VC0830)
+#else
+# define machine_is_vc0830()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DT430
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DT430
+# endif
+# define machine_is_dt430()	(machine_arch_type == MACH_TYPE_DT430)
+#else
+# define machine_is_dt430()	(0)
+#endif
+
+#ifdef CONFIG_MACH_JI42PF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_JI42PF
+# endif
+# define machine_is_ji42pf()	(machine_arch_type == MACH_TYPE_JI42PF)
+#else
+# define machine_is_ji42pf()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GNET_KSM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GNET_KSM
+# endif
+# define machine_is_gnet_ksm()	(machine_arch_type == MACH_TYPE_GNET_KSM)
+#else
+# define machine_is_gnet_ksm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GNET_SGM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GNET_SGM
+# endif
+# define machine_is_gnet_sgm()	(machine_arch_type == MACH_TYPE_GNET_SGM)
+#else
+# define machine_is_gnet_sgm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GNET_SGR
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GNET_SGR
+# endif
+# define machine_is_gnet_sgr()	(machine_arch_type == MACH_TYPE_GNET_SGR)
+#else
+# define machine_is_gnet_sgr()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3_ICETEKEVM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3_ICETEKEVM
+# endif
+# define machine_is_omap3_icetekevm()	(machine_arch_type == MACH_TYPE_OMAP3_ICETEKEVM)
+#else
+# define machine_is_omap3_icetekevm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PNP
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PNP
+# endif
+# define machine_is_pnp()	(machine_arch_type == MACH_TYPE_PNP)
+#else
+# define machine_is_pnp()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CTERA_2BAY_K
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CTERA_2BAY_K
+# endif
+# define machine_is_ctera_2bay_k()	(machine_arch_type == MACH_TYPE_CTERA_2BAY_K)
+#else
+# define machine_is_ctera_2bay_k()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CTERA_2BAY_U
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CTERA_2BAY_U
+# endif
+# define machine_is_ctera_2bay_u()	(machine_arch_type == MACH_TYPE_CTERA_2BAY_U)
+#else
+# define machine_is_ctera_2bay_u()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SAS_C
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SAS_C
+# endif
+# define machine_is_sas_c()	(machine_arch_type == MACH_TYPE_SAS_C)
+#else
+# define machine_is_sas_c()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VMA2315
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VMA2315
+# endif
+# define machine_is_vma2315()	(machine_arch_type == MACH_TYPE_VMA2315)
+#else
+# define machine_is_vma2315()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VCS
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VCS
+# endif
+# define machine_is_vcs()	(machine_arch_type == MACH_TYPE_VCS)
+#else
+# define machine_is_vcs()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPEAR600
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPEAR600
+# endif
+# define machine_is_spear600()	(machine_arch_type == MACH_TYPE_SPEAR600)
+#else
+# define machine_is_spear600()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPEAR300
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPEAR300
+# endif
+# define machine_is_spear300()	(machine_arch_type == MACH_TYPE_SPEAR300)
+#else
+# define machine_is_spear300()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SPEAR1300
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SPEAR1300
+# endif
+# define machine_is_spear1300()	(machine_arch_type == MACH_TYPE_SPEAR1300)
+#else
+# define machine_is_spear1300()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LILLY1131
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LILLY1131
+# endif
+# define machine_is_lilly1131()	(machine_arch_type == MACH_TYPE_LILLY1131)
+#else
+# define machine_is_lilly1131()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARVOO_AX301
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARVOO_AX301
+# endif
+# define machine_is_arvoo_ax301()	(machine_arch_type == MACH_TYPE_ARVOO_AX301)
+#else
+# define machine_is_arvoo_ax301()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAPPHONE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAPPHONE
+# endif
+# define machine_is_mapphone()	(machine_arch_type == MACH_TYPE_MAPPHONE)
+#else
+# define machine_is_mapphone()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LEGEND
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LEGEND
+# endif
+# define machine_is_legend()	(machine_arch_type == MACH_TYPE_LEGEND)
+#else
+# define machine_is_legend()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SALSA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SALSA
+# endif
+# define machine_is_salsa()	(machine_arch_type == MACH_TYPE_SALSA)
+#else
+# define machine_is_salsa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LOUNGE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LOUNGE
+# endif
+# define machine_is_lounge()	(machine_arch_type == MACH_TYPE_LOUNGE)
+#else
+# define machine_is_lounge()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VISION
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VISION
+# endif
+# define machine_is_vision()	(machine_arch_type == MACH_TYPE_VISION)
+#else
+# define machine_is_vision()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VMB20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VMB20
+# endif
+# define machine_is_vmb20()	(machine_arch_type == MACH_TYPE_VMB20)
+#else
+# define machine_is_vmb20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HY2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HY2410
+# endif
+# define machine_is_hy2410()	(machine_arch_type == MACH_TYPE_HY2410)
+#else
+# define machine_is_hy2410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HY9315
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HY9315
+# endif
+# define machine_is_hy9315()	(machine_arch_type == MACH_TYPE_HY9315)
+#else
+# define machine_is_hy9315()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BULLWINKLE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BULLWINKLE
+# endif
+# define machine_is_bullwinkle()	(machine_arch_type == MACH_TYPE_BULLWINKLE)
+#else
+# define machine_is_bullwinkle()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARM_ULTIMATOR2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARM_ULTIMATOR2
+# endif
+# define machine_is_arm_ultimator2()	(machine_arch_type == MACH_TYPE_ARM_ULTIMATOR2)
+#else
+# define machine_is_arm_ultimator2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VS_V210
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VS_V210
+# endif
+# define machine_is_vs_v210()	(machine_arch_type == MACH_TYPE_VS_V210)
+#else
+# define machine_is_vs_v210()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VS_V212
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VS_V212
+# endif
+# define machine_is_vs_v212()	(machine_arch_type == MACH_TYPE_VS_V212)
+#else
+# define machine_is_vs_v212()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HMT
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HMT
+# endif
+# define machine_is_hmt()	(machine_arch_type == MACH_TYPE_HMT)
+#else
+# define machine_is_hmt()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SUEN3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SUEN3
+# endif
+# define machine_is_suen3()	(machine_arch_type == MACH_TYPE_SUEN3)
+#else
+# define machine_is_suen3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_VESPER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_VESPER
+# endif
+# define machine_is_vesper()	(machine_arch_type == MACH_TYPE_VESPER)
+#else
+# define machine_is_vesper()	(0)
+#endif
+
+#ifdef CONFIG_MACH_STR9
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_STR9
+# endif
+# define machine_is_str9()	(machine_arch_type == MACH_TYPE_STR9)
+#else
+# define machine_is_str9()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3_WL_FF
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3_WL_FF
+# endif
+# define machine_is_omap3_wl_ff()	(machine_arch_type == MACH_TYPE_OMAP3_WL_FF)
+#else
+# define machine_is_omap3_wl_ff()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SIMCOM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SIMCOM
+# endif
+# define machine_is_simcom()	(machine_arch_type == MACH_TYPE_SIMCOM)
+#else
+# define machine_is_simcom()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MCWEBIO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MCWEBIO
+# endif
+# define machine_is_mcwebio()	(machine_arch_type == MACH_TYPE_MCWEBIO)
+#else
+# define machine_is_mcwebio()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3_PHRAZER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3_PHRAZER
+# endif
+# define machine_is_omap3_phrazer()	(machine_arch_type == MACH_TYPE_OMAP3_PHRAZER)
+#else
+# define machine_is_omap3_phrazer()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DARWIN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DARWIN
+# endif
+# define machine_is_darwin()	(machine_arch_type == MACH_TYPE_DARWIN)
+#else
+# define machine_is_darwin()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ORATISCOMU
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ORATISCOMU
+# endif
+# define machine_is_oratiscomu()	(machine_arch_type == MACH_TYPE_ORATISCOMU)
+#else
+# define machine_is_oratiscomu()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RTSBC20
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RTSBC20
+# endif
+# define machine_is_rtsbc20()	(machine_arch_type == MACH_TYPE_RTSBC20)
+#else
+# define machine_is_rtsbc20()	(0)
+#endif
+
+#ifdef CONFIG_MACH_I780
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_I780
+# endif
+# define machine_is_sgh_i780()	(machine_arch_type == MACH_TYPE_I780)
+#else
+# define machine_is_sgh_i780()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GEMINI324
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GEMINI324
+# endif
+# define machine_is_gemini324()	(machine_arch_type == MACH_TYPE_GEMINI324)
+#else
+# define machine_is_gemini324()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ORATISLAN
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ORATISLAN
+# endif
+# define machine_is_oratislan()	(machine_arch_type == MACH_TYPE_ORATISLAN)
+#else
+# define machine_is_oratislan()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ORATISALOG
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ORATISALOG
+# endif
+# define machine_is_oratisalog()	(machine_arch_type == MACH_TYPE_ORATISALOG)
+#else
+# define machine_is_oratisalog()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ORATISMADI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ORATISMADI
+# endif
+# define machine_is_oratismadi()	(machine_arch_type == MACH_TYPE_ORATISMADI)
+#else
+# define machine_is_oratismadi()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ORATISOT16
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ORATISOT16
+# endif
+# define machine_is_oratisot16()	(machine_arch_type == MACH_TYPE_ORATISOT16)
+#else
+# define machine_is_oratisot16()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ORATISDESK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ORATISDESK
+# endif
+# define machine_is_oratisdesk()	(machine_arch_type == MACH_TYPE_ORATISDESK)
+#else
+# define machine_is_oratisdesk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_V2P_CA9
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_V2P_CA9
+# endif
+# define machine_is_v2_ca9()	(machine_arch_type == MACH_TYPE_V2P_CA9)
+#else
+# define machine_is_v2_ca9()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SINTEXO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SINTEXO
+# endif
+# define machine_is_sintexo()	(machine_arch_type == MACH_TYPE_SINTEXO)
+#else
+# define machine_is_sintexo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CM3389
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CM3389
+# endif
+# define machine_is_cm3389()	(machine_arch_type == MACH_TYPE_CM3389)
+#else
+# define machine_is_cm3389()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3_CIO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3_CIO
+# endif
+# define machine_is_omap3_cio()	(machine_arch_type == MACH_TYPE_OMAP3_CIO)
+#else
+# define machine_is_omap3_cio()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SGH_I900
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SGH_I900
+# endif
+# define machine_is_sgh_i900()	(machine_arch_type == MACH_TYPE_SGH_I900)
+#else
+# define machine_is_sgh_i900()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BST100
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BST100
+# endif
+# define machine_is_bst100()	(machine_arch_type == MACH_TYPE_BST100)
+#else
+# define machine_is_bst100()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PASSION
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PASSION
+# endif
+# define machine_is_passion()	(machine_arch_type == MACH_TYPE_PASSION)
+#else
+# define machine_is_passion()	(0)
+#endif
+
+#ifdef CONFIG_MACH_INDESIGN_AT91SAM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_INDESIGN_AT91SAM
+# endif
+# define machine_is_indesign_at91sam()	(machine_arch_type == MACH_TYPE_INDESIGN_AT91SAM)
+#else
+# define machine_is_indesign_at91sam()	(0)
+#endif
+
+#ifdef CONFIG_MACH_C4_BADGER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_C4_BADGER
+# endif
+# define machine_is_c4_badger()	(machine_arch_type == MACH_TYPE_C4_BADGER)
+#else
+# define machine_is_c4_badger()	(0)
+#endif
+
+#ifdef CONFIG_MACH_C4_VIPER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_C4_VIPER
+# endif
+# define machine_is_c4_viper()	(machine_arch_type == MACH_TYPE_C4_VIPER)
+#else
+# define machine_is_c4_viper()	(0)
+#endif
+
+#ifdef CONFIG_MACH_D2NET
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_D2NET
+# endif
+# define machine_is_d2net()	(machine_arch_type == MACH_TYPE_D2NET)
+#else
+# define machine_is_d2net()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BIGDISK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BIGDISK
+# endif
+# define machine_is_bigdisk()	(machine_arch_type == MACH_TYPE_BIGDISK)
+#else
+# define machine_is_bigdisk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NOTALVISION
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NOTALVISION
+# endif
+# define machine_is_notalvision()	(machine_arch_type == MACH_TYPE_NOTALVISION)
+#else
+# define machine_is_notalvision()	(0)
+#endif
+
+#ifdef CONFIG_MACH_OMAP3_KBOC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_OMAP3_KBOC
+# endif
+# define machine_is_omap3_kboc()	(machine_arch_type == MACH_TYPE_OMAP3_KBOC)
+#else
+# define machine_is_omap3_kboc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CYCLONE
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CYCLONE
+# endif
+# define machine_is_cyclone()	(machine_arch_type == MACH_TYPE_CYCLONE)
+#else
+# define machine_is_cyclone()	(0)
+#endif
+
+#ifdef CONFIG_MACH_NINJA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_NINJA
+# endif
+# define machine_is_ninja()	(machine_arch_type == MACH_TYPE_NINJA)
+#else
+# define machine_is_ninja()	(0)
+#endif
+
+#ifdef CONFIG_MACH_AT91SAM9G20EK_2MMC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_AT91SAM9G20EK_2MMC
+# endif
+# define machine_is_at91sam9g20ek_2mmc()	(machine_arch_type == MACH_TYPE_AT91SAM9G20EK_2MMC)
+#else
+# define machine_is_at91sam9g20ek_2mmc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BCMRING
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BCMRING
+# endif
+# define machine_is_bcmring()	(machine_arch_type == MACH_TYPE_BCMRING)
+#else
+# define machine_is_bcmring()	(0)
+#endif
+
+#ifdef CONFIG_MACH_RESOL_DL2
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_RESOL_DL2
+# endif
+# define machine_is_resol_dl2()	(machine_arch_type == MACH_TYPE_RESOL_DL2)
+#else
+# define machine_is_resol_dl2()	(0)
+#endif
+
+#ifdef CONFIG_MACH_IFOSW
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_IFOSW
+# endif
+# define machine_is_ifosw()	(machine_arch_type == MACH_TYPE_IFOSW)
+#else
+# define machine_is_ifosw()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCRHODIUM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCRHODIUM
+# endif
+# define machine_is_htcrhodium()	(machine_arch_type == MACH_TYPE_HTCRHODIUM)
+#else
+# define machine_is_htcrhodium()	(0)
+#endif
+
+#ifdef CONFIG_MACH_HTCTOPAZ
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_HTCTOPAZ
+# endif
+# define machine_is_htctopaz()	(machine_arch_type == MACH_TYPE_HTCTOPAZ)
+#else
+# define machine_is_htctopaz()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MATRIX504
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MATRIX504
+# endif
+# define machine_is_matrix504()	(machine_arch_type == MACH_TYPE_MATRIX504)
+#else
+# define machine_is_matrix504()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MRFSA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MRFSA
+# endif
+# define machine_is_mrfsa()	(machine_arch_type == MACH_TYPE_MRFSA)
+#else
+# define machine_is_mrfsa()	(0)
+#endif
+
+#ifdef CONFIG_MACH_SC_P270
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_SC_P270
+# endif
+# define machine_is_sc_p270()	(machine_arch_type == MACH_TYPE_SC_P270)
+#else
+# define machine_is_sc_p270()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ATLAS5_EVB
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ATLAS5_EVB
+# endif
+# define machine_is_atlas5_evb()	(machine_arch_type == MACH_TYPE_ATLAS5_EVB)
+#else
+# define machine_is_atlas5_evb()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PELCO_LOBOX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PELCO_LOBOX
+# endif
+# define machine_is_pelco_lobox()	(machine_arch_type == MACH_TYPE_PELCO_LOBOX)
+#else
+# define machine_is_pelco_lobox()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DILAX_PCU200
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DILAX_PCU200
+# endif
+# define machine_is_dilax_pcu200()	(machine_arch_type == MACH_TYPE_DILAX_PCU200)
+#else
+# define machine_is_dilax_pcu200()	(0)
+#endif
+
+#ifdef CONFIG_MACH_LEONARDO
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_LEONARDO
+# endif
+# define machine_is_leonardo()	(machine_arch_type == MACH_TYPE_LEONARDO)
+#else
+# define machine_is_leonardo()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZORAN_APPROACH7
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZORAN_APPROACH7
+# endif
+# define machine_is_zoran_approach7()	(machine_arch_type == MACH_TYPE_ZORAN_APPROACH7)
+#else
+# define machine_is_zoran_approach7()	(0)
+#endif
+
+#ifdef CONFIG_MACH_DP6XX
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_DP6XX
+# endif
+# define machine_is_dp6xx()	(machine_arch_type == MACH_TYPE_DP6XX)
+#else
+# define machine_is_dp6xx()	(0)
+#endif
+
+#ifdef CONFIG_MACH_BCM2153_VESPER
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_BCM2153_VESPER
+# endif
+# define machine_is_bcm2153_vesper()	(machine_arch_type == MACH_TYPE_BCM2153_VESPER)
+#else
+# define machine_is_bcm2153_vesper()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MAHIMAHI
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MAHIMAHI
+# endif
+# define machine_is_mahimahi()	(machine_arch_type == MACH_TYPE_MAHIMAHI)
+#else
+# define machine_is_mahimahi()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CLICKC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CLICKC
+# endif
+# define machine_is_clickc()	(machine_arch_type == MACH_TYPE_CLICKC)
+#else
+# define machine_is_clickc()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ZB_GATEWAY
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ZB_GATEWAY
+# endif
+# define machine_is_zb_gateway()	(machine_arch_type == MACH_TYPE_ZB_GATEWAY)
+#else
+# define machine_is_zb_gateway()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TAZCARD
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TAZCARD
+# endif
+# define machine_is_tazcard()	(machine_arch_type == MACH_TYPE_TAZCARD)
+#else
+# define machine_is_tazcard()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TAZDEV
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TAZDEV
+# endif
+# define machine_is_tazdev()	(machine_arch_type == MACH_TYPE_TAZDEV)
+#else
+# define machine_is_tazdev()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ANNAX_CB_ARM
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ANNAX_CB_ARM
+# endif
+# define machine_is_annax_cb_arm()	(machine_arch_type == MACH_TYPE_ANNAX_CB_ARM)
+#else
+# define machine_is_annax_cb_arm()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ANNAX_DM3
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ANNAX_DM3
+# endif
+# define machine_is_annax_dm3()	(machine_arch_type == MACH_TYPE_ANNAX_DM3)
+#else
+# define machine_is_annax_dm3()	(0)
+#endif
+
+#ifdef CONFIG_MACH_CEREBRIC
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_CEREBRIC
+# endif
+# define machine_is_cerebric()	(machine_arch_type == MACH_TYPE_CEREBRIC)
+#else
+# define machine_is_cerebric()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ORCA
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ORCA
+# endif
+# define machine_is_orca()	(machine_arch_type == MACH_TYPE_ORCA)
+#else
+# define machine_is_orca()	(0)
+#endif
+
+#ifdef CONFIG_MACH_PC9260
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_PC9260
+# endif
+# define machine_is_pc9260()	(machine_arch_type == MACH_TYPE_PC9260)
+#else
+# define machine_is_pc9260()	(0)
+#endif
+
+#ifdef CONFIG_MACH_EMS285A
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_EMS285A
+# endif
+# define machine_is_ems285a()	(machine_arch_type == MACH_TYPE_EMS285A)
+#else
+# define machine_is_ems285a()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GEC2410
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GEC2410
+# endif
+# define machine_is_gec2410()	(machine_arch_type == MACH_TYPE_GEC2410)
+#else
+# define machine_is_gec2410()	(0)
+#endif
+
+#ifdef CONFIG_MACH_GEC2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_GEC2440
+# endif
+# define machine_is_gec2440()	(machine_arch_type == MACH_TYPE_GEC2440)
+#else
+# define machine_is_gec2440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ARCH_MW903
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ARCH_MW903
+# endif
+# define machine_is_mw903()	(machine_arch_type == MACH_TYPE_ARCH_MW903)
+#else
+# define machine_is_mw903()	(0)
+#endif
+
+#ifdef CONFIG_MACH_MW2440
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_MW2440
+# endif
+# define machine_is_mw2440()	(machine_arch_type == MACH_TYPE_MW2440)
+#else
+# define machine_is_mw2440()	(0)
+#endif
+
+#ifdef CONFIG_MACH_ECAC2378
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_ECAC2378
+# endif
+# define machine_is_ecac2378()	(machine_arch_type == MACH_TYPE_ECAC2378)
+#else
+# define machine_is_ecac2378()	(0)
+#endif
+
+#ifdef CONFIG_MACH_TAZKIOSK
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_TAZKIOSK
+# endif
+# define machine_is_tazkiosk()	(machine_arch_type == MACH_TYPE_TAZKIOSK)
+#else
+# define machine_is_tazkiosk()	(0)
+#endif
+
+#ifdef CONFIG_MACH_WHITERABBIT_MCH
+# ifdef machine_arch_type
+#  undef machine_arch_type
+#  define machine_arch_type	__machine_arch_type
+# else
+#  define machine_arch_type	MACH_TYPE_WHITERABBIT_MCH
+# endif
+# define machine_is_whiterabbit_mch()	(machine_arch_type == MACH_TYPE_WHITERABBIT_MCH)
+#else
+# define machine_is_whiterabbit_mch()	(0)
+#endif
+
 /*
  * These have not yet been registered
  */
-/* #define MACH_TYPE_367                  <<not registered>> */
-#define machine_is_esl_wireless_tab()	(0)
 
 #ifndef machine_arch_type
 #define machine_arch_type	__machine_arch_type
diff -N -r -up ./u-boot-1.3.4.orig/include/configs/at91sam9260ek.h ./u-boot-1.3.4/include/configs/at91sam9260ek.h
--- ./u-boot-1.3.4.orig/include/configs/at91sam9260ek.h	2008-08-12 16:08:38.000000000 +0200
+++ ./u-boot-1.3.4/include/configs/at91sam9260ek.h	2009-06-01 18:05:21.000000000 +0200
@@ -127,10 +127,6 @@
 #define CFG_MEMTEST_START		PHYS_SDRAM
 #define CFG_MEMTEST_END			0x23e00000
 
-#undef CFG_USE_DATAFLASH_CS0
-#define CFG_USE_DATAFLASH_CS1		1
-#undef CFG_USE_NANDFLASH
-
 #ifdef CFG_USE_DATAFLASH_CS0
 
 /* bootstrap + u-boot + env + linux in dataflash on CS0 */
diff -N -r -up ./u-boot-1.3.4.orig/include/configs/at91sam9261ek.h ./u-boot-1.3.4/include/configs/at91sam9261ek.h
--- ./u-boot-1.3.4.orig/include/configs/at91sam9261ek.h	2008-08-12 16:08:38.000000000 +0200
+++ ./u-boot-1.3.4/include/configs/at91sam9261ek.h	2009-06-01 18:05:21.000000000 +0200
@@ -142,9 +142,6 @@
 #define CFG_MEMTEST_START		PHYS_SDRAM
 #define CFG_MEMTEST_END			0x23e00000
 
-#define CFG_USE_DATAFLASH_CS0		1
-#undef CFG_USE_NANDFLASH
-
 #ifdef CFG_USE_DATAFLASH_CS0
 
 /* bootstrap + u-boot + env + linux in dataflash on CS0 */
@@ -159,6 +156,20 @@
 				"mtdparts=at91_nand:-(root) "		\
 				"rw rootfstype=jffs2"
 
+#elif CFG_USE_DATAFLASH_CS3
+
+/* bootstrap + u-boot + env + linux in dataflash on CS3 */
+#define CFG_ENV_IS_IN_DATAFLASH	1
+#define CFG_MONITOR_BASE	(CFG_DATAFLASH_LOGIC_ADDR_CS3 + 0x8400)
+#define CFG_ENV_OFFSET		0x4200
+#define CFG_ENV_ADDR		(CFG_DATAFLASH_LOGIC_ADDR_CS3 + CFG_ENV_OFFSET)
+#define CFG_ENV_SIZE		0x4200
+#define CONFIG_BOOTCOMMAND	"cp.b 0xD0042000 0x22000000 0x210000; bootm"
+#define CONFIG_BOOTARGS		"console=ttyS0,115200 "			\
+				"root=/dev/mtdblock0 "			\
+				"mtdparts=at91_nand:-(root) "		\
+				"rw rootfstype=jffs2"
+
 #else /* CFG_USE_NANDFLASH */
 
 /* bootstrap + u-boot + env + linux in nandflash */
diff -N -r -up ./u-boot-1.3.4.orig/include/configs/at91sam9263ek.h ./u-boot-1.3.4/include/configs/at91sam9263ek.h
--- ./u-boot-1.3.4.orig/include/configs/at91sam9263ek.h	2008-08-12 16:08:38.000000000 +0200
+++ ./u-boot-1.3.4/include/configs/at91sam9263ek.h	2009-06-01 18:07:30.000000000 +0200
@@ -29,8 +29,12 @@
 
 /* ARM asynchronous clock */
 #define AT91_CPU_NAME		"AT91SAM9263"
-#define AT91_MAIN_CLOCK		199919000	/* from 16.367 MHz crystal */
-#define AT91_MASTER_CLOCK	99959500	/* peripheral = main / 2 */
+
+// T.W. - fixed crystal value to 18.432 MHz
+
+#define AT91_MAIN_CLOCK		198656000	/* from 16.367 MHz crystal */
+#define AT91_MASTER_CLOCK	(AT91_MAIN_CLOCK/2)	/* peripheral = main / 2 */
+
 #define CFG_HZ			1000000		/* 1us resolution */
 
 #define AT91_SLOW_CLOCK		32768	/* slow clock */
@@ -148,9 +152,6 @@
 #define CFG_MEMTEST_START		PHYS_SDRAM
 #define CFG_MEMTEST_END			0x23e00000
 
-#define CFG_USE_DATAFLASH		1
-#undef CFG_USE_NANDFLASH
-
 #ifdef CFG_USE_DATAFLASH
 
 /* bootstrap + u-boot + env + linux in dataflash on CS0 */
diff -N -r -up ./u-boot-1.3.4.orig/include/configs/at91sam9g20ek.h ./u-boot-1.3.4/include/configs/at91sam9g20ek.h
--- ./u-boot-1.3.4.orig/include/configs/at91sam9g20ek.h	1970-01-01 01:00:00.000000000 +0100
+++ ./u-boot-1.3.4/include/configs/at91sam9g20ek.h	2009-06-01 18:05:21.000000000 +0200
@@ -0,0 +1,198 @@
+/*
+ * (C) Copyright 2007-2008
+ * Stelian Pop <stelian.pop@leadtechdesign.com>
+ * Lead Tech Design <www.leadtechdesign.com>
+ *
+ * Configuation settings for the AT91SAM9G20EK board.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/* ARM asynchronous clock */
+#define AT91_MAIN_CLOCK		396288000	/* from 18.432 MHz crystal */
+#define AT91_MASTER_CLOCK	132096000	/* peripheral = main / 3 */
+#define CFG_HZ			1000000		/* 1us resolution */
+
+#define AT91_SLOW_CLOCK		32768	/* slow clock */
+
+#define CONFIG_ARM926EJS	1	/* This is an ARM926EJS Core	*/
+#define CONFIG_AT91SAM9G20	1	/* It's an Atmel AT91SAM9G20 SoC*/
+#define CONFIG_AT91SAM9G20EK	1	/* on an AT91SAM9G20EK Board	*/
+#undef CONFIG_USE_IRQ			/* we don't need IRQ/FIQ stuff	*/
+
+#define CONFIG_CMDLINE_TAG	1	/* enable passing of ATAGs	*/
+#define CONFIG_SETUP_MEMORY_TAGS 1
+#define CONFIG_INITRD_TAG	1
+
+#define CONFIG_SKIP_LOWLEVEL_INIT
+#define CONFIG_SKIP_RELOCATE_UBOOT
+
+/*
+ * Hardware drivers
+ */
+#define CONFIG_ATMEL_USART	1
+#undef CONFIG_USART0
+#undef CONFIG_USART1
+#undef CONFIG_USART2
+#define CONFIG_USART3		1	/* USART 3 is DBGU */
+
+#define CONFIG_BOOTDELAY	3
+
+/*
+ * BOOTP options
+ */
+#define CONFIG_BOOTP_BOOTFILESIZE	1
+#define CONFIG_BOOTP_BOOTPATH		1
+#define CONFIG_BOOTP_GATEWAY		1
+#define CONFIG_BOOTP_HOSTNAME		1
+
+/*
+ * Command line configuration.
+ */
+#include <config_cmd_default.h>
+#undef CONFIG_CMD_BDI
+#undef CONFIG_CMD_IMI
+#undef CONFIG_CMD_AUTOSCRIPT
+#undef CONFIG_CMD_FPGA
+#undef CONFIG_CMD_LOADS
+#undef CONFIG_CMD_IMLS
+
+#define CONFIG_CMD_PING		1
+#define CONFIG_CMD_DHCP		1
+#define CONFIG_CMD_NAND		1
+#define CONFIG_CMD_USB		1
+
+/* SDRAM */
+#define CONFIG_NR_DRAM_BANKS		1
+#define PHYS_SDRAM			0x20000000
+#define PHYS_SDRAM_SIZE			0x04000000	/* 64 megs */
+
+/* DataFlash */
+#define CONFIG_HAS_DATAFLASH		1
+#define CFG_SPI_WRITE_TOUT		(5*CFG_HZ)
+#define CFG_MAX_DATAFLASH_BANKS		2
+#define CFG_DATAFLASH_LOGIC_ADDR_CS0	0xC0000000	/* CS0 */
+#define CFG_DATAFLASH_LOGIC_ADDR_CS1	0xD0000000	/* CS1 */
+#define AT91_SPI_CLK			15000000
+#define DATAFLASH_TCSS			(0x22 << 16)
+#define DATAFLASH_TCHS			(0x1 << 24)
+
+/* NAND flash */
+#define NAND_MAX_CHIPS			1
+#define CFG_MAX_NAND_DEVICE		1
+#define CFG_NAND_BASE			0x40000000
+#define CFG_NAND_DBW_8			1
+
+/* NOR flash - no real flash on this board */
+#define CFG_NO_FLASH			1
+
+/* Ethernet */
+#define CONFIG_MACB			1
+#define CONFIG_RMII			1
+#define CONFIG_NET_MULTI		1
+#define CONFIG_NET_RETRY_COUNT		20
+#define CONFIG_RESET_PHY_R		1
+
+/* USB */
+#define CONFIG_USB_OHCI_NEW		1
+#define LITTLEENDIAN			1
+#define CONFIG_DOS_PARTITION		1
+#define CFG_USB_OHCI_CPU_INIT		1
+#define CFG_USB_OHCI_REGS_BASE		0x00500000	/* AT91SAM9G20_UHP_BASE */
+#define CFG_USB_OHCI_SLOT_NAME		"at91sam9g20"
+#define CFG_USB_OHCI_MAX_ROOT_PORTS	2
+#define CONFIG_USB_STORAGE		1
+
+#define CFG_LOAD_ADDR			0x22000000	/* load address */
+
+#define CFG_MEMTEST_START		PHYS_SDRAM
+#define CFG_MEMTEST_END			0x23e00000
+
+#ifdef CFG_USE_DATAFLASH_CS0
+
+/* bootstrap + u-boot + env + linux in dataflash on CS0 */
+#define CFG_ENV_IS_IN_DATAFLASH	1
+#define CFG_MONITOR_BASE	(CFG_DATAFLASH_LOGIC_ADDR_CS0 + 0x8400)
+#define CFG_ENV_OFFSET		0x4200
+#define CFG_ENV_ADDR		(CFG_DATAFLASH_LOGIC_ADDR_CS0 + CFG_ENV_OFFSET)
+#define CFG_ENV_SIZE		0x4200
+#define CONFIG_BOOTCOMMAND	"cp.b 0xC0042000 0x22000000 0x210000; bootm"
+#define CONFIG_BOOTARGS		"console=ttyS0,115200 "			\
+				"root=/dev/mtdblock0 "			\
+				"mtdparts=at91_nand:-(root) "		\
+				"rw rootfstype=jffs2"
+
+#elif CFG_USE_DATAFLASH_CS1
+
+/* bootstrap + u-boot + env + linux in dataflash on CS1 */
+#define CFG_ENV_IS_IN_DATAFLASH	1
+#define CFG_MONITOR_BASE	(CFG_DATAFLASH_LOGIC_ADDR_CS1 + 0x8400)
+#define CFG_ENV_OFFSET		0x4200
+#define CFG_ENV_ADDR		(CFG_DATAFLASH_LOGIC_ADDR_CS1 + CFG_ENV_OFFSET)
+#define CFG_ENV_SIZE		0x4200
+#define CONFIG_BOOTCOMMAND	"cp.b 0xD0042000 0x22000000 0x210000; bootm"
+#define CONFIG_BOOTARGS		"console=ttyS0,115200 "			\
+				"root=/dev/mtdblock0 "			\
+				"mtdparts=at91_nand:-(root) "		\
+				"rw rootfstype=jffs2"
+
+#else /* CFG_USE_NANDFLASH */
+
+/* bootstrap + u-boot + env + linux in nandflash */
+#define CFG_ENV_IS_IN_NAND	1
+#define CFG_ENV_OFFSET		0x60000
+#define CFG_ENV_OFFSET_REDUND	0x80000
+#define CFG_ENV_SIZE		0x20000		/* 1 sector = 128 kB */
+#define CONFIG_BOOTCOMMAND	"nand read 0x22000000 0xA0000 0x200000; bootm"
+#define CONFIG_BOOTARGS		"console=ttyS0,115200 "			\
+				"root=/dev/mtdblock5 "			\
+				"mtdparts=at91_nand:128k(bootstrap)ro,"	\
+				"256k(uboot)ro,128k(env1)ro,"		\
+				"128k(env2)ro,2M(linux),-(root) "	\
+				"rw rootfstype=jffs2"
+
+#endif
+
+#define CONFIG_BAUDRATE		115200
+#define CFG_BAUDRATE_TABLE	{115200 , 19200, 38400, 57600, 9600 }
+
+#define CFG_PROMPT		"U-Boot> "
+#define CFG_CBSIZE		256
+#define CFG_MAXARGS		16
+#define CFG_PBSIZE		(CFG_CBSIZE + sizeof(CFG_PROMPT) + 16)
+#define CFG_LONGHELP		1
+#define CONFIG_CMDLINE_EDITING	1
+
+#define ROUND(A, B)		(((A) + (B)) & ~((B) - 1))
+/*
+ * Size of malloc() pool
+ */
+#define CFG_MALLOC_LEN		ROUND(3 * CFG_ENV_SIZE + 128*1024, 0x1000)
+#define CFG_GBL_DATA_SIZE	128	/* 128 bytes for initial data */
+
+#define CONFIG_STACKSIZE	(32*1024)	/* regular stack */
+
+#ifdef CONFIG_USE_IRQ
+#error CONFIG_USE_IRQ not supported
+#endif
+
+#endif
diff -N -r -up ./u-boot-1.3.4.orig/include/configs/at91sam9rlek.h ./u-boot-1.3.4/include/configs/at91sam9rlek.h
--- ./u-boot-1.3.4.orig/include/configs/at91sam9rlek.h	2008-08-12 16:08:38.000000000 +0200
+++ ./u-boot-1.3.4/include/configs/at91sam9rlek.h	2009-06-01 18:05:21.000000000 +0200
@@ -117,9 +117,6 @@
 #define CFG_MEMTEST_START		PHYS_SDRAM
 #define CFG_MEMTEST_END			0x23e00000
 
-#define CFG_USE_DATAFLASH		1
-#undef CFG_USE_NANDFLASH
-
 #ifdef CFG_USE_DATAFLASH
 
 /* bootstrap + u-boot + env + linux in dataflash on CS0 */
diff -N -r -up ./u-boot-1.3.4.orig/include/configs/whiterabbit_mch.h ./u-boot-1.3.4/include/configs/whiterabbit_mch.h
--- ./u-boot-1.3.4.orig/include/configs/whiterabbit_mch.h	1970-01-01 01:00:00.000000000 +0100
+++ ./u-boot-1.3.4/include/configs/whiterabbit_mch.h	2009-07-09 05:27:15.000000000 +0200
@@ -0,0 +1,181 @@
+/*
+ * (C) Copyright 2007-2008
+ * Stelian Pop <stelian.pop@leadtechdesign.com>
+ * Lead Tech Design <www.leadtechdesign.com>
+ *
+ * Configuation settings for the AT91SAM9263EK board.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+/* ARM asynchronous clock */
+#define AT91_CPU_NAME		"AT91SAM9263"
+
+// T.W. - fixed crystal value to 18.432 MHz
+
+#define AT91_MAIN_CLOCK		198656000	/* from 16.367 MHz crystal */
+#define AT91_MASTER_CLOCK	(AT91_MAIN_CLOCK/2)	/* peripheral = main / 2 */
+
+#define CFG_HZ			1000000		/* 1us resolution */
+
+#define AT91_SLOW_CLOCK		32768	/* slow clock */
+
+#define CONFIG_ARM926EJS	1	/* This is an ARM926EJS Core	*/
+#define CONFIG_AT91SAM9263	1	/* It's an Atmel AT91SAM9263 SoC*/
+#define CONFIG_WHITERABBIT_MCH	1	/* on an AT91SAM9263EK Board	*/
+#undef CONFIG_USE_IRQ			/* we don't need IRQ/FIQ stuff	*/
+
+#define CONFIG_CMDLINE_TAG	1	/* enable passing of ATAGs	*/
+#define CONFIG_SETUP_MEMORY_TAGS 1
+#define CONFIG_INITRD_TAG	1
+
+#define CONFIG_SKIP_LOWLEVEL_INIT
+#define CONFIG_SKIP_RELOCATE_UBOOT
+
+/*
+ * Hardware drivers
+ */
+#define CONFIG_ATMEL_USART	1
+#undef CONFIG_USART0
+#undef CONFIG_USART1
+#undef CONFIG_USART2
+#define CONFIG_USART3		1	/* USART 3 is DBGU */
+
+#define CONFIG_BOOTDELAY	3
+
+#define CONFIG_BOOTP_BOOTFILESIZE	1
+#define CONFIG_BOOTP_BOOTPATH		1
+#define CONFIG_BOOTP_GATEWAY		1
+#define CONFIG_BOOTP_HOSTNAME		1
+
+/*
+ * Command line configuration.
+ */
+#include <config_cmd_default.h>
+#undef CONFIG_CMD_BDI
+#undef CONFIG_CMD_IMI
+#undef CONFIG_CMD_AUTOSCRIPT
+#undef CONFIG_CMD_FPGA
+#undef CONFIG_CMD_LOADS
+#undef CONFIG_CMD_IMLS
+
+#define CONFIG_CMD_PING		1
+#define CONFIG_CMD_DHCP		1
+#define CONFIG_CMD_NAND		1
+
+/* SDRAM */
+#define CONFIG_NR_DRAM_BANKS		1
+#define PHYS_SDRAM			0x20000000
+#define PHYS_SDRAM_SIZE			0x04000000	/* 64 megs */
+
+/* DataFlash */
+#define CONFIG_HAS_DATAFLASH		1
+#define CFG_SPI_WRITE_TOUT		(5*CFG_HZ)
+#define CFG_MAX_DATAFLASH_BANKS		1
+#define CFG_DATAFLASH_LOGIC_ADDR_CS0	0xC0000000	/* CS0 */
+#define AT91_SPI_CLK			15000000
+#define DATAFLASH_TCSS			(0x1a << 16)
+#define DATAFLASH_TCHS			(0x1 << 24)
+
+/* NOR flash, if populated */
+#if 1
+#define CFG_NO_FLASH			1
+#else
+#define CFG_FLASH_CFI			1
+#define CFG_FLASH_CFI_DRIVER		1
+#define PHYS_FLASH_1			0x10000000
+#define CFG_FLASH_BASE			PHYS_FLASH_1
+#define CFG_MAX_FLASH_SECT		256
+#define CFG_MAX_FLASH_BANKS		1
+#endif
+
+/* NAND flash */
+#define NAND_MAX_CHIPS			1
+#define CFG_MAX_NAND_DEVICE		1
+#define CFG_NAND_BASE			0x40000000
+#define CFG_NAND_DBW_8			1
+
+/* Ethernet */
+#define CONFIG_MACB			1
+#define CONFIG_RMII			1
+#define CONFIG_NET_MULTI		1
+#define CONFIG_NET_RETRY_COUNT		20
+#define CONFIG_RESET_PHY_R		1
+
+#define CFG_LOAD_ADDR			0x22000000	/* load address */
+
+#define CFG_MEMTEST_START		PHYS_SDRAM
+#define CFG_MEMTEST_END			0x23e00000
+
+#ifdef CFG_USE_DATAFLASH
+
+/* bootstrap + u-boot + env + linux in dataflash on CS0 */
+#define CFG_ENV_IS_IN_DATAFLASH	1
+#define CFG_MONITOR_BASE	(CFG_DATAFLASH_LOGIC_ADDR_CS0 + 0x8400)
+#define CFG_ENV_OFFSET		0x4200
+#define CFG_ENV_ADDR		(CFG_DATAFLASH_LOGIC_ADDR_CS0 + CFG_ENV_OFFSET)
+#define CFG_ENV_SIZE		0x4200
+#define CONFIG_BOOTCOMMAND	"cp.b 0xC0042000 0x22000000 0x210000; bootm"
+#define CONFIG_BOOTARGS		"console=ttyS0,115200 " \
+				"root=/dev/mtdblock0 " \
+				"mtdparts=at91_nand:-(root) "\
+				"rw rootfstype=jffs2"
+
+#else /* CFG_USE_NANDFLASH */
+
+/* bootstrap + u-boot + env + linux in nandflash */
+#define CFG_ENV_IS_IN_NAND	1
+#define CFG_ENV_OFFSET		0x60000
+#define CFG_ENV_OFFSET_REDUND	0x80000
+#define CFG_ENV_SIZE		0x20000		/* 1 sector = 128 kB */
+#define CONFIG_BOOTCOMMAND	"nand read 0x22000000 0xA0000 0x200000; bootm"
+#define CONFIG_BOOTARGS		"console=ttyS0,115200 " \
+				"root=/dev/mtdblock5 " \
+				"mtdparts=at91_nand:128k(bootstrap)ro,256k(uboot)ro,128k(env1)ro,128k(env2)ro,2M(linux),-(root) " \
+				"rw rootfstype=jffs2"
+
+#endif
+
+#define CONFIG_BAUDRATE		115200
+#define CFG_BAUDRATE_TABLE	{115200 , 19200, 38400, 57600, 9600 }
+
+#define CFG_PROMPT		"U-Boot> "
+#define CFG_CBSIZE		256
+#define CFG_MAXARGS		16
+#define CFG_PBSIZE		(CFG_CBSIZE + sizeof(CFG_PROMPT) + 16)
+#define CFG_LONGHELP		1
+#define CONFIG_CMDLINE_EDITING	1
+
+#define ROUND(A, B)		(((A) + (B)) & ~((B) - 1))
+/*
+ * Size of malloc() pool
+ */
+#define CFG_MALLOC_LEN		ROUND(3 * CFG_ENV_SIZE + 128*1024, 0x1000)
+#define CFG_GBL_DATA_SIZE	128	/* 128 bytes for initial data */
+
+#define CONFIG_STACKSIZE	(32*1024)	/* regular stack */
+
+#ifdef CONFIG_USE_IRQ
+#error CONFIG_USE_IRQ not supported
+#endif
+
+#endif
diff -N -r -up ./u-boot-1.3.4.orig/lib_arm/board.c ./u-boot-1.3.4/lib_arm/board.c
--- ./u-boot-1.3.4.orig/lib_arm/board.c	2008-08-12 16:08:38.000000000 +0200
+++ ./u-boot-1.3.4/lib_arm/board.c	2010-01-14 16:00:38.000000000 +0100
@@ -134,20 +134,20 @@ char *strmhz(char *buf, long hz)
  ************************************************************************
  * May be supplied by boards if desired
  */
-void inline __coloured_LED_init (void) {}
-void inline coloured_LED_init (void) __attribute__((weak, alias("__coloured_LED_init")));
-void inline __red_LED_on (void) {}
-void inline red_LED_on (void) __attribute__((weak, alias("__red_LED_on")));
-void inline __red_LED_off(void) {}
-void inline red_LED_off(void)	     __attribute__((weak, alias("__red_LED_off")));
-void inline __green_LED_on(void) {}
-void inline green_LED_on(void) __attribute__((weak, alias("__green_LED_on")));
-void inline __green_LED_off(void) {}
-void inline green_LED_off(void)__attribute__((weak, alias("__green_LED_off")));
-void inline __yellow_LED_on(void) {}
-void inline yellow_LED_on(void)__attribute__((weak, alias("__yellow_LED_on")));
-void inline __yellow_LED_off(void) {}
-void inline yellow_LED_off(void)__attribute__((weak, alias("__yellow_LED_off")));
+void __coloured_LED_init (void) {}
+void  coloured_LED_init (void) __attribute__((weak, alias("__coloured_LED_init")));
+void  __red_LED_on (void) {}
+void  red_LED_on (void) __attribute__((weak, alias("__red_LED_on")));
+void  __red_LED_off(void) {}
+void  red_LED_off(void)	     __attribute__((weak, alias("__red_LED_off")));
+void  __green_LED_on(void) {}
+void  green_LED_on(void) __attribute__((weak, alias("__green_LED_on")));
+void  __green_LED_off(void) {}
+void  green_LED_off(void)__attribute__((weak, alias("__green_LED_off")));
+void  __yellow_LED_on(void) {}
+void  yellow_LED_on(void)__attribute__((weak, alias("__yellow_LED_on")));
+void  __yellow_LED_off(void) {}
+void  yellow_LED_off(void)__attribute__((weak, alias("__yellow_LED_off")));
 
 /************************************************************************
  * Init Utilities							*
diff -N -r -up ./u-boot-1.3.4.orig/Makefile ./u-boot-1.3.4/Makefile
--- ./u-boot-1.3.4.orig/Makefile	2008-08-12 16:08:38.000000000 +0200
+++ ./u-boot-1.3.4/Makefile	2009-07-09 05:22:13.000000000 +0200
@@ -2353,15 +2353,6 @@ shannon_config	:	unconfig
 at91rm9200dk_config	:	unconfig
 	@$(MKCONFIG) $(@:_config=) arm arm920t at91rm9200dk atmel at91rm9200
 
-at91sam9261ek_config	:	unconfig
-	@$(MKCONFIG) $(@:_config=) arm arm926ejs at91sam9261ek atmel at91sam9
-
-at91sam9263ek_config	:	unconfig
-	@$(MKCONFIG) $(@:_config=) arm arm926ejs at91sam9263ek atmel at91sam9
-
-at91sam9rlek_config	:	unconfig
-	@$(MKCONFIG) $(@:_config=) arm arm926ejs at91sam9rlek atmel at91sam9
-
 cmc_pu2_config	:	unconfig
 	@$(MKCONFIG) $(@:_config=) arm arm920t cmc_pu2 NULL at91rm9200
 
@@ -2384,8 +2375,103 @@ mp2usb_config	:	unconfig
 at91cap9adk_config	:	unconfig
 	@$(MKCONFIG) $(@:_config=) arm arm926ejs at91cap9adk atmel at91sam9
 
+at91sam9260ek_nandflash_config \
+at91sam9260ek_dataflash_cs0_config \
+at91sam9260ek_dataflash_cs1_config \
 at91sam9260ek_config	:	unconfig
-	@$(MKCONFIG) $(@:_config=) arm arm926ejs at91sam9260ek atmel at91sam9
+	@if [ "$(findstring _nandflash,$@)" ] ; then \
+		echo "#define CFG_USE_NANDFLASH 1"	>>$(obj)include/config.h ; \
+		$(XECHO) "... with environment variable in NAND FLASH" ; \
+	elif [ "$(findstring dataflash_cs0,$@)" ] ; then \
+		echo "#define CFG_USE_DATAFLASH_CS0 1"	>>$(obj)include/config.h ; \
+		$(XECHO) "... with environment variable in SPI DATAFLASH CS0" ; \
+	else \
+		echo "#define CFG_USE_DATAFLASH_CS1 1"	>>$(obj)include/config.h ; \
+		$(XECHO) "... with environment variable in SPI DATAFLASH CS1" ; \
+	fi;
+	@$(MKCONFIG) -a at91sam9260ek arm arm926ejs at91sam9260ek atmel at91sam9
+
+at91sam9xeek_nandflash_config \
+at91sam9xeek_dataflash_cs0_config \
+at91sam9xeek_dataflash_cs1_config \
+at91sam9xeek_config	:	unconfig
+	@if [ "$(findstring _nandflash,$@)" ] ; then \
+		echo "#define CFG_USE_NANDFLASH 1"	>>$(obj)include/config.h ; \
+		$(XECHO) "... with environment variable in NAND FLASH" ; \
+	elif [ "$(findstring dataflash_cs0,$@)" ] ; then \
+		echo "#define CFG_USE_DATAFLASH_CS0 1"	>>$(obj)include/config.h ; \
+		$(XECHO) "... with environment variable in SPI DATAFLASH CS0" ; \
+	else \
+		echo "#define CFG_USE_DATAFLASH_CS1 1"	>>$(obj)include/config.h ; \
+		$(XECHO) "... with environment variable in SPI DATAFLASH CS1" ; \
+	fi;
+	@$(MKCONFIG) -n at91sam9xeek -a at91sam9260ek arm arm926ejs at91sam9260ek atmel at91sam9
+
+at91sam9g20ek_nandflash_config \
+at91sam9g20ek_dataflash_cs0_config \
+at91sam9g20ek_dataflash_cs1_config \
+at91sam9g20ek_config	:	unconfig
+	@if [ "$(findstring _nandflash,$@)" ] ; then \
+		echo "#define CFG_USE_NANDFLASH 1"	>>$(obj)include/config.h ; \
+		$(XECHO) "... with environment variable in NAND FLASH" ; \
+	elif [ "$(findstring dataflash_cs0,$@)" ] ; then \
+		echo "#define CFG_USE_DATAFLASH_CS0 1"	>>$(obj)include/config.h ; \
+		$(XECHO) "... with environment variable in SPI DATAFLASH CS0" ; \
+	else \
+		echo "#define CFG_USE_DATAFLASH_CS1 1"	>>$(obj)include/config.h ; \
+		$(XECHO) "... with environment variable in SPI DATAFLASH CS1" ; \
+	fi;
+	@$(MKCONFIG) -a at91sam9g20ek arm arm926ejs at91sam9g20ek atmel at91sam9
+
+at91sam9261ek_nandflash_config \
+at91sam9261ek_dataflash_cs0_config \
+at91sam9261ek_dataflash_cs3_config \
+at91sam9261ek_config	:	unconfig
+	@if [ "$(findstring _nandflash,$@)" ] ; then \
+		echo "#define CFG_USE_NANDFLASH 1"	>>$(obj)include/config.h ; \
+		$(XECHO) "... with environment variable in NAND FLASH" ; \
+	elif [ "$(findstring dataflash_cs3,$@)" ] ; then \
+		echo "#define CFG_USE_DATAFLASH_CS3 1"	>>$(obj)include/config.h ; \
+		$(XECHO) "... with environment variable in SPI DATAFLASH CS3" ; \
+	else \
+		echo "#define CFG_USE_DATAFLASH_CS0 1"	>>$(obj)include/config.h ; \
+		$(XECHO) "... with environment variable in SPI DATAFLASH CS0" ; \
+	fi;
+	@$(MKCONFIG) -a at91sam9261ek arm arm926ejs at91sam9261ek atmel at91sam9
+
+at91sam9263ek_nandflash_config \
+at91sam9263ek_dataflash_config \
+at91sam9263ek_dataflash_cs0_config \
+at91sam9263ek_config	:	unconfig
+	@if [ "$(findstring _nandflash,$@)" ] ; then \
+		echo "#define CFG_USE_NANDFLASH 1"	>>$(obj)include/config.h ; \
+		$(XECHO) "... with environment variable in NAND FLASH" ; \
+	else \
+		echo "#define CFG_USE_DATAFLASH 1"	>>$(obj)include/config.h ; \
+		$(XECHO) "... with environment variable in SPI DATAFLASH CS0" ; \
+	fi;
+	@$(MKCONFIG) -a at91sam9263ek arm arm926ejs at91sam9263ek atmel at91sam9
+
+
+whiterabbit_mch	:	unconfig
+	echo "#define CFG_USE_DATAFLASH 1"	>>$(obj)include/config.h ; 
+	@$(MKCONFIG) -a whiterabbit_mch arm arm926ejs whiterabbit_mch atmel at91sam9
+
+
+
+at91sam9rlek_nandflash_config \
+at91sam9rlek_dataflash_config \
+at91sam9rlek_dataflash_cs0_config \
+at91sam9rlek_config	:	unconfig
+	@if [ "$(findstring _nandflash,$@)" ] ; then \
+		echo "#define CFG_USE_NANDFLASH 1"	>>$(obj)include/config.h ; \
+		$(XECHO) "... with environment variable in NAND FLASH" ; \
+	else \
+		echo "#define CFG_USE_DATAFLASH 1"	>>$(obj)include/config.h ; \
+		$(XECHO) "... with environment variable in SPI DATAFLASH CS0" ; \
+	fi;
+	@$(MKCONFIG) -a at91sam9rlek arm arm926ejs at91sam9rlek atmel at91sam9
+
 
 ########################################################################
 ## ARM Integrator boards - see doc/README-integrator for more info.
diff -N -r -up ./u-boot-1.3.4.orig/net/eth.c ./u-boot-1.3.4/net/eth.c
--- ./u-boot-1.3.4.orig/net/eth.c	2008-08-12 16:08:38.000000000 +0200
+++ ./u-boot-1.3.4/net/eth.c	2009-06-01 18:05:21.000000000 +0200
@@ -287,7 +287,7 @@ int eth_initialize(bd_t *bis)
 	mcdmafec_initialize(bis);
 #endif
 #if defined(CONFIG_AT91CAP9) || defined(CONFIG_AT91SAM9260) || \
-    defined(CONFIG_AT91SAM9263)
+    defined(CONFIG_AT91SAM9263) || defined(CONFIG_AT91SAM9G20)
 	at91sam9_eth_initialize(bis);
 #endif
 
diff -N -r -up ./u-boot-1.3.4.orig/tools/crc32.c ./u-boot-1.3.4/tools/crc32.c
--- ./u-boot-1.3.4.orig/tools/crc32.c	1970-01-01 01:00:00.000000000 +0100
+++ ./u-boot-1.3.4/tools/crc32.c	2008-08-12 16:08:38.000000000 +0200
@@ -0,0 +1,229 @@
+/*
+ * This file is derived from crc32.c from the zlib-1.1.3 distribution
+ * by Jean-loup Gailly and Mark Adler.
+ */
+
+/* crc32.c -- compute the CRC-32 of a data stream
+ * Copyright (C) 1995-1998 Mark Adler
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+#ifndef USE_HOSTCC	/* Shut down "ANSI does not permit..." warnings */
+#include <common.h>
+#else
+#include <stdint.h>
+#endif
+
+#if defined(CONFIG_HW_WATCHDOG) || defined(CONFIG_WATCHDOG)
+#include <watchdog.h>
+#endif
+#include "zlib.h"
+
+#define local static
+#define ZEXPORT	/* empty */
+
+#ifdef DYNAMIC_CRC_TABLE
+
+local int crc_table_empty = 1;
+local uint32_t crc_table[256];
+local void make_crc_table OF((void));
+
+/*
+  Generate a table for a byte-wise 32-bit CRC calculation on the polynomial:
+  x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.
+
+  Polynomials over GF(2) are represented in binary, one bit per coefficient,
+  with the lowest powers in the most significant bit.  Then adding polynomials
+  is just exclusive-or, and multiplying a polynomial by x is a right shift by
+  one.  If we call the above polynomial p, and represent a byte as the
+  polynomial q, also with the lowest power in the most significant bit (so the
+  byte 0xb1 is the polynomial x^7+x^3+x+1), then the CRC is (q*x^32) mod p,
+  where a mod b means the remainder after dividing a by b.
+
+  This calculation is done using the shift-register method of multiplying and
+  taking the remainder.  The register is initialized to zero, and for each
+  incoming bit, x^32 is added mod p to the register if the bit is a one (where
+  x^32 mod p is p+x^32 = x^26+...+1), and the register is multiplied mod p by
+  x (which is shifting right by one and adding x^32 mod p if the bit shifted
+  out is a one).  We start with the highest power (least significant bit) of
+  q and repeat for all eight bits of q.
+
+  The table is simply the CRC of all possible eight bit values.  This is all
+  the information needed to generate CRC's on data a byte at a time for all
+  combinations of CRC register values and incoming bytes.
+*/
+local void make_crc_table()
+{
+  uint32_t c;
+  int n, k;
+  uLong poly;		/* polynomial exclusive-or pattern */
+  /* terms of polynomial defining this crc (except x^32): */
+  static const Byte p[] = {0,1,2,4,5,7,8,10,11,12,16,22,23,26};
+
+  /* make exclusive-or pattern from polynomial (0xedb88320L) */
+  poly = 0L;
+  for (n = 0; n < sizeof(p)/sizeof(Byte); n++)
+    poly |= 1L << (31 - p[n]);
+
+  for (n = 0; n < 256; n++)
+  {
+    c = (uLong)n;
+    for (k = 0; k < 8; k++)
+      c = c & 1 ? poly ^ (c >> 1) : c >> 1;
+    crc_table[n] = c;
+  }
+  crc_table_empty = 0;
+}
+#else
+/* ========================================================================
+ * Table of CRC-32's of all single-byte values (made by make_crc_table)
+ */
+local const uint32_t crc_table[256] = {
+  0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL, 0x076dc419L,
+  0x706af48fL, 0xe963a535L, 0x9e6495a3L, 0x0edb8832L, 0x79dcb8a4L,
+  0xe0d5e91eL, 0x97d2d988L, 0x09b64c2bL, 0x7eb17cbdL, 0xe7b82d07L,
+  0x90bf1d91L, 0x1db71064L, 0x6ab020f2L, 0xf3b97148L, 0x84be41deL,
+  0x1adad47dL, 0x6ddde4ebL, 0xf4d4b551L, 0x83d385c7L, 0x136c9856L,
+  0x646ba8c0L, 0xfd62f97aL, 0x8a65c9ecL, 0x14015c4fL, 0x63066cd9L,
+  0xfa0f3d63L, 0x8d080df5L, 0x3b6e20c8L, 0x4c69105eL, 0xd56041e4L,
+  0xa2677172L, 0x3c03e4d1L, 0x4b04d447L, 0xd20d85fdL, 0xa50ab56bL,
+  0x35b5a8faL, 0x42b2986cL, 0xdbbbc9d6L, 0xacbcf940L, 0x32d86ce3L,
+  0x45df5c75L, 0xdcd60dcfL, 0xabd13d59L, 0x26d930acL, 0x51de003aL,
+  0xc8d75180L, 0xbfd06116L, 0x21b4f4b5L, 0x56b3c423L, 0xcfba9599L,
+  0xb8bda50fL, 0x2802b89eL, 0x5f058808L, 0xc60cd9b2L, 0xb10be924L,
+  0x2f6f7c87L, 0x58684c11L, 0xc1611dabL, 0xb6662d3dL, 0x76dc4190L,
+  0x01db7106L, 0x98d220bcL, 0xefd5102aL, 0x71b18589L, 0x06b6b51fL,
+  0x9fbfe4a5L, 0xe8b8d433L, 0x7807c9a2L, 0x0f00f934L, 0x9609a88eL,
+  0xe10e9818L, 0x7f6a0dbbL, 0x086d3d2dL, 0x91646c97L, 0xe6635c01L,
+  0x6b6b51f4L, 0x1c6c6162L, 0x856530d8L, 0xf262004eL, 0x6c0695edL,
+  0x1b01a57bL, 0x8208f4c1L, 0xf50fc457L, 0x65b0d9c6L, 0x12b7e950L,
+  0x8bbeb8eaL, 0xfcb9887cL, 0x62dd1ddfL, 0x15da2d49L, 0x8cd37cf3L,
+  0xfbd44c65L, 0x4db26158L, 0x3ab551ceL, 0xa3bc0074L, 0xd4bb30e2L,
+  0x4adfa541L, 0x3dd895d7L, 0xa4d1c46dL, 0xd3d6f4fbL, 0x4369e96aL,
+  0x346ed9fcL, 0xad678846L, 0xda60b8d0L, 0x44042d73L, 0x33031de5L,
+  0xaa0a4c5fL, 0xdd0d7cc9L, 0x5005713cL, 0x270241aaL, 0xbe0b1010L,
+  0xc90c2086L, 0x5768b525L, 0x206f85b3L, 0xb966d409L, 0xce61e49fL,
+  0x5edef90eL, 0x29d9c998L, 0xb0d09822L, 0xc7d7a8b4L, 0x59b33d17L,
+  0x2eb40d81L, 0xb7bd5c3bL, 0xc0ba6cadL, 0xedb88320L, 0x9abfb3b6L,
+  0x03b6e20cL, 0x74b1d29aL, 0xead54739L, 0x9dd277afL, 0x04db2615L,
+  0x73dc1683L, 0xe3630b12L, 0x94643b84L, 0x0d6d6a3eL, 0x7a6a5aa8L,
+  0xe40ecf0bL, 0x9309ff9dL, 0x0a00ae27L, 0x7d079eb1L, 0xf00f9344L,
+  0x8708a3d2L, 0x1e01f268L, 0x6906c2feL, 0xf762575dL, 0x806567cbL,
+  0x196c3671L, 0x6e6b06e7L, 0xfed41b76L, 0x89d32be0L, 0x10da7a5aL,
+  0x67dd4accL, 0xf9b9df6fL, 0x8ebeeff9L, 0x17b7be43L, 0x60b08ed5L,
+  0xd6d6a3e8L, 0xa1d1937eL, 0x38d8c2c4L, 0x4fdff252L, 0xd1bb67f1L,
+  0xa6bc5767L, 0x3fb506ddL, 0x48b2364bL, 0xd80d2bdaL, 0xaf0a1b4cL,
+  0x36034af6L, 0x41047a60L, 0xdf60efc3L, 0xa867df55L, 0x316e8eefL,
+  0x4669be79L, 0xcb61b38cL, 0xbc66831aL, 0x256fd2a0L, 0x5268e236L,
+  0xcc0c7795L, 0xbb0b4703L, 0x220216b9L, 0x5505262fL, 0xc5ba3bbeL,
+  0xb2bd0b28L, 0x2bb45a92L, 0x5cb36a04L, 0xc2d7ffa7L, 0xb5d0cf31L,
+  0x2cd99e8bL, 0x5bdeae1dL, 0x9b64c2b0L, 0xec63f226L, 0x756aa39cL,
+  0x026d930aL, 0x9c0906a9L, 0xeb0e363fL, 0x72076785L, 0x05005713L,
+  0x95bf4a82L, 0xe2b87a14L, 0x7bb12baeL, 0x0cb61b38L, 0x92d28e9bL,
+  0xe5d5be0dL, 0x7cdcefb7L, 0x0bdbdf21L, 0x86d3d2d4L, 0xf1d4e242L,
+  0x68ddb3f8L, 0x1fda836eL, 0x81be16cdL, 0xf6b9265bL, 0x6fb077e1L,
+  0x18b74777L, 0x88085ae6L, 0xff0f6a70L, 0x66063bcaL, 0x11010b5cL,
+  0x8f659effL, 0xf862ae69L, 0x616bffd3L, 0x166ccf45L, 0xa00ae278L,
+  0xd70dd2eeL, 0x4e048354L, 0x3903b3c2L, 0xa7672661L, 0xd06016f7L,
+  0x4969474dL, 0x3e6e77dbL, 0xaed16a4aL, 0xd9d65adcL, 0x40df0b66L,
+  0x37d83bf0L, 0xa9bcae53L, 0xdebb9ec5L, 0x47b2cf7fL, 0x30b5ffe9L,
+  0xbdbdf21cL, 0xcabac28aL, 0x53b39330L, 0x24b4a3a6L, 0xbad03605L,
+  0xcdd70693L, 0x54de5729L, 0x23d967bfL, 0xb3667a2eL, 0xc4614ab8L,
+  0x5d681b02L, 0x2a6f2b94L, 0xb40bbe37L, 0xc30c8ea1L, 0x5a05df1bL,
+  0x2d02ef8dL
+};
+#endif
+
+#if 0
+/* =========================================================================
+ * This function can be used by asm versions of crc32()
+ */
+const uint32_t * ZEXPORT get_crc_table()
+{
+#ifdef DYNAMIC_CRC_TABLE
+  if (crc_table_empty) make_crc_table();
+#endif
+  return (const uint32_t *)crc_table;
+}
+#endif
+
+/* ========================================================================= */
+#define DO1(buf) crc = crc_table[((int)crc ^ (*buf++)) & 0xff] ^ (crc >> 8);
+#define DO2(buf)  DO1(buf); DO1(buf);
+#define DO4(buf)  DO2(buf); DO2(buf);
+#define DO8(buf)  DO4(buf); DO4(buf);
+
+/* ========================================================================= */
+uint32_t ZEXPORT crc32 (uint32_t crc, const Bytef *buf, uInt len)
+{
+#ifdef DYNAMIC_CRC_TABLE
+    if (crc_table_empty)
+      make_crc_table();
+#endif
+    crc = crc ^ 0xffffffffL;
+    while (len >= 8)
+    {
+      DO8(buf);
+      len -= 8;
+    }
+    if (len) do {
+      DO1(buf);
+    } while (--len);
+    return crc ^ 0xffffffffL;
+}
+
+#if defined(CONFIG_CMD_JFFS2) || \
+	(defined(CONFIG_CMD_NAND) \
+	&& !defined(CFG_NAND_LEGACY))
+
+/* No ones complement version. JFFS2 (and other things ?)
+ * don't use ones compliment in their CRC calculations.
+ */
+uint32_t ZEXPORT crc32_no_comp(uint32_t crc, const Bytef *buf, uInt len)
+{
+#ifdef DYNAMIC_CRC_TABLE
+    if (crc_table_empty)
+      make_crc_table();
+#endif
+    while (len >= 8)
+    {
+      DO8(buf);
+      len -= 8;
+    }
+    if (len) do {
+      DO1(buf);
+    } while (--len);
+
+    return crc;
+}
+
+#endif
+
+/*
+ * Calculate the crc32 checksum triggering the watchdog every 'chunk_sz' bytes
+ * of input.
+ */
+uint32_t ZEXPORT crc32_wd (uint32_t crc,
+			   const unsigned char *buf,
+			   uInt len, uInt chunk_sz)
+{
+#if defined(CONFIG_HW_WATCHDOG) || defined(CONFIG_WATCHDOG)
+	const unsigned char *end, *curr;
+	int chunk;
+
+	curr = buf;
+	end = buf + len;
+	while (curr < end) {
+		chunk = end - curr;
+		if (chunk > chunk_sz)
+			chunk = chunk_sz;
+		crc = crc32 (crc, curr, chunk);
+		curr += chunk;
+		WATCHDOG_RESET ();
+	}
+#else
+	crc = crc32 (crc, buf, len);
+#endif
+
+	return crc;
+}
diff -N -r -up ./u-boot-1.3.4.orig/tools/environment.c ./u-boot-1.3.4/tools/environment.c
--- ./u-boot-1.3.4.orig/tools/environment.c	1970-01-01 01:00:00.000000000 +0100
+++ ./u-boot-1.3.4/tools/environment.c	2008-08-12 16:08:38.000000000 +0200
@@ -0,0 +1,208 @@
+/*
+ * (C) Copyright 2001
+ * Erik Theisen,  Wave 7 Optics, etheisen@mindspring.com.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef __ASSEMBLY__
+#define	__ASSEMBLY__			/* Dirty trick to get only #defines	*/
+#endif
+#define	__ASM_STUB_PROCESSOR_H__	/* don't include asm/processor.		*/
+#include <config.h>
+#undef	__ASSEMBLY__
+#include <environment.h>
+
+/*
+ * Handle HOSTS that have prepended
+ * crap on symbol names, not TARGETS.
+ */
+#if defined(__APPLE__)
+/* Leading underscore on symbols */
+#  define SYM_CHAR "_"
+#else /* No leading character on symbols */
+#  define SYM_CHAR
+#endif
+
+/*
+ * Generate embedded environment table
+ * inside U-Boot image, if needed.
+ */
+#if defined(ENV_IS_EMBEDDED)
+/*
+ * Only put the environment in it's own section when we are building
+ * U-Boot proper.  The host based program "tools/envcrc" does not need
+ * a seperate section.  Note that ENV_CRC is only defined when building
+ * U-Boot itself.
+ */
+#if (defined(CFG_USE_PPCENV) || defined(CONFIG_NAND_U_BOOT)) && \
+     defined(ENV_CRC) /* Environment embedded in U-Boot .ppcenv section */
+/* XXX - This only works with GNU C */
+#  define __PPCENV__ __attribute__ ((section(".ppcenv")))
+#  define __PPCTEXT__ __attribute__ ((section(".text")))
+
+#elif defined(USE_HOSTCC) /* Native for 'tools/envcrc' */
+#  define __PPCENV__ /*XXX DO_NOT_DEL_THIS_COMMENT*/
+#  define __PPCTEXT__ /*XXX DO_NOT_DEL_THIS_COMMENT*/
+
+#else /* Environment is embedded in U-Boot's .text section */
+/* XXX - This only works with GNU C */
+#  define __PPCENV__ __attribute__ ((section(".text")))
+#  define __PPCTEXT__ __attribute__ ((section(".text")))
+#endif
+
+/*
+ * Macros to generate global absolutes.
+ */
+#if defined(__bfin__)
+# define GEN_SET_VALUE(name, value) asm (".set " GEN_SYMNAME(name) ", " GEN_VALUE(value))
+#else
+# define GEN_SET_VALUE(name, value) asm (GEN_SYMNAME(name) " = " GEN_VALUE(value))
+#endif
+#define GEN_SYMNAME(str) SYM_CHAR #str
+#define GEN_VALUE(str) #str
+#define GEN_ABS(name, value) \
+		asm (".globl " GEN_SYMNAME(name)); \
+		GEN_SET_VALUE(name, value)
+
+/*
+ * Macros to transform values
+ * into environment strings.
+ */
+#define XMK_STR(x)	#x
+#define MK_STR(x)	XMK_STR(x)
+
+/*
+ * Check to see if we are building with a
+ * computed CRC.  Otherwise define it as ~0.
+ */
+#if !defined(ENV_CRC)
+#  define ENV_CRC	~0
+#endif
+
+env_t environment __PPCENV__ = {
+	ENV_CRC,	/* CRC Sum */
+#ifdef CFG_REDUNDAND_ENVIRONMENT
+	1,		/* Flags: valid */
+#endif
+	{
+#if defined(CONFIG_BOOTARGS)
+	"bootargs="	CONFIG_BOOTARGS			"\0"
+#endif
+#if defined(CONFIG_BOOTCOMMAND)
+	"bootcmd="	CONFIG_BOOTCOMMAND		"\0"
+#endif
+#if defined(CONFIG_RAMBOOTCOMMAND)
+	"ramboot="	CONFIG_RAMBOOTCOMMAND		"\0"
+#endif
+#if defined(CONFIG_NFSBOOTCOMMAND)
+	"nfsboot="	CONFIG_NFSBOOTCOMMAND		"\0"
+#endif
+#if defined(CONFIG_BOOTDELAY) && (CONFIG_BOOTDELAY >= 0)
+	"bootdelay="	MK_STR(CONFIG_BOOTDELAY)	"\0"
+#endif
+#if defined(CONFIG_BAUDRATE) && (CONFIG_BAUDRATE >= 0)
+	"baudrate="	MK_STR(CONFIG_BAUDRATE)		"\0"
+#endif
+#ifdef	CONFIG_LOADS_ECHO
+	"loads_echo="	MK_STR(CONFIG_LOADS_ECHO)	"\0"
+#endif
+#ifdef	CONFIG_ETHADDR
+	"ethaddr="	MK_STR(CONFIG_ETHADDR)		"\0"
+#endif
+#ifdef	CONFIG_ETH1ADDR
+	"eth1addr="	MK_STR(CONFIG_ETH1ADDR)		"\0"
+#endif
+#ifdef	CONFIG_ETH2ADDR
+	"eth2addr="	MK_STR(CONFIG_ETH2ADDR)		"\0"
+#endif
+#ifdef	CONFIG_ETH3ADDR
+	"eth3addr="	MK_STR(CONFIG_ETH3ADDR)		"\0"
+#endif
+#ifdef	CONFIG_ETHPRIME
+	"ethprime="	CONFIG_ETHPRIME			"\0"
+#endif
+#ifdef	CONFIG_IPADDR
+	"ipaddr="	MK_STR(CONFIG_IPADDR)		"\0"
+#endif
+#ifdef	CONFIG_SERVERIP
+	"serverip="	MK_STR(CONFIG_SERVERIP)		"\0"
+#endif
+#ifdef	CFG_AUTOLOAD
+	"autoload="	CFG_AUTOLOAD			"\0"
+#endif
+#ifdef	CONFIG_ROOTPATH
+	"rootpath="	MK_STR(CONFIG_ROOTPATH)		"\0"
+#endif
+#ifdef	CONFIG_GATEWAYIP
+	"gatewayip="	MK_STR(CONFIG_GATEWAYIP)	"\0"
+#endif
+#ifdef	CONFIG_NETMASK
+	"netmask="	MK_STR(CONFIG_NETMASK)		"\0"
+#endif
+#ifdef	CONFIG_HOSTNAME
+	"hostname="	MK_STR(CONFIG_HOSTNAME)		"\0"
+#endif
+#ifdef	CONFIG_BOOTFILE
+	"bootfile="	MK_STR(CONFIG_BOOTFILE)		"\0"
+#endif
+#ifdef	CONFIG_LOADADDR
+	"loadaddr="	MK_STR(CONFIG_LOADADDR)		"\0"
+#endif
+#ifdef	CONFIG_PREBOOT
+	"preboot="	CONFIG_PREBOOT			"\0"
+#endif
+#ifdef	CONFIG_CLOCKS_IN_MHZ
+	"clocks_in_mhz=" "1"				"\0"
+#endif
+#if defined(CONFIG_PCI_BOOTDELAY) && (CONFIG_PCI_BOOTDELAY > 0)
+	"pcidelay="	MK_STR(CONFIG_PCI_BOOTDELAY)	"\0"
+#endif
+#ifdef  CONFIG_EXTRA_ENV_SETTINGS
+	CONFIG_EXTRA_ENV_SETTINGS
+#endif
+	"\0"		/* Term. env_t.data with 2 NULs */
+	}
+};
+#ifdef CFG_ENV_ADDR_REDUND
+env_t redundand_environment __PPCENV__ = {
+	0,		/* CRC Sum: invalid */
+	0,		/* Flags:   invalid */
+	{
+	"\0"
+	}
+};
+#endif	/* CFG_ENV_ADDR_REDUND */
+
+/*
+ * These will end up in the .text section
+ * if the environment strings are embedded
+ * in the image.  When this is used for
+ * tools/envcrc, they are placed in the
+ * .data/.sdata section.
+ *
+ */
+unsigned long env_size __PPCTEXT__ = sizeof(env_t);
+
+/*
+ * Add in absolutes.
+ */
+GEN_ABS(env_offset, CFG_ENV_OFFSET);
+
+#endif /* ENV_IS_EMBEDDED */
diff -N -r -up ./u-boot-1.3.4.orig/tools/fdt.c ./u-boot-1.3.4/tools/fdt.c
--- ./u-boot-1.3.4.orig/tools/fdt.c	1970-01-01 01:00:00.000000000 +0100
+++ ./u-boot-1.3.4/tools/fdt.c	2008-08-12 16:08:38.000000000 +0200
@@ -0,0 +1,205 @@
+/*
+ * libfdt - Flat Device Tree manipulation
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ *
+ * libfdt is dual licensed: you can use it either under the terms of
+ * the GPL, or the BSD license, at your option.
+ *
+ *  a) This library is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of the
+ *     License, or (at your option) any later version.
+ *
+ *     This library is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ *     You should have received a copy of the GNU General Public
+ *     License along with this library; if not, write to the Free
+ *     Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
+ *     MA 02110-1301 USA
+ *
+ * Alternatively,
+ *
+ *  b) Redistribution and use in source and binary forms, with or
+ *     without modification, are permitted provided that the following
+ *     conditions are met:
+ *
+ *     1. Redistributions of source code must retain the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer.
+ *     2. Redistributions in binary form must reproduce the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *
+ *     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+ *     CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ *     INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *     MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ *     CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *     SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *     NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ *     HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *     CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ *     OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ *     EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "libfdt_env.h"
+
+#ifndef USE_HOSTCC
+#include <fdt.h>
+#include <libfdt.h>
+#else
+#include "fdt_host.h"
+#endif
+
+#include "libfdt_internal.h"
+
+int fdt_check_header(const void *fdt)
+{
+	if (fdt_magic(fdt) == FDT_MAGIC) {
+		/* Complete tree */
+		if (fdt_version(fdt) < FDT_FIRST_SUPPORTED_VERSION)
+			return -FDT_ERR_BADVERSION;
+		if (fdt_last_comp_version(fdt) > FDT_LAST_SUPPORTED_VERSION)
+			return -FDT_ERR_BADVERSION;
+	} else if (fdt_magic(fdt) == SW_MAGIC) {
+		/* Unfinished sequential-write blob */
+		if (fdt_size_dt_struct(fdt) == 0)
+			return -FDT_ERR_BADSTATE;
+	} else {
+		return -FDT_ERR_BADMAGIC;
+	}
+
+	return 0;
+}
+
+const void *fdt_offset_ptr(const void *fdt, int offset, int len)
+{
+	const void *p;
+
+	if (fdt_version(fdt) >= 0x11)
+		if (((offset + len) < offset)
+		    || ((offset + len) > fdt_size_dt_struct(fdt)))
+			return NULL;
+
+	p = _fdt_offset_ptr(fdt, offset);
+
+	if (p + len < p)
+		return NULL;
+	return p;
+}
+
+uint32_t fdt_next_tag(const void *fdt, int offset, int *nextoffset)
+{
+	const uint32_t *tagp, *lenp;
+	uint32_t tag;
+	const char *p;
+
+	if (offset % FDT_TAGSIZE)
+		return -1;
+
+	tagp = fdt_offset_ptr(fdt, offset, FDT_TAGSIZE);
+	if (! tagp)
+		return FDT_END; /* premature end */
+	tag = fdt32_to_cpu(*tagp);
+	offset += FDT_TAGSIZE;
+
+	switch (tag) {
+	case FDT_BEGIN_NODE:
+		/* skip name */
+		do {
+			p = fdt_offset_ptr(fdt, offset++, 1);
+		} while (p && (*p != '\0'));
+		if (! p)
+			return FDT_END;
+		break;
+	case FDT_PROP:
+		lenp = fdt_offset_ptr(fdt, offset, sizeof(*lenp));
+		if (! lenp)
+			return FDT_END;
+		/* skip name offset, length and value */
+		offset += 2*FDT_TAGSIZE + fdt32_to_cpu(*lenp);
+		break;
+	}
+
+	if (nextoffset)
+		*nextoffset = ALIGN(offset, FDT_TAGSIZE);
+
+	return tag;
+}
+
+int _fdt_check_node_offset(const void *fdt, int offset)
+{
+	if ((offset < 0) || (offset % FDT_TAGSIZE)
+	    || (fdt_next_tag(fdt, offset, &offset) != FDT_BEGIN_NODE))
+		return -FDT_ERR_BADOFFSET;
+
+	return offset;
+}
+
+int fdt_next_node(const void *fdt, int offset, int *depth)
+{
+	int nextoffset = 0;
+	uint32_t tag;
+
+	if (offset >= 0)
+		if ((nextoffset = _fdt_check_node_offset(fdt, offset)) < 0)
+			return nextoffset;
+
+	do {
+		offset = nextoffset;
+		tag = fdt_next_tag(fdt, offset, &nextoffset);
+
+		switch (tag) {
+		case FDT_PROP:
+		case FDT_NOP:
+			break;
+
+		case FDT_BEGIN_NODE:
+			if (depth)
+				(*depth)++;
+			break;
+
+		case FDT_END_NODE:
+			if (depth)
+				(*depth)--;
+			break;
+
+		case FDT_END:
+			return -FDT_ERR_NOTFOUND;
+
+		default:
+			return -FDT_ERR_BADSTRUCTURE;
+		}
+	} while (tag != FDT_BEGIN_NODE);
+
+	return offset;
+}
+
+const char *_fdt_find_string(const char *strtab, int tabsize, const char *s)
+{
+	int len = strlen(s) + 1;
+	const char *last = strtab + tabsize - len;
+	const char *p;
+
+	for (p = strtab; p <= last; p++)
+		if (memeq(p, s, len))
+			return p;
+	return NULL;
+}
+
+int fdt_move(const void *fdt, void *buf, int bufsize)
+{
+	CHECK_HEADER(fdt);
+
+	if (fdt_totalsize(fdt) > bufsize)
+		return -FDT_ERR_NOSPACE;
+
+	memmove(buf, fdt, fdt_totalsize(fdt));
+	return 0;
+}
diff -N -r -up ./u-boot-1.3.4.orig/tools/fdt_ro.c ./u-boot-1.3.4/tools/fdt_ro.c
--- ./u-boot-1.3.4.orig/tools/fdt_ro.c	1970-01-01 01:00:00.000000000 +0100
+++ ./u-boot-1.3.4/tools/fdt_ro.c	2008-08-12 16:08:38.000000000 +0200
@@ -0,0 +1,470 @@
+/*
+ * libfdt - Flat Device Tree manipulation
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ *
+ * libfdt is dual licensed: you can use it either under the terms of
+ * the GPL, or the BSD license, at your option.
+ *
+ *  a) This library is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of the
+ *     License, or (at your option) any later version.
+ *
+ *     This library is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ *     You should have received a copy of the GNU General Public
+ *     License along with this library; if not, write to the Free
+ *     Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
+ *     MA 02110-1301 USA
+ *
+ * Alternatively,
+ *
+ *  b) Redistribution and use in source and binary forms, with or
+ *     without modification, are permitted provided that the following
+ *     conditions are met:
+ *
+ *     1. Redistributions of source code must retain the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer.
+ *     2. Redistributions in binary form must reproduce the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *
+ *     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+ *     CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ *     INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *     MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ *     CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *     SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *     NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ *     HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *     CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ *     OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ *     EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "libfdt_env.h"
+
+#ifndef USE_HOSTCC
+#include <fdt.h>
+#include <libfdt.h>
+#else
+#include "fdt_host.h"
+#endif
+
+#include "libfdt_internal.h"
+
+static int nodename_eq(const void *fdt, int offset,
+		       const char *s, int len)
+{
+	const char *p = fdt_offset_ptr(fdt, offset + FDT_TAGSIZE, len+1);
+
+	if (! p)
+		/* short match */
+		return 0;
+
+	if (memcmp(p, s, len) != 0)
+		return 0;
+
+	if (p[len] == '\0')
+		return 1;
+	else if (!memchr(s, '@', len) && (p[len] == '@'))
+		return 1;
+	else
+		return 0;
+}
+
+const char *fdt_string(const void *fdt, int stroffset)
+{
+	return (char *)fdt + fdt_off_dt_strings(fdt) + stroffset;
+}
+
+int fdt_get_mem_rsv(const void *fdt, int n, uint64_t *address, uint64_t *size)
+{
+	CHECK_HEADER(fdt);
+	*address = fdt64_to_cpu(_fdt_mem_rsv(fdt, n)->address);
+	*size = fdt64_to_cpu(_fdt_mem_rsv(fdt, n)->size);
+	return 0;
+}
+
+int fdt_num_mem_rsv(const void *fdt)
+{
+	int i = 0;
+
+	while (fdt64_to_cpu(_fdt_mem_rsv(fdt, i)->size) != 0)
+		i++;
+	return i;
+}
+
+int fdt_subnode_offset_namelen(const void *fdt, int offset,
+			       const char *name, int namelen)
+{
+	int depth;
+
+	CHECK_HEADER(fdt);
+
+	for (depth = 0;
+	     offset >= 0;
+	     offset = fdt_next_node(fdt, offset, &depth)) {
+		if (depth < 0)
+			return -FDT_ERR_NOTFOUND;
+		else if ((depth == 1)
+			 && nodename_eq(fdt, offset, name, namelen))
+			return offset;
+	}
+
+	return offset; /* error */
+}
+
+int fdt_subnode_offset(const void *fdt, int parentoffset,
+		       const char *name)
+{
+	return fdt_subnode_offset_namelen(fdt, parentoffset, name, strlen(name));
+}
+
+int fdt_path_offset(const void *fdt, const char *path)
+{
+	const char *end = path + strlen(path);
+	const char *p = path;
+	int offset = 0;
+
+	CHECK_HEADER(fdt);
+
+	if (*path != '/')
+		return -FDT_ERR_BADPATH;
+
+	while (*p) {
+		const char *q;
+
+		while (*p == '/')
+			p++;
+		if (! *p)
+			return offset;
+		q = strchr(p, '/');
+		if (! q)
+			q = end;
+
+		offset = fdt_subnode_offset_namelen(fdt, offset, p, q-p);
+		if (offset < 0)
+			return offset;
+
+		p = q;
+	}
+
+	return offset;
+}
+
+const char *fdt_get_name(const void *fdt, int nodeoffset, int *len)
+{
+	const struct fdt_node_header *nh = _fdt_offset_ptr(fdt, nodeoffset);
+	int err;
+
+	if (((err = fdt_check_header(fdt)) != 0)
+	    || ((err = _fdt_check_node_offset(fdt, nodeoffset)) < 0))
+			goto fail;
+
+	if (len)
+		*len = strlen(nh->name);
+
+	return nh->name;
+
+ fail:
+	if (len)
+		*len = err;
+	return NULL;
+}
+
+const struct fdt_property *fdt_get_property(const void *fdt,
+					    int nodeoffset,
+					    const char *name, int *lenp)
+{
+	uint32_t tag;
+	const struct fdt_property *prop;
+	int namestroff;
+	int offset, nextoffset;
+	int err;
+
+	if (((err = fdt_check_header(fdt)) != 0)
+	    || ((err = _fdt_check_node_offset(fdt, nodeoffset)) < 0))
+			goto fail;
+
+	nextoffset = err;
+	do {
+		offset = nextoffset;
+
+		tag = fdt_next_tag(fdt, offset, &nextoffset);
+		switch (tag) {
+		case FDT_END:
+			err = -FDT_ERR_TRUNCATED;
+			goto fail;
+
+		case FDT_BEGIN_NODE:
+		case FDT_END_NODE:
+		case FDT_NOP:
+			break;
+
+		case FDT_PROP:
+			err = -FDT_ERR_BADSTRUCTURE;
+			prop = fdt_offset_ptr(fdt, offset, sizeof(*prop));
+			if (! prop)
+				goto fail;
+			namestroff = fdt32_to_cpu(prop->nameoff);
+			if (streq(fdt_string(fdt, namestroff), name)) {
+				/* Found it! */
+				int len = fdt32_to_cpu(prop->len);
+				prop = fdt_offset_ptr(fdt, offset,
+						      sizeof(*prop)+len);
+				if (! prop)
+					goto fail;
+
+				if (lenp)
+					*lenp = len;
+
+				return prop;
+			}
+			break;
+
+		default:
+			err = -FDT_ERR_BADSTRUCTURE;
+			goto fail;
+		}
+	} while ((tag != FDT_BEGIN_NODE) && (tag != FDT_END_NODE));
+
+	err = -FDT_ERR_NOTFOUND;
+ fail:
+	if (lenp)
+		*lenp = err;
+	return NULL;
+}
+
+const void *fdt_getprop(const void *fdt, int nodeoffset,
+		  const char *name, int *lenp)
+{
+	const struct fdt_property *prop;
+
+	prop = fdt_get_property(fdt, nodeoffset, name, lenp);
+	if (! prop)
+		return NULL;
+
+	return prop->data;
+}
+
+uint32_t fdt_get_phandle(const void *fdt, int nodeoffset)
+{
+	const uint32_t *php;
+	int len;
+
+	php = fdt_getprop(fdt, nodeoffset, "linux,phandle", &len);
+	if (!php || (len != sizeof(*php)))
+		return 0;
+
+	return fdt32_to_cpu(*php);
+}
+
+int fdt_get_path(const void *fdt, int nodeoffset, char *buf, int buflen)
+{
+	int pdepth = 0, p = 0;
+	int offset, depth, namelen;
+	const char *name;
+
+	CHECK_HEADER(fdt);
+
+	if (buflen < 2)
+		return -FDT_ERR_NOSPACE;
+
+	for (offset = 0, depth = 0;
+	     (offset >= 0) && (offset <= nodeoffset);
+	     offset = fdt_next_node(fdt, offset, &depth)) {
+		if (pdepth < depth)
+			continue; /* overflowed buffer */
+
+		while (pdepth > depth) {
+			do {
+				p--;
+			} while (buf[p-1] != '/');
+			pdepth--;
+		}
+
+		name = fdt_get_name(fdt, offset, &namelen);
+		if (!name)
+			return namelen;
+		if ((p + namelen + 1) <= buflen) {
+			memcpy(buf + p, name, namelen);
+			p += namelen;
+			buf[p++] = '/';
+			pdepth++;
+		}
+
+		if (offset == nodeoffset) {
+			if (pdepth < (depth + 1))
+				return -FDT_ERR_NOSPACE;
+
+			if (p > 1) /* special case so that root path is "/", not "" */
+				p--;
+			buf[p] = '\0';
+			return p;
+		}
+	}
+
+	if ((offset == -FDT_ERR_NOTFOUND) || (offset >= 0))
+		return -FDT_ERR_BADOFFSET;
+	else if (offset == -FDT_ERR_BADOFFSET)
+		return -FDT_ERR_BADSTRUCTURE;
+
+	return offset; /* error from fdt_next_node() */
+}
+
+int fdt_supernode_atdepth_offset(const void *fdt, int nodeoffset,
+				 int supernodedepth, int *nodedepth)
+{
+	int offset, depth;
+	int supernodeoffset = -FDT_ERR_INTERNAL;
+
+	CHECK_HEADER(fdt);
+
+	if (supernodedepth < 0)
+		return -FDT_ERR_NOTFOUND;
+
+	for (offset = 0, depth = 0;
+	     (offset >= 0) && (offset <= nodeoffset);
+	     offset = fdt_next_node(fdt, offset, &depth)) {
+		if (depth == supernodedepth)
+			supernodeoffset = offset;
+
+		if (offset == nodeoffset) {
+			if (nodedepth)
+				*nodedepth = depth;
+
+			if (supernodedepth > depth)
+				return -FDT_ERR_NOTFOUND;
+			else
+				return supernodeoffset;
+		}
+	}
+
+	if ((offset == -FDT_ERR_NOTFOUND) || (offset >= 0))
+		return -FDT_ERR_BADOFFSET;
+	else if (offset == -FDT_ERR_BADOFFSET)
+		return -FDT_ERR_BADSTRUCTURE;
+
+	return offset; /* error from fdt_next_node() */
+}
+
+int fdt_node_depth(const void *fdt, int nodeoffset)
+{
+	int nodedepth;
+	int err;
+
+	err = fdt_supernode_atdepth_offset(fdt, nodeoffset, 0, &nodedepth);
+	if (err)
+		return (err < 0) ? err : -FDT_ERR_INTERNAL;
+	return nodedepth;
+}
+
+int fdt_parent_offset(const void *fdt, int nodeoffset)
+{
+	int nodedepth = fdt_node_depth(fdt, nodeoffset);
+
+	if (nodedepth < 0)
+		return nodedepth;
+	return fdt_supernode_atdepth_offset(fdt, nodeoffset,
+					    nodedepth - 1, NULL);
+}
+
+int fdt_node_offset_by_prop_value(const void *fdt, int startoffset,
+				  const char *propname,
+				  const void *propval, int proplen)
+{
+	int offset;
+	const void *val;
+	int len;
+
+	CHECK_HEADER(fdt);
+
+	/* FIXME: The algorithm here is pretty horrible: we scan each
+	 * property of a node in fdt_getprop(), then if that didn't
+	 * find what we want, we scan over them again making our way
+	 * to the next node.  Still it's the easiest to implement
+	 * approach; performance can come later. */
+	for (offset = fdt_next_node(fdt, startoffset, NULL);
+	     offset >= 0;
+	     offset = fdt_next_node(fdt, offset, NULL)) {
+		val = fdt_getprop(fdt, offset, propname, &len);
+		if (val && (len == proplen)
+		    && (memcmp(val, propval, len) == 0))
+			return offset;
+	}
+
+	return offset; /* error from fdt_next_node() */
+}
+
+int fdt_node_offset_by_phandle(const void *fdt, uint32_t phandle)
+{
+	if ((phandle == 0) || (phandle == -1))
+		return -FDT_ERR_BADPHANDLE;
+	phandle = cpu_to_fdt32(phandle);
+	return fdt_node_offset_by_prop_value(fdt, -1, "linux,phandle",
+					     &phandle, sizeof(phandle));
+}
+
+int _stringlist_contains(const void *strlist, int listlen, const char *str)
+{
+	int len = strlen(str);
+	const void *p;
+
+	while (listlen >= len) {
+		if (memcmp(str, strlist, len+1) == 0)
+			return 1;
+		p = memchr(strlist, '\0', listlen);
+		if (!p)
+			return 0; /* malformed strlist.. */
+		listlen -= (p-strlist) + 1;
+		strlist = p + 1;
+	}
+	return 0;
+}
+
+int fdt_node_check_compatible(const void *fdt, int nodeoffset,
+			      const char *compatible)
+{
+	const void *prop;
+	int len;
+
+	prop = fdt_getprop(fdt, nodeoffset, "compatible", &len);
+	if (!prop)
+		return len;
+	if (_stringlist_contains(prop, len, compatible))
+		return 0;
+	else
+		return 1;
+}
+
+int fdt_node_offset_by_compatible(const void *fdt, int startoffset,
+				  const char *compatible)
+{
+	int offset, err;
+
+	CHECK_HEADER(fdt);
+
+	/* FIXME: The algorithm here is pretty horrible: we scan each
+	 * property of a node in fdt_node_check_compatible(), then if
+	 * that didn't find what we want, we scan over them again
+	 * making our way to the next node.  Still it's the easiest to
+	 * implement approach; performance can come later. */
+	for (offset = fdt_next_node(fdt, startoffset, NULL);
+	     offset >= 0;
+	     offset = fdt_next_node(fdt, offset, NULL)) {
+		err = fdt_node_check_compatible(fdt, offset, compatible);
+		if ((err < 0) && (err != -FDT_ERR_NOTFOUND))
+			return err;
+		else if (err == 0)
+			return offset;
+	}
+
+	return offset; /* error from fdt_next_node() */
+}
diff -N -r -up ./u-boot-1.3.4.orig/tools/fdt_rw.c ./u-boot-1.3.4/tools/fdt_rw.c
--- ./u-boot-1.3.4.orig/tools/fdt_rw.c	1970-01-01 01:00:00.000000000 +0100
+++ ./u-boot-1.3.4/tools/fdt_rw.c	2008-08-12 16:08:38.000000000 +0200
@@ -0,0 +1,463 @@
+/*
+ * libfdt - Flat Device Tree manipulation
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ *
+ * libfdt is dual licensed: you can use it either under the terms of
+ * the GPL, or the BSD license, at your option.
+ *
+ *  a) This library is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of the
+ *     License, or (at your option) any later version.
+ *
+ *     This library is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ *     You should have received a copy of the GNU General Public
+ *     License along with this library; if not, write to the Free
+ *     Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
+ *     MA 02110-1301 USA
+ *
+ * Alternatively,
+ *
+ *  b) Redistribution and use in source and binary forms, with or
+ *     without modification, are permitted provided that the following
+ *     conditions are met:
+ *
+ *     1. Redistributions of source code must retain the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer.
+ *     2. Redistributions in binary form must reproduce the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *
+ *     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+ *     CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ *     INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *     MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ *     CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *     SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *     NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ *     HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *     CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ *     OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ *     EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "libfdt_env.h"
+
+#ifndef USE_HOSTCC
+#include <fdt.h>
+#include <libfdt.h>
+#else
+#include "fdt_host.h"
+#endif
+
+#include "libfdt_internal.h"
+
+static int _blocks_misordered(const void *fdt,
+			      int mem_rsv_size, int struct_size)
+{
+	return (fdt_off_mem_rsvmap(fdt) < ALIGN(sizeof(struct fdt_header), 8))
+		|| (fdt_off_dt_struct(fdt) <
+		    (fdt_off_mem_rsvmap(fdt) + mem_rsv_size))
+		|| (fdt_off_dt_strings(fdt) <
+		    (fdt_off_dt_struct(fdt) + struct_size))
+		|| (fdt_totalsize(fdt) <
+		    (fdt_off_dt_strings(fdt) + fdt_size_dt_strings(fdt)));
+}
+
+static int rw_check_header(void *fdt)
+{
+	CHECK_HEADER(fdt);
+
+	if (fdt_version(fdt) < 17)
+		return -FDT_ERR_BADVERSION;
+	if (_blocks_misordered(fdt, sizeof(struct fdt_reserve_entry),
+			       fdt_size_dt_struct(fdt)))
+		return -FDT_ERR_BADLAYOUT;
+	if (fdt_version(fdt) > 17)
+		fdt_set_version(fdt, 17);
+
+	return 0;
+}
+
+#define RW_CHECK_HEADER(fdt) \
+	{ \
+		int err; \
+		if ((err = rw_check_header(fdt)) != 0) \
+			return err; \
+	}
+
+static inline int _blob_data_size(void *fdt)
+{
+	return fdt_off_dt_strings(fdt) + fdt_size_dt_strings(fdt);
+}
+
+static int _blob_splice(void *fdt, void *p, int oldlen, int newlen)
+{
+	void *end = fdt + _blob_data_size(fdt);
+
+	if (((p + oldlen) < p) || ((p + oldlen) > end))
+		return -FDT_ERR_BADOFFSET;
+	if ((end - oldlen + newlen) > (fdt + fdt_totalsize(fdt)))
+		return -FDT_ERR_NOSPACE;
+	memmove(p + newlen, p + oldlen, end - p - oldlen);
+	return 0;
+}
+
+static int _blob_splice_mem_rsv(void *fdt, struct fdt_reserve_entry *p,
+				int oldn, int newn)
+{
+	int delta = (newn - oldn) * sizeof(*p);
+	int err;
+	err = _blob_splice(fdt, p, oldn * sizeof(*p), newn * sizeof(*p));
+	if (err)
+		return err;
+	fdt_set_off_dt_struct(fdt, fdt_off_dt_struct(fdt) + delta);
+	fdt_set_off_dt_strings(fdt, fdt_off_dt_strings(fdt) + delta);
+	return 0;
+}
+
+static int _blob_splice_struct(void *fdt, void *p,
+			       int oldlen, int newlen)
+{
+	int delta = newlen - oldlen;
+	int err;
+
+	if ((err = _blob_splice(fdt, p, oldlen, newlen)))
+		return err;
+
+	fdt_set_size_dt_struct(fdt, fdt_size_dt_struct(fdt) + delta);
+	fdt_set_off_dt_strings(fdt, fdt_off_dt_strings(fdt) + delta);
+	return 0;
+}
+
+static int _blob_splice_string(void *fdt, int newlen)
+{
+	void *p = fdt + fdt_off_dt_strings(fdt) + fdt_size_dt_strings(fdt);
+	int err;
+
+	if ((err = _blob_splice(fdt, p, 0, newlen)))
+		return err;
+
+	fdt_set_size_dt_strings(fdt, fdt_size_dt_strings(fdt) + newlen);
+	return 0;
+}
+
+static int _find_add_string(void *fdt, const char *s)
+{
+	char *strtab = (char *)fdt + fdt_off_dt_strings(fdt);
+	const char *p;
+	char *new;
+	int len = strlen(s) + 1;
+	int err;
+
+	p = _fdt_find_string(strtab, fdt_size_dt_strings(fdt), s);
+	if (p)
+		/* found it */
+		return (p - strtab);
+
+	new = strtab + fdt_size_dt_strings(fdt);
+	err = _blob_splice_string(fdt, len);
+	if (err)
+		return err;
+
+	memcpy(new, s, len);
+	return (new - strtab);
+}
+
+int fdt_add_mem_rsv(void *fdt, uint64_t address, uint64_t size)
+{
+	struct fdt_reserve_entry *re;
+	int err;
+
+	RW_CHECK_HEADER(fdt);
+
+	re = _fdt_mem_rsv_w(fdt, fdt_num_mem_rsv(fdt));
+	err = _blob_splice_mem_rsv(fdt, re, 0, 1);
+	if (err)
+		return err;
+
+	re->address = cpu_to_fdt64(address);
+	re->size = cpu_to_fdt64(size);
+	return 0;
+}
+
+int fdt_del_mem_rsv(void *fdt, int n)
+{
+	struct fdt_reserve_entry *re = _fdt_mem_rsv_w(fdt, n);
+	int err;
+
+	RW_CHECK_HEADER(fdt);
+
+	if (n >= fdt_num_mem_rsv(fdt))
+		return -FDT_ERR_NOTFOUND;
+
+	err = _blob_splice_mem_rsv(fdt, re, 1, 0);
+	if (err)
+		return err;
+	return 0;
+}
+
+static int _resize_property(void *fdt, int nodeoffset, const char *name, int len,
+			    struct fdt_property **prop)
+{
+	int oldlen;
+	int err;
+
+	*prop = fdt_get_property_w(fdt, nodeoffset, name, &oldlen);
+	if (! (*prop))
+		return oldlen;
+
+	if ((err = _blob_splice_struct(fdt, (*prop)->data,
+				       ALIGN(oldlen, FDT_TAGSIZE),
+				       ALIGN(len, FDT_TAGSIZE))))
+		return err;
+
+	(*prop)->len = cpu_to_fdt32(len);
+	return 0;
+}
+
+static int _add_property(void *fdt, int nodeoffset, const char *name, int len,
+			 struct fdt_property **prop)
+{
+	int proplen;
+	int nextoffset;
+	int namestroff;
+	int err;
+
+	if ((nextoffset = _fdt_check_node_offset(fdt, nodeoffset)) < 0)
+		return nextoffset;
+
+	namestroff = _find_add_string(fdt, name);
+	if (namestroff < 0)
+		return namestroff;
+
+	*prop = _fdt_offset_ptr_w(fdt, nextoffset);
+	proplen = sizeof(**prop) + ALIGN(len, FDT_TAGSIZE);
+
+	err = _blob_splice_struct(fdt, *prop, 0, proplen);
+	if (err)
+		return err;
+
+	(*prop)->tag = cpu_to_fdt32(FDT_PROP);
+	(*prop)->nameoff = cpu_to_fdt32(namestroff);
+	(*prop)->len = cpu_to_fdt32(len);
+	return 0;
+}
+
+int fdt_set_name(void *fdt, int nodeoffset, const char *name)
+{
+	char *namep;
+	int oldlen, newlen;
+	int err;
+
+	RW_CHECK_HEADER(fdt);
+
+	namep = (char *)fdt_get_name(fdt, nodeoffset, &oldlen);
+	if (!namep)
+		return oldlen;
+
+	newlen = strlen(name);
+
+	err = _blob_splice_struct(fdt, namep, ALIGN(oldlen+1, FDT_TAGSIZE),
+				  ALIGN(newlen+1, FDT_TAGSIZE));
+	if (err)
+		return err;
+
+	memcpy(namep, name, newlen+1);
+	return 0;
+}
+
+int fdt_setprop(void *fdt, int nodeoffset, const char *name,
+		const void *val, int len)
+{
+	struct fdt_property *prop;
+	int err;
+
+	RW_CHECK_HEADER(fdt);
+
+	err = _resize_property(fdt, nodeoffset, name, len, &prop);
+	if (err == -FDT_ERR_NOTFOUND)
+		err = _add_property(fdt, nodeoffset, name, len, &prop);
+	if (err)
+		return err;
+
+	memcpy(prop->data, val, len);
+	return 0;
+}
+
+int fdt_delprop(void *fdt, int nodeoffset, const char *name)
+{
+	struct fdt_property *prop;
+	int len, proplen;
+
+	RW_CHECK_HEADER(fdt);
+
+	prop = fdt_get_property_w(fdt, nodeoffset, name, &len);
+	if (! prop)
+		return len;
+
+	proplen = sizeof(*prop) + ALIGN(len, FDT_TAGSIZE);
+	return _blob_splice_struct(fdt, prop, proplen, 0);
+}
+
+int fdt_add_subnode_namelen(void *fdt, int parentoffset,
+			    const char *name, int namelen)
+{
+	struct fdt_node_header *nh;
+	int offset, nextoffset;
+	int nodelen;
+	int err;
+	uint32_t tag;
+	uint32_t *endtag;
+
+	RW_CHECK_HEADER(fdt);
+
+	offset = fdt_subnode_offset_namelen(fdt, parentoffset, name, namelen);
+	if (offset >= 0)
+		return -FDT_ERR_EXISTS;
+	else if (offset != -FDT_ERR_NOTFOUND)
+		return offset;
+
+	/* Try to place the new node after the parent's properties */
+	fdt_next_tag(fdt, parentoffset, &nextoffset); /* skip the BEGIN_NODE */
+	do {
+		offset = nextoffset;
+		tag = fdt_next_tag(fdt, offset, &nextoffset);
+	} while ((tag == FDT_PROP) || (tag == FDT_NOP));
+
+	nh = _fdt_offset_ptr_w(fdt, offset);
+	nodelen = sizeof(*nh) + ALIGN(namelen+1, FDT_TAGSIZE) + FDT_TAGSIZE;
+
+	err = _blob_splice_struct(fdt, nh, 0, nodelen);
+	if (err)
+		return err;
+
+	nh->tag = cpu_to_fdt32(FDT_BEGIN_NODE);
+	memset(nh->name, 0, ALIGN(namelen+1, FDT_TAGSIZE));
+	memcpy(nh->name, name, namelen);
+	endtag = (uint32_t *)((void *)nh + nodelen - FDT_TAGSIZE);
+	*endtag = cpu_to_fdt32(FDT_END_NODE);
+
+	return offset;
+}
+
+int fdt_add_subnode(void *fdt, int parentoffset, const char *name)
+{
+	return fdt_add_subnode_namelen(fdt, parentoffset, name, strlen(name));
+}
+
+int fdt_del_node(void *fdt, int nodeoffset)
+{
+	int endoffset;
+
+	RW_CHECK_HEADER(fdt);
+
+	endoffset = _fdt_node_end_offset(fdt, nodeoffset);
+	if (endoffset < 0)
+		return endoffset;
+
+	return _blob_splice_struct(fdt, _fdt_offset_ptr_w(fdt, nodeoffset),
+				   endoffset - nodeoffset, 0);
+}
+
+static void _packblocks(const void *fdt, void *buf,
+		       int mem_rsv_size, int struct_size)
+{
+	int mem_rsv_off, struct_off, strings_off;
+
+	mem_rsv_off = ALIGN(sizeof(struct fdt_header), 8);
+	struct_off = mem_rsv_off + mem_rsv_size;
+	strings_off = struct_off + struct_size;
+
+	memmove(buf + mem_rsv_off, fdt + fdt_off_mem_rsvmap(fdt), mem_rsv_size);
+	fdt_set_off_mem_rsvmap(buf, mem_rsv_off);
+
+	memmove(buf + struct_off, fdt + fdt_off_dt_struct(fdt), struct_size);
+	fdt_set_off_dt_struct(buf, struct_off);
+	fdt_set_size_dt_struct(buf, struct_size);
+
+	memmove(buf + strings_off, fdt + fdt_off_dt_strings(fdt),
+		fdt_size_dt_strings(fdt));
+	fdt_set_off_dt_strings(buf, strings_off);
+	fdt_set_size_dt_strings(buf, fdt_size_dt_strings(fdt));
+}
+
+int fdt_open_into(const void *fdt, void *buf, int bufsize)
+{
+	int err;
+	int mem_rsv_size, struct_size;
+	int newsize;
+	void *tmp;
+
+	CHECK_HEADER(fdt);
+
+	mem_rsv_size = (fdt_num_mem_rsv(fdt)+1)
+		* sizeof(struct fdt_reserve_entry);
+
+	if (fdt_version(fdt) >= 17) {
+		struct_size = fdt_size_dt_struct(fdt);
+	} else {
+		struct_size = 0;
+		while (fdt_next_tag(fdt, struct_size, &struct_size) != FDT_END)
+			;
+	}
+
+	if (!_blocks_misordered(fdt, mem_rsv_size, struct_size)) {
+		/* no further work necessary */
+		err = fdt_move(fdt, buf, bufsize);
+		if (err)
+			return err;
+		fdt_set_version(buf, 17);
+		fdt_set_size_dt_struct(buf, struct_size);
+		fdt_set_totalsize(buf, bufsize);
+		return 0;
+	}
+
+	/* Need to reorder */
+	newsize = ALIGN(sizeof(struct fdt_header), 8) + mem_rsv_size
+		+ struct_size + fdt_size_dt_strings(fdt);
+
+	if (bufsize < newsize)
+		return -FDT_ERR_NOSPACE;
+
+	if (((buf + newsize) <= fdt)
+	    || (buf >= (fdt + fdt_totalsize(fdt)))) {
+		tmp = buf;
+	} else {
+		tmp = (void *)fdt + fdt_totalsize(fdt);
+		if ((tmp + newsize) > (buf + bufsize))
+			return -FDT_ERR_NOSPACE;
+	}
+
+	_packblocks(fdt, tmp, mem_rsv_size, struct_size);
+	memmove(buf, tmp, newsize);
+
+	fdt_set_magic(buf, FDT_MAGIC);
+	fdt_set_totalsize(buf, bufsize);
+	fdt_set_version(buf, 17);
+	fdt_set_last_comp_version(buf, 16);
+	fdt_set_boot_cpuid_phys(buf, fdt_boot_cpuid_phys(fdt));
+
+	return 0;
+}
+
+int fdt_pack(void *fdt)
+{
+	int mem_rsv_size;
+
+	RW_CHECK_HEADER(fdt);
+
+	mem_rsv_size = (fdt_num_mem_rsv(fdt)+1)
+		* sizeof(struct fdt_reserve_entry);
+	_packblocks(fdt, fdt, mem_rsv_size, fdt_size_dt_struct(fdt));
+	fdt_set_totalsize(fdt, _blob_data_size(fdt));
+
+	return 0;
+}
diff -N -r -up ./u-boot-1.3.4.orig/tools/fdt_strerror.c ./u-boot-1.3.4/tools/fdt_strerror.c
--- ./u-boot-1.3.4.orig/tools/fdt_strerror.c	1970-01-01 01:00:00.000000000 +0100
+++ ./u-boot-1.3.4/tools/fdt_strerror.c	2008-08-12 16:08:38.000000000 +0200
@@ -0,0 +1,100 @@
+/*
+ * libfdt - Flat Device Tree manipulation
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ *
+ * libfdt is dual licensed: you can use it either under the terms of
+ * the GPL, or the BSD license, at your option.
+ *
+ *  a) This library is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of the
+ *     License, or (at your option) any later version.
+ *
+ *     This library is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ *     You should have received a copy of the GNU General Public
+ *     License along with this library; if not, write to the Free
+ *     Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
+ *     MA 02110-1301 USA
+ *
+ * Alternatively,
+ *
+ *  b) Redistribution and use in source and binary forms, with or
+ *     without modification, are permitted provided that the following
+ *     conditions are met:
+ *
+ *     1. Redistributions of source code must retain the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer.
+ *     2. Redistributions in binary form must reproduce the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *
+ *     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+ *     CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ *     INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *     MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ *     CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *     SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *     NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ *     HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *     CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ *     OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ *     EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "libfdt_env.h"
+
+#ifndef USE_HOSTCC
+#include <fdt.h>
+#include <libfdt.h>
+#else
+#include "fdt_host.h"
+#endif
+
+#include "libfdt_internal.h"
+
+struct errtabent {
+	const char *str;
+};
+
+#define ERRTABENT(val) \
+	[(val)] = { .str = #val, }
+
+static struct errtabent errtable[] = {
+	ERRTABENT(FDT_ERR_NOTFOUND),
+	ERRTABENT(FDT_ERR_EXISTS),
+	ERRTABENT(FDT_ERR_NOSPACE),
+
+	ERRTABENT(FDT_ERR_BADOFFSET),
+	ERRTABENT(FDT_ERR_BADPATH),
+	ERRTABENT(FDT_ERR_BADSTATE),
+
+	ERRTABENT(FDT_ERR_TRUNCATED),
+	ERRTABENT(FDT_ERR_BADMAGIC),
+	ERRTABENT(FDT_ERR_BADVERSION),
+	ERRTABENT(FDT_ERR_BADSTRUCTURE),
+	ERRTABENT(FDT_ERR_BADLAYOUT),
+};
+#define ERRTABSIZE	(sizeof(errtable) / sizeof(errtable[0]))
+
+const char *fdt_strerror(int errval)
+{
+	if (errval > 0)
+		return "<valid offset/length>";
+	else if (errval == 0)
+		return "<no error>";
+	else if (errval > -ERRTABSIZE) {
+		const char *s = errtable[-errval].str;
+
+		if (s)
+			return s;
+	}
+
+	return "<unknown error>";
+}
diff -N -r -up ./u-boot-1.3.4.orig/tools/fdt_wip.c ./u-boot-1.3.4/tools/fdt_wip.c
--- ./u-boot-1.3.4.orig/tools/fdt_wip.c	1970-01-01 01:00:00.000000000 +0100
+++ ./u-boot-1.3.4/tools/fdt_wip.c	2008-08-12 16:08:38.000000000 +0200
@@ -0,0 +1,148 @@
+/*
+ * libfdt - Flat Device Tree manipulation
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ *
+ * libfdt is dual licensed: you can use it either under the terms of
+ * the GPL, or the BSD license, at your option.
+ *
+ *  a) This library is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of the
+ *     License, or (at your option) any later version.
+ *
+ *     This library is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ *     You should have received a copy of the GNU General Public
+ *     License along with this library; if not, write to the Free
+ *     Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
+ *     MA 02110-1301 USA
+ *
+ * Alternatively,
+ *
+ *  b) Redistribution and use in source and binary forms, with or
+ *     without modification, are permitted provided that the following
+ *     conditions are met:
+ *
+ *     1. Redistributions of source code must retain the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer.
+ *     2. Redistributions in binary form must reproduce the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *
+ *     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+ *     CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ *     INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *     MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ *     CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *     SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *     NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ *     HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *     CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ *     OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ *     EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "libfdt_env.h"
+
+#ifndef USE_HOSTCC
+#include <fdt.h>
+#include <libfdt.h>
+#else
+#include "fdt_host.h"
+#endif
+
+#include "libfdt_internal.h"
+
+int fdt_setprop_inplace(void *fdt, int nodeoffset, const char *name,
+			const void *val, int len)
+{
+	void *propval;
+	int proplen;
+
+	propval = fdt_getprop_w(fdt, nodeoffset, name, &proplen);
+	if (! propval)
+		return proplen;
+
+	if (proplen != len)
+		return -FDT_ERR_NOSPACE;
+
+	memcpy(propval, val, len);
+	return 0;
+}
+
+static void nop_region(void *start, int len)
+{
+	uint32_t *p;
+
+	for (p = start; (void *)p < (start + len); p++)
+		*p = cpu_to_fdt32(FDT_NOP);
+}
+
+int fdt_nop_property(void *fdt, int nodeoffset, const char *name)
+{
+	struct fdt_property *prop;
+	int len;
+
+	prop = fdt_get_property_w(fdt, nodeoffset, name, &len);
+	if (! prop)
+		return len;
+
+	nop_region(prop, len + sizeof(*prop));
+
+	return 0;
+}
+
+int _fdt_node_end_offset(void *fdt, int nodeoffset)
+{
+	int level = 0;
+	uint32_t tag;
+	int offset, nextoffset;
+
+	tag = fdt_next_tag(fdt, nodeoffset, &nextoffset);
+	if (tag != FDT_BEGIN_NODE)
+		return -FDT_ERR_BADOFFSET;
+	do {
+		offset = nextoffset;
+		tag = fdt_next_tag(fdt, offset, &nextoffset);
+
+		switch (tag) {
+		case FDT_END:
+			return offset;
+
+		case FDT_BEGIN_NODE:
+			level++;
+			break;
+
+		case FDT_END_NODE:
+			level--;
+			break;
+
+		case FDT_PROP:
+		case FDT_NOP:
+			break;
+
+		default:
+			return -FDT_ERR_BADSTRUCTURE;
+		}
+	} while (level >= 0);
+
+	return nextoffset;
+}
+
+int fdt_nop_node(void *fdt, int nodeoffset)
+{
+	int endoffset;
+
+	endoffset = _fdt_node_end_offset(fdt, nodeoffset);
+	if (endoffset < 0)
+		return endoffset;
+
+	nop_region(fdt_offset_ptr_w(fdt, nodeoffset, 0), endoffset - nodeoffset);
+	return 0;
+}
diff -N -r -up ./u-boot-1.3.4.orig/tools/image.c ./u-boot-1.3.4/tools/image.c
--- ./u-boot-1.3.4.orig/tools/image.c	1970-01-01 01:00:00.000000000 +0100
+++ ./u-boot-1.3.4/tools/image.c	2008-08-12 16:08:38.000000000 +0200
@@ -0,0 +1,2511 @@
+/*
+ * (C) Copyright 2008 Semihalf
+ *
+ * (C) Copyright 2000-2006
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#ifndef USE_HOSTCC
+#include <common.h>
+#include <watchdog.h>
+
+#ifdef CONFIG_SHOW_BOOT_PROGRESS
+#include <status_led.h>
+#endif
+
+#ifdef CONFIG_HAS_DATAFLASH
+#include <dataflash.h>
+#endif
+
+#ifdef CONFIG_LOGBUFFER
+#include <logbuff.h>
+#endif
+
+#if defined(CONFIG_TIMESTAMP) || defined(CONFIG_CMD_DATE)
+#include <rtc.h>
+#endif
+
+#include <image.h>
+
+#if defined(CONFIG_FIT) || defined (CONFIG_OF_LIBFDT)
+#include <fdt.h>
+#include <libfdt.h>
+#include <fdt_support.h>
+#endif
+
+#if defined(CONFIG_FIT)
+#include <u-boot/md5.h>
+#include <sha1.h>
+
+static int fit_check_ramdisk (const void *fit, int os_noffset,
+		uint8_t arch, int verify);
+#endif
+
+#ifdef CONFIG_CMD_BDI
+extern int do_bdinfo(cmd_tbl_t *cmdtp, int flag, int argc, char *argv[]);
+#endif
+
+DECLARE_GLOBAL_DATA_PTR;
+
+static image_header_t* image_get_ramdisk (ulong rd_addr, uint8_t arch,
+						int verify);
+#else
+#include "mkimage.h"
+#include <u-boot/md5.h>
+#include <time.h>
+#include <image.h>
+#endif /* !USE_HOSTCC*/
+
+typedef struct table_entry {
+	int	id;		/* as defined in image.h	*/
+	char	*sname;		/* short (input) name		*/
+	char	*lname;		/* long (output) name		*/
+} table_entry_t;
+
+static table_entry_t uimage_arch[] = {
+	{	IH_ARCH_INVALID,	NULL,		"Invalid ARCH",	},
+	{	IH_ARCH_ALPHA,		"alpha",	"Alpha",	},
+	{	IH_ARCH_ARM,		"arm",		"ARM",		},
+	{	IH_ARCH_I386,		"x86",		"Intel x86",	},
+	{	IH_ARCH_IA64,		"ia64",		"IA64",		},
+	{	IH_ARCH_M68K,		"m68k",		"M68K",		},
+	{	IH_ARCH_MICROBLAZE,	"microblaze",	"MicroBlaze",	},
+	{	IH_ARCH_MIPS,		"mips",		"MIPS",		},
+	{	IH_ARCH_MIPS64,		"mips64",	"MIPS 64 Bit",	},
+	{	IH_ARCH_NIOS,		"nios",		"NIOS",		},
+	{	IH_ARCH_NIOS2,		"nios2",	"NIOS II",	},
+	{	IH_ARCH_PPC,		"powerpc",	"PowerPC",	},
+	{	IH_ARCH_PPC,		"ppc",		"PowerPC",	},
+	{	IH_ARCH_S390,		"s390",		"IBM S390",	},
+	{	IH_ARCH_SH,		"sh",		"SuperH",	},
+	{	IH_ARCH_SPARC,		"sparc",	"SPARC",	},
+	{	IH_ARCH_SPARC64,	"sparc64",	"SPARC 64 Bit",	},
+	{	IH_ARCH_BLACKFIN,	"blackfin",	"Blackfin",	},
+	{	IH_ARCH_AVR32,		"avr32",	"AVR32",	},
+	{	-1,			"",		"",		},
+};
+
+static table_entry_t uimage_os[] = {
+	{	IH_OS_INVALID,	NULL,		"Invalid OS",		},
+#if defined(CONFIG_ARTOS) || defined(USE_HOSTCC)
+	{	IH_OS_ARTOS,	"artos",	"ARTOS",		},
+#endif
+	{	IH_OS_LINUX,	"linux",	"Linux",		},
+#if defined(CONFIG_LYNXKDI) || defined(USE_HOSTCC)
+	{	IH_OS_LYNXOS,	"lynxos",	"LynxOS",		},
+#endif
+	{	IH_OS_NETBSD,	"netbsd",	"NetBSD",		},
+	{	IH_OS_RTEMS,	"rtems",	"RTEMS",		},
+	{	IH_OS_U_BOOT,	"u-boot",	"U-Boot",		},
+#if defined(CONFIG_CMD_ELF) || defined(USE_HOSTCC)
+	{	IH_OS_QNX,	"qnx",		"QNX",			},
+	{	IH_OS_VXWORKS,	"vxworks",	"VxWorks",		},
+#endif
+#ifdef USE_HOSTCC
+	{	IH_OS_4_4BSD,	"4_4bsd",	"4_4BSD",		},
+	{	IH_OS_DELL,	"dell",		"Dell",			},
+	{	IH_OS_ESIX,	"esix",		"Esix",			},
+	{	IH_OS_FREEBSD,	"freebsd",	"FreeBSD",		},
+	{	IH_OS_IRIX,	"irix",		"Irix",			},
+	{	IH_OS_NCR,	"ncr",		"NCR",			},
+	{	IH_OS_OPENBSD,	"openbsd",	"OpenBSD",		},
+	{	IH_OS_PSOS,	"psos",		"pSOS",			},
+	{	IH_OS_SCO,	"sco",		"SCO",			},
+	{	IH_OS_SOLARIS,	"solaris",	"Solaris",		},
+	{	IH_OS_SVR4,	"svr4",		"SVR4",			},
+#endif
+	{	-1,		"",		"",			},
+};
+
+static table_entry_t uimage_type[] = {
+	{	IH_TYPE_INVALID,    NULL,	  "Invalid Image",	},
+	{	IH_TYPE_FILESYSTEM, "filesystem", "Filesystem Image",	},
+	{	IH_TYPE_FIRMWARE,   "firmware",	  "Firmware",		},
+	{	IH_TYPE_KERNEL,	    "kernel",	  "Kernel Image",	},
+	{	IH_TYPE_MULTI,	    "multi",	  "Multi-File Image",	},
+	{	IH_TYPE_RAMDISK,    "ramdisk",	  "RAMDisk Image",	},
+	{	IH_TYPE_SCRIPT,     "script",	  "Script",		},
+	{	IH_TYPE_STANDALONE, "standalone", "Standalone Program", },
+	{	IH_TYPE_FLATDT,     "flat_dt",    "Flat Device Tree",	},
+	{	-1,		    "",		  "",			},
+};
+
+static table_entry_t uimage_comp[] = {
+	{	IH_COMP_NONE,	"none",		"uncompressed",		},
+	{	IH_COMP_BZIP2,	"bzip2",	"bzip2 compressed",	},
+	{	IH_COMP_GZIP,	"gzip",		"gzip compressed",	},
+	{	-1,		"",		"",			},
+};
+
+uint32_t crc32 (uint32_t, const unsigned char *, uint);
+uint32_t crc32_wd (uint32_t, const unsigned char *, uint, uint);
+static void genimg_print_size (uint32_t size);
+#if defined(CONFIG_TIMESTAMP) || defined(CONFIG_CMD_DATE) || defined(USE_HOSTCC)
+static void genimg_print_time (time_t timestamp);
+#endif
+
+/*****************************************************************************/
+/* Legacy format routines */
+/*****************************************************************************/
+int image_check_hcrc (image_header_t *hdr)
+{
+	ulong hcrc;
+	ulong len = image_get_header_size ();
+	image_header_t header;
+
+	/* Copy header so we can blank CRC field for re-calculation */
+	memmove (&header, (char *)hdr, image_get_header_size ());
+	image_set_hcrc (&header, 0);
+
+	hcrc = crc32 (0, (unsigned char *)&header, len);
+
+	return (hcrc == image_get_hcrc (hdr));
+}
+
+int image_check_dcrc (image_header_t *hdr)
+{
+	ulong data = image_get_data (hdr);
+	ulong len = image_get_data_size (hdr);
+	ulong dcrc = crc32_wd (0, (unsigned char *)data, len, CHUNKSZ_CRC32);
+
+	return (dcrc == image_get_dcrc (hdr));
+}
+
+/**
+ * image_multi_count - get component (sub-image) count
+ * @hdr: pointer to the header of the multi component image
+ *
+ * image_multi_count() returns number of components in a multi
+ * component image.
+ *
+ * Note: no checking of the image type is done, caller must pass
+ * a valid multi component image.
+ *
+ * returns:
+ *     number of components
+ */
+ulong image_multi_count (image_header_t *hdr)
+{
+	ulong i, count = 0;
+	uint32_t *size;
+
+	/* get start of the image payload, which in case of multi
+	 * component images that points to a table of component sizes */
+	size = (uint32_t *)image_get_data (hdr);
+
+	/* count non empty slots */
+	for (i = 0; size[i]; ++i)
+		count++;
+
+	return count;
+}
+
+/**
+ * image_multi_getimg - get component data address and size
+ * @hdr: pointer to the header of the multi component image
+ * @idx: index of the requested component
+ * @data: pointer to a ulong variable, will hold component data address
+ * @len: pointer to a ulong variable, will hold component size
+ *
+ * image_multi_getimg() returns size and data address for the requested
+ * component in a multi component image.
+ *
+ * Note: no checking of the image type is done, caller must pass
+ * a valid multi component image.
+ *
+ * returns:
+ *     data address and size of the component, if idx is valid
+ *     0 in data and len, if idx is out of range
+ */
+void image_multi_getimg (image_header_t *hdr, ulong idx,
+			ulong *data, ulong *len)
+{
+	int i;
+	uint32_t *size;
+	ulong offset, count, img_data;
+
+	/* get number of component */
+	count = image_multi_count (hdr);
+
+	/* get start of the image payload, which in case of multi
+	 * component images that points to a table of component sizes */
+	size = (uint32_t *)image_get_data (hdr);
+
+	/* get address of the proper component data start, which means
+	 * skipping sizes table (add 1 for last, null entry) */
+	img_data = image_get_data (hdr) + (count + 1) * sizeof (uint32_t);
+
+	if (idx < count) {
+		*len = uimage_to_cpu (size[idx]);
+		offset = 0;
+
+		/* go over all indices preceding requested component idx */
+		for (i = 0; i < idx; i++) {
+			/* add up i-th component size, rounding up to 4 bytes */
+			offset += (uimage_to_cpu (size[i]) + 3) & ~3 ;
+		}
+
+		/* calculate idx-th component data address */
+		*data = img_data + offset;
+	} else {
+		*len = 0;
+		*data = 0;
+	}
+}
+
+static void image_print_type (image_header_t *hdr)
+{
+	const char *os, *arch, *type, *comp;
+
+	os = genimg_get_os_name (image_get_os (hdr));
+	arch = genimg_get_arch_name (image_get_arch (hdr));
+	type = genimg_get_type_name (image_get_type (hdr));
+	comp = genimg_get_comp_name (image_get_comp (hdr));
+
+	printf ("%s %s %s (%s)\n", arch, os, type, comp);
+}
+
+/**
+ * image_print_contents - prints out the contents of the legacy format image
+ * @hdr: pointer to the legacy format image header
+ * @p: pointer to prefix string
+ *
+ * image_print_contents() formats a multi line legacy image contents description.
+ * The routine prints out all header fields followed by the size/offset data
+ * for MULTI/SCRIPT images.
+ *
+ * returns:
+ *     no returned results
+ */
+void image_print_contents (image_header_t *hdr)
+{
+	const char *p;
+
+#ifdef USE_HOSTCC
+	p = "";
+#else
+	p = "   ";
+#endif
+
+	printf ("%sImage Name:   %.*s\n", p, IH_NMLEN, image_get_name (hdr));
+#if defined(CONFIG_TIMESTAMP) || defined(CONFIG_CMD_DATE) || defined(USE_HOSTCC)
+	printf ("%sCreated:      ", p);
+	genimg_print_time ((time_t)image_get_time (hdr));
+#endif
+	printf ("%sImage Type:   ", p);
+	image_print_type (hdr);
+	printf ("%sData Size:    ", p);
+	genimg_print_size (image_get_data_size (hdr));
+	printf ("%sLoad Address: %08x\n", p, image_get_load (hdr));
+	printf ("%sEntry Point:  %08x\n", p, image_get_ep (hdr));
+
+	if (image_check_type (hdr, IH_TYPE_MULTI) ||
+			image_check_type (hdr, IH_TYPE_SCRIPT)) {
+		int i;
+		ulong data, len;
+		ulong count = image_multi_count (hdr);
+
+		printf ("%sContents:\n", p);
+		for (i = 0; i < count; i++) {
+			image_multi_getimg (hdr, i, &data, &len);
+
+			printf ("%s   Image %d: ", p, i);
+			genimg_print_size (len);
+
+			if (image_check_type (hdr, IH_TYPE_SCRIPT) && i > 0) {
+				/*
+				 * the user may need to know offsets
+				 * if planning to do something with
+				 * multiple files
+				 */
+				printf ("%s    Offset = 0x%08lx\n", p, data);
+			}
+		}
+	}
+}
+
+
+#ifndef USE_HOSTCC
+/**
+ * image_get_ramdisk - get and verify ramdisk image
+ * @rd_addr: ramdisk image start address
+ * @arch: expected ramdisk architecture
+ * @verify: checksum verification flag
+ *
+ * image_get_ramdisk() returns a pointer to the verified ramdisk image
+ * header. Routine receives image start address and expected architecture
+ * flag. Verification done covers data and header integrity and os/type/arch
+ * fields checking.
+ *
+ * If dataflash support is enabled routine checks for dataflash addresses
+ * and handles required dataflash reads.
+ *
+ * returns:
+ *     pointer to a ramdisk image header, if image was found and valid
+ *     otherwise, return NULL
+ */
+static image_header_t* image_get_ramdisk (ulong rd_addr, uint8_t arch,
+						int verify)
+{
+	image_header_t *rd_hdr = (image_header_t *)rd_addr;
+
+	if (!image_check_magic (rd_hdr)) {
+		puts ("Bad Magic Number\n");
+		show_boot_progress (-10);
+		return NULL;
+	}
+
+	if (!image_check_hcrc (rd_hdr)) {
+		puts ("Bad Header Checksum\n");
+		show_boot_progress (-11);
+		return NULL;
+	}
+
+	show_boot_progress (10);
+	image_print_contents (rd_hdr);
+
+	if (verify) {
+		puts("   Verifying Checksum ... ");
+		if (!image_check_dcrc (rd_hdr)) {
+			puts ("Bad Data CRC\n");
+			show_boot_progress (-12);
+			return NULL;
+		}
+		puts("OK\n");
+	}
+
+	show_boot_progress (11);
+
+	if (!image_check_os (rd_hdr, IH_OS_LINUX) ||
+	    !image_check_arch (rd_hdr, arch) ||
+	    !image_check_type (rd_hdr, IH_TYPE_RAMDISK)) {
+		printf ("No Linux %s Ramdisk Image\n",
+				genimg_get_arch_name(arch));
+		show_boot_progress (-13);
+		return NULL;
+	}
+
+	return rd_hdr;
+}
+#endif /* !USE_HOSTCC */
+
+/*****************************************************************************/
+/* Shared dual-format routines */
+/*****************************************************************************/
+#ifndef USE_HOSTCC
+int getenv_yesno (char *var)
+{
+	char *s = getenv (var);
+	return (s && (*s == 'n')) ? 0 : 1;
+}
+
+ulong getenv_bootm_low(void)
+{
+	char *s = getenv ("bootm_low");
+	if (s) {
+		ulong tmp = simple_strtoul (s, NULL, 16);
+		return tmp;
+	}
+
+#if defined(CFG_SDRAM_BASE)
+	return CFG_SDRAM_BASE;
+#elif defined(CONFIG_ARM)
+	return gd->bd->bi_dram[0].start;
+#else
+	return 0;
+#endif
+}
+
+phys_size_t getenv_bootm_size(void)
+{
+	char *s = getenv ("bootm_size");
+	if (s) {
+		phys_size_t tmp;
+#ifdef CFG_64BIT_STRTOUL
+		tmp = (phys_size_t)simple_strtoull (s, NULL, 16);
+#else
+		tmp = (phys_size_t)simple_strtoul (s, NULL, 16);
+#endif
+		return tmp;
+	}
+
+#if defined(CONFIG_ARM)
+	return gd->bd->bi_dram[0].size;
+#else
+	return gd->bd->bi_memsize;
+#endif
+}
+
+void memmove_wd (void *to, void *from, size_t len, ulong chunksz)
+{
+#if defined(CONFIG_HW_WATCHDOG) || defined(CONFIG_WATCHDOG)
+	while (len > 0) {
+		size_t tail = (len > chunksz) ? chunksz : len;
+		WATCHDOG_RESET ();
+		memmove (to, from, tail);
+		to += tail;
+		from += tail;
+		len -= tail;
+	}
+#else	/* !(CONFIG_HW_WATCHDOG || CONFIG_WATCHDOG) */
+	memmove (to, from, len);
+#endif	/* CONFIG_HW_WATCHDOG || CONFIG_WATCHDOG */
+}
+#endif /* !USE_HOSTCC */
+
+static void genimg_print_size (uint32_t size)
+{
+#ifndef USE_HOSTCC
+	printf ("%d Bytes = ", size);
+	print_size (size, "\n");
+#else
+	printf ("%d Bytes = %.2f kB = %.2f MB\n",
+			size, (double)size / 1.024e3,
+			(double)size / 1.048576e6);
+#endif
+}
+
+#if defined(CONFIG_TIMESTAMP) || defined(CONFIG_CMD_DATE) || defined(USE_HOSTCC)
+static void genimg_print_time (time_t timestamp)
+{
+#ifndef USE_HOSTCC
+	struct rtc_time tm;
+
+	to_tm (timestamp, &tm);
+	printf ("%4d-%02d-%02d  %2d:%02d:%02d UTC\n",
+			tm.tm_year, tm.tm_mon, tm.tm_mday,
+			tm.tm_hour, tm.tm_min, tm.tm_sec);
+#else
+	printf ("%s", ctime(&timestamp));
+#endif
+}
+#endif /* CONFIG_TIMESTAMP || CONFIG_CMD_DATE || USE_HOSTCC */
+
+/**
+ * get_table_entry_name - translate entry id to long name
+ * @table: pointer to a translation table for entries of a specific type
+ * @msg: message to be returned when translation fails
+ * @id: entry id to be translated
+ *
+ * get_table_entry_name() will go over translation table trying to find
+ * entry that matches given id. If matching entry is found, its long
+ * name is returned to the caller.
+ *
+ * returns:
+ *     long entry name if translation succeeds
+ *     msg otherwise
+ */
+static char *get_table_entry_name (table_entry_t *table, char *msg, int id)
+{
+	for (; table->id >= 0; ++table) {
+		if (table->id == id)
+			return (table->lname);
+	}
+	return (msg);
+}
+
+const char *genimg_get_os_name (uint8_t os)
+{
+	return (get_table_entry_name (uimage_os, "Unknown OS", os));
+}
+
+const char *genimg_get_arch_name (uint8_t arch)
+{
+	return (get_table_entry_name (uimage_arch, "Unknown Architecture", arch));
+}
+
+const char *genimg_get_type_name (uint8_t type)
+{
+	return (get_table_entry_name (uimage_type, "Unknown Image", type));
+}
+
+const char *genimg_get_comp_name (uint8_t comp)
+{
+	return (get_table_entry_name (uimage_comp, "Unknown Compression", comp));
+}
+
+/**
+ * get_table_entry_id - translate short entry name to id
+ * @table: pointer to a translation table for entries of a specific type
+ * @table_name: to be used in case of error
+ * @name: entry short name to be translated
+ *
+ * get_table_entry_id() will go over translation table trying to find
+ * entry that matches given short name. If matching entry is found,
+ * its id returned to the caller.
+ *
+ * returns:
+ *     entry id if translation succeeds
+ *     -1 otherwise
+ */
+static int get_table_entry_id (table_entry_t *table,
+		const char *table_name, const char *name)
+{
+	table_entry_t *t;
+#ifdef USE_HOSTCC
+	int first = 1;
+
+	for (t = table; t->id >= 0; ++t) {
+		if (t->sname && strcasecmp(t->sname, name) == 0)
+			return (t->id);
+	}
+
+	fprintf (stderr, "\nInvalid %s Type - valid names are", table_name);
+	for (t = table; t->id >= 0; ++t) {
+		if (t->sname == NULL)
+			continue;
+		fprintf (stderr, "%c %s", (first) ? ':' : ',', t->sname);
+		first = 0;
+	}
+	fprintf (stderr, "\n");
+#else
+	for (t = table; t->id >= 0; ++t) {
+		if (t->sname && strcmp(t->sname, name) == 0)
+			return (t->id);
+	}
+	debug ("Invalid %s Type: %s\n", table_name, name);
+#endif /* USE_HOSTCC */
+	return (-1);
+}
+
+int genimg_get_os_id (const char *name)
+{
+	return (get_table_entry_id (uimage_os, "OS", name));
+}
+
+int genimg_get_arch_id (const char *name)
+{
+	return (get_table_entry_id (uimage_arch, "CPU", name));
+}
+
+int genimg_get_type_id (const char *name)
+{
+	return (get_table_entry_id (uimage_type, "Image", name));
+}
+
+int genimg_get_comp_id (const char *name)
+{
+	return (get_table_entry_id (uimage_comp, "Compression", name));
+}
+
+#ifndef USE_HOSTCC
+/**
+ * genimg_get_format - get image format type
+ * @img_addr: image start address
+ *
+ * genimg_get_format() checks whether provided address points to a valid
+ * legacy or FIT image.
+ *
+ * New uImage format and FDT blob are based on a libfdt. FDT blob
+ * may be passed directly or embedded in a FIT image. In both situations
+ * genimg_get_format() must be able to dectect libfdt header.
+ *
+ * returns:
+ *     image format type or IMAGE_FORMAT_INVALID if no image is present
+ */
+int genimg_get_format (void *img_addr)
+{
+	ulong		format = IMAGE_FORMAT_INVALID;
+	image_header_t	*hdr;
+#if defined(CONFIG_FIT) || defined(CONFIG_OF_LIBFDT)
+	char		*fit_hdr;
+#endif
+
+	hdr = (image_header_t *)img_addr;
+	if (image_check_magic(hdr))
+		format = IMAGE_FORMAT_LEGACY;
+#if defined(CONFIG_FIT) || defined(CONFIG_OF_LIBFDT)
+	else {
+		fit_hdr = (char *)img_addr;
+		if (fdt_check_header (fit_hdr) == 0)
+			format = IMAGE_FORMAT_FIT;
+	}
+#endif
+
+	return format;
+}
+
+/**
+ * genimg_get_image - get image from special storage (if necessary)
+ * @img_addr: image start address
+ *
+ * genimg_get_image() checks if provided image start adddress is located
+ * in a dataflash storage. If so, image is moved to a system RAM memory.
+ *
+ * returns:
+ *     image start address after possible relocation from special storage
+ */
+ulong genimg_get_image (ulong img_addr)
+{
+	ulong ram_addr = img_addr;
+
+#ifdef CONFIG_HAS_DATAFLASH
+	ulong h_size, d_size;
+
+	if (addr_dataflash (img_addr)){
+		/* ger RAM address */
+		ram_addr = CFG_LOAD_ADDR;
+
+		/* get header size */
+		h_size = image_get_header_size ();
+#if defined(CONFIG_FIT)
+		if (sizeof(struct fdt_header) > h_size)
+			h_size = sizeof(struct fdt_header);
+#endif
+
+		/* read in header */
+		debug ("   Reading image header from dataflash address "
+			"%08lx to RAM address %08lx\n", img_addr, ram_addr);
+
+		read_dataflash (img_addr, h_size, (char *)ram_addr);
+
+		/* get data size */
+		switch (genimg_get_format ((void *)ram_addr)) {
+		case IMAGE_FORMAT_LEGACY:
+			d_size = image_get_data_size ((image_header_t *)ram_addr);
+			debug ("   Legacy format image found at 0x%08lx, size 0x%08lx\n",
+					ram_addr, d_size);
+			break;
+#if defined(CONFIG_FIT)
+		case IMAGE_FORMAT_FIT:
+			d_size = fit_get_size ((const void *)ram_addr) - h_size;
+			debug ("   FIT/FDT format image found at 0x%08lx, size 0x%08lx\n",
+					ram_addr, d_size);
+			break;
+#endif
+		default:
+			printf ("   No valid image found at 0x%08lx\n", img_addr);
+			return ram_addr;
+		}
+
+		/* read in image data */
+		debug ("   Reading image remaining data from dataflash address "
+			"%08lx to RAM address %08lx\n", img_addr + h_size,
+			ram_addr + h_size);
+
+		read_dataflash (img_addr + h_size, d_size,
+				(char *)(ram_addr + h_size));
+
+	}
+#endif /* CONFIG_HAS_DATAFLASH */
+
+	return ram_addr;
+}
+
+/**
+ * fit_has_config - check if there is a valid FIT configuration
+ * @images: pointer to the bootm command headers structure
+ *
+ * fit_has_config() checks if there is a FIT configuration in use
+ * (if FTI support is present).
+ *
+ * returns:
+ *     0, no FIT support or no configuration found
+ *     1, configuration found
+ */
+int genimg_has_config (bootm_headers_t *images)
+{
+#if defined(CONFIG_FIT)
+	if (images->fit_uname_cfg)
+		return 1;
+#endif
+	return 0;
+}
+
+/**
+ * boot_get_ramdisk - main ramdisk handling routine
+ * @argc: command argument count
+ * @argv: command argument list
+ * @images: pointer to the bootm images structure
+ * @arch: expected ramdisk architecture
+ * @rd_start: pointer to a ulong variable, will hold ramdisk start address
+ * @rd_end: pointer to a ulong variable, will hold ramdisk end
+ *
+ * boot_get_ramdisk() is responsible for finding a valid ramdisk image.
+ * Curently supported are the following ramdisk sources:
+ *      - multicomponent kernel/ramdisk image,
+ *      - commandline provided address of decicated ramdisk image.
+ *
+ * returns:
+ *     0, if ramdisk image was found and valid, or skiped
+ *     rd_start and rd_end are set to ramdisk start/end addresses if
+ *     ramdisk image is found and valid
+ *
+ *     1, if ramdisk image is found but corrupted
+ *     rd_start and rd_end are set to 0 if no ramdisk exists
+ */
+int boot_get_ramdisk (int argc, char *argv[], bootm_headers_t *images,
+		uint8_t arch, ulong *rd_start, ulong *rd_end)
+{
+	ulong rd_addr, rd_load;
+	ulong rd_data, rd_len;
+	image_header_t *rd_hdr;
+#if defined(CONFIG_FIT)
+	void		*fit_hdr;
+	const char	*fit_uname_config = NULL;
+	const char	*fit_uname_ramdisk = NULL;
+	ulong		default_addr;
+	int		rd_noffset;
+	int		cfg_noffset;
+	const void	*data;
+	size_t		size;
+#endif
+
+	*rd_start = 0;
+	*rd_end = 0;
+
+	/*
+	 * Look for a '-' which indicates to ignore the
+	 * ramdisk argument
+	 */
+	if ((argc >= 3) && (strcmp(argv[2], "-") ==  0)) {
+		debug ("## Skipping init Ramdisk\n");
+		rd_len = rd_data = 0;
+	} else if (argc >= 3 || genimg_has_config (images)) {
+#if defined(CONFIG_FIT)
+		if (argc >= 3) {
+			/*
+			 * If the init ramdisk comes from the FIT image and
+			 * the FIT image address is omitted in the command
+			 * line argument, try to use os FIT image address or
+			 * default load address.
+			 */
+			if (images->fit_uname_os)
+				default_addr = (ulong)images->fit_hdr_os;
+			else
+				default_addr = load_addr;
+
+			if (fit_parse_conf (argv[2], default_addr,
+						&rd_addr, &fit_uname_config)) {
+				debug ("*  ramdisk: config '%s' from image at 0x%08lx\n",
+						fit_uname_config, rd_addr);
+			} else if (fit_parse_subimage (argv[2], default_addr,
+						&rd_addr, &fit_uname_ramdisk)) {
+				debug ("*  ramdisk: subimage '%s' from image at 0x%08lx\n",
+						fit_uname_ramdisk, rd_addr);
+			} else
+#endif
+			{
+				rd_addr = simple_strtoul(argv[2], NULL, 16);
+				debug ("*  ramdisk: cmdline image address = 0x%08lx\n",
+						rd_addr);
+			}
+#if defined(CONFIG_FIT)
+		} else {
+			/* use FIT configuration provided in first bootm
+			 * command argument
+			 */
+			rd_addr = (ulong)images->fit_hdr_os;
+			fit_uname_config = images->fit_uname_cfg;
+			debug ("*  ramdisk: using config '%s' from image at 0x%08lx\n",
+					fit_uname_config, rd_addr);
+
+			/*
+			 * Check whether configuration has ramdisk defined,
+			 * if not, don't try to use it, quit silently.
+			 */
+			fit_hdr = (void *)rd_addr;
+			cfg_noffset = fit_conf_get_node (fit_hdr, fit_uname_config);
+			if (cfg_noffset < 0) {
+				debug ("*  ramdisk: no such config\n");
+				return 1;
+			}
+
+			rd_noffset = fit_conf_get_ramdisk_node (fit_hdr, cfg_noffset);
+			if (rd_noffset < 0) {
+				debug ("*  ramdisk: no ramdisk in config\n");
+				return 0;
+			}
+		}
+#endif
+
+		/* copy from dataflash if needed */
+		rd_addr = genimg_get_image (rd_addr);
+
+		/*
+		 * Check if there is an initrd image at the
+		 * address provided in the second bootm argument
+		 * check image type, for FIT images get FIT node.
+		 */
+		switch (genimg_get_format ((void *)rd_addr)) {
+		case IMAGE_FORMAT_LEGACY:
+			printf ("## Loading init Ramdisk from Legacy "
+					"Image at %08lx ...\n", rd_addr);
+
+			show_boot_progress (9);
+			rd_hdr = image_get_ramdisk (rd_addr, arch,
+							images->verify);
+
+			if (rd_hdr == NULL)
+				return 1;
+
+			rd_data = image_get_data (rd_hdr);
+			rd_len = image_get_data_size (rd_hdr);
+			rd_load = image_get_load (rd_hdr);
+			break;
+#if defined(CONFIG_FIT)
+		case IMAGE_FORMAT_FIT:
+			fit_hdr = (void *)rd_addr;
+			printf ("## Loading init Ramdisk from FIT "
+					"Image at %08lx ...\n", rd_addr);
+
+			show_boot_progress (120);
+			if (!fit_check_format (fit_hdr)) {
+				puts ("Bad FIT ramdisk image format!\n");
+				show_boot_progress (-120);
+				return 1;
+			}
+			show_boot_progress (121);
+
+			if (!fit_uname_ramdisk) {
+				/*
+				 * no ramdisk image node unit name, try to get config
+				 * node first. If config unit node name is NULL
+				 * fit_conf_get_node() will try to find default config node
+				 */
+				show_boot_progress (122);
+				cfg_noffset = fit_conf_get_node (fit_hdr, fit_uname_config);
+				if (cfg_noffset < 0) {
+					puts ("Could not find configuration node\n");
+					show_boot_progress (-122);
+					return 1;
+				}
+				fit_uname_config = fdt_get_name (fit_hdr, cfg_noffset, NULL);
+				printf ("   Using '%s' configuration\n", fit_uname_config);
+
+				rd_noffset = fit_conf_get_ramdisk_node (fit_hdr, cfg_noffset);
+				fit_uname_ramdisk = fit_get_name (fit_hdr, rd_noffset, NULL);
+			} else {
+				/* get ramdisk component image node offset */
+				show_boot_progress (123);
+				rd_noffset = fit_image_get_node (fit_hdr, fit_uname_ramdisk);
+			}
+			if (rd_noffset < 0) {
+				puts ("Could not find subimage node\n");
+				show_boot_progress (-124);
+				return 1;
+			}
+
+			printf ("   Trying '%s' ramdisk subimage\n", fit_uname_ramdisk);
+
+			show_boot_progress (125);
+			if (!fit_check_ramdisk (fit_hdr, rd_noffset, arch, images->verify))
+				return 1;
+
+			/* get ramdisk image data address and length */
+			if (fit_image_get_data (fit_hdr, rd_noffset, &data, &size)) {
+				puts ("Could not find ramdisk subimage data!\n");
+				show_boot_progress (-127);
+				return 1;
+			}
+			show_boot_progress (128);
+
+			rd_data = (ulong)data;
+			rd_len = size;
+
+			if (fit_image_get_load (fit_hdr, rd_noffset, &rd_load)) {
+				puts ("Can't get ramdisk subimage load address!\n");
+				show_boot_progress (-129);
+				return 1;
+			}
+			show_boot_progress (129);
+
+			images->fit_hdr_rd = fit_hdr;
+			images->fit_uname_rd = fit_uname_ramdisk;
+			images->fit_noffset_rd = rd_noffset;
+			break;
+#endif
+		default:
+			puts ("Wrong Ramdisk Image Format\n");
+			rd_data = rd_len = rd_load = 0;
+		}
+
+#if defined(CONFIG_B2) || defined(CONFIG_EVB4510) || defined(CONFIG_ARMADILLO)
+		/*
+		 * We need to copy the ramdisk to SRAM to let Linux boot
+		 */
+		if (rd_data) {
+			memmove ((void *)rd_load, (uchar *)rd_data, rd_len);
+			rd_data = rd_load;
+		}
+#endif /* CONFIG_B2 || CONFIG_EVB4510 || CONFIG_ARMADILLO */
+
+	} else if (images->legacy_hdr_valid &&
+			image_check_type (&images->legacy_hdr_os_copy, IH_TYPE_MULTI)) {
+		/*
+		 * Now check if we have a legacy mult-component image,
+		 * get second entry data start address and len.
+		 */
+		show_boot_progress (13);
+		printf ("## Loading init Ramdisk from multi component "
+				"Legacy Image at %08lx ...\n",
+				(ulong)images->legacy_hdr_os);
+
+		image_multi_getimg (images->legacy_hdr_os, 1, &rd_data, &rd_len);
+	} else {
+		/*
+		 * no initrd image
+		 */
+		show_boot_progress (14);
+		rd_len = rd_data = 0;
+	}
+
+	if (!rd_data) {
+		debug ("## No init Ramdisk\n");
+	} else {
+		*rd_start = rd_data;
+		*rd_end = rd_data + rd_len;
+	}
+	debug ("   ramdisk start = 0x%08lx, ramdisk end = 0x%08lx\n",
+			*rd_start, *rd_end);
+
+	return 0;
+}
+
+#if defined(CONFIG_PPC) || defined(CONFIG_M68K) || defined(CONFIG_SPARC)
+/**
+ * boot_ramdisk_high - relocate init ramdisk
+ * @lmb: pointer to lmb handle, will be used for memory mgmt
+ * @rd_data: ramdisk data start address
+ * @rd_len: ramdisk data length
+ * @initrd_start: pointer to a ulong variable, will hold final init ramdisk
+ *      start address (after possible relocation)
+ * @initrd_end: pointer to a ulong variable, will hold final init ramdisk
+ *      end address (after possible relocation)
+ *
+ * boot_ramdisk_high() takes a relocation hint from "initrd_high" environement
+ * variable and if requested ramdisk data is moved to a specified location.
+ *
+ * Initrd_start and initrd_end are set to final (after relocation) ramdisk
+ * start/end addresses if ramdisk image start and len were provided,
+ * otherwise set initrd_start and initrd_end set to zeros.
+ *
+ * returns:
+ *      0 - success
+ *     -1 - failure
+ */
+int boot_ramdisk_high (struct lmb *lmb, ulong rd_data, ulong rd_len,
+		  ulong *initrd_start, ulong *initrd_end)
+{
+	char	*s;
+	ulong	initrd_high;
+	int	initrd_copy_to_ram = 1;
+
+	if ((s = getenv ("initrd_high")) != NULL) {
+		/* a value of "no" or a similar string will act like 0,
+		 * turning the "load high" feature off. This is intentional.
+		 */
+		initrd_high = simple_strtoul (s, NULL, 16);
+		if (initrd_high == ~0)
+			initrd_copy_to_ram = 0;
+	} else {
+		/* not set, no restrictions to load high */
+		initrd_high = ~0;
+	}
+
+
+#ifdef CONFIG_LOGBUFFER
+	/* Prevent initrd from overwriting logbuffer */
+	lmb_reserve(lmb, logbuffer_base() - LOGBUFF_OVERHEAD, LOGBUFF_RESERVE);
+#endif
+
+	debug ("## initrd_high = 0x%08lx, copy_to_ram = %d\n",
+			initrd_high, initrd_copy_to_ram);
+
+	if (rd_data) {
+		if (!initrd_copy_to_ram) {	/* zero-copy ramdisk support */
+			debug ("   in-place initrd\n");
+			*initrd_start = rd_data;
+			*initrd_end = rd_data + rd_len;
+			lmb_reserve(lmb, rd_data, rd_len);
+		} else {
+			if (initrd_high)
+				*initrd_start = (ulong)lmb_alloc_base (lmb, rd_len, 0x1000, initrd_high);
+			else
+				*initrd_start = (ulong)lmb_alloc (lmb, rd_len, 0x1000);
+
+			if (*initrd_start == 0) {
+				puts ("ramdisk - allocation error\n");
+				goto error;
+			}
+			show_boot_progress (12);
+
+			*initrd_end = *initrd_start + rd_len;
+			printf ("   Loading Ramdisk to %08lx, end %08lx ... ",
+					*initrd_start, *initrd_end);
+
+			memmove_wd ((void *)*initrd_start,
+					(void *)rd_data, rd_len, CHUNKSZ);
+
+			puts ("OK\n");
+		}
+	} else {
+		*initrd_start = 0;
+		*initrd_end = 0;
+	}
+	debug ("   ramdisk load start = 0x%08lx, ramdisk load end = 0x%08lx\n",
+			*initrd_start, *initrd_end);
+
+	return 0;
+
+error:
+	return -1;
+}
+
+/**
+ * boot_get_cmdline - allocate and initialize kernel cmdline
+ * @lmb: pointer to lmb handle, will be used for memory mgmt
+ * @cmd_start: pointer to a ulong variable, will hold cmdline start
+ * @cmd_end: pointer to a ulong variable, will hold cmdline end
+ * @bootmap_base: ulong variable, holds offset in physical memory to
+ * base of bootmap
+ *
+ * boot_get_cmdline() allocates space for kernel command line below
+ * BOOTMAPSZ + bootmap_base address. If "bootargs" U-boot environemnt
+ * variable is present its contents is copied to allocated kernel
+ * command line.
+ *
+ * returns:
+ *      0 - success
+ *     -1 - failure
+ */
+int boot_get_cmdline (struct lmb *lmb, ulong *cmd_start, ulong *cmd_end,
+			ulong bootmap_base)
+{
+	char *cmdline;
+	char *s;
+
+	cmdline = (char *)(ulong)lmb_alloc_base(lmb, CFG_BARGSIZE, 0xf,
+					 CFG_BOOTMAPSZ + bootmap_base);
+
+	if (cmdline == NULL)
+		return -1;
+
+	if ((s = getenv("bootargs")) == NULL)
+		s = "";
+
+	strcpy(cmdline, s);
+
+	*cmd_start = (ulong) & cmdline[0];
+	*cmd_end = *cmd_start + strlen(cmdline);
+
+	debug ("## cmdline at 0x%08lx ... 0x%08lx\n", *cmd_start, *cmd_end);
+
+	return 0;
+}
+
+/**
+ * boot_get_kbd - allocate and initialize kernel copy of board info
+ * @lmb: pointer to lmb handle, will be used for memory mgmt
+ * @kbd: double pointer to board info data
+ * @bootmap_base: ulong variable, holds offset in physical memory to
+ * base of bootmap
+ *
+ * boot_get_kbd() allocates space for kernel copy of board info data below
+ * BOOTMAPSZ + bootmap_base address and kernel board info is initialized with
+ * the current u-boot board info data.
+ *
+ * returns:
+ *      0 - success
+ *     -1 - failure
+ */
+int boot_get_kbd (struct lmb *lmb, bd_t **kbd, ulong bootmap_base)
+{
+	*kbd = (bd_t *)(ulong)lmb_alloc_base(lmb, sizeof(bd_t), 0xf,
+				      CFG_BOOTMAPSZ + bootmap_base);
+	if (*kbd == NULL)
+		return -1;
+
+	**kbd = *(gd->bd);
+
+	debug ("## kernel board info at 0x%08lx\n", (ulong)*kbd);
+
+#if defined(DEBUG) && defined(CONFIG_CMD_BDI)
+	do_bdinfo(NULL, 0, 0, NULL);
+#endif
+
+	return 0;
+}
+#endif /* CONFIG_PPC || CONFIG_M68K */
+#endif /* !USE_HOSTCC */
+
+#if defined(CONFIG_FIT)
+/*****************************************************************************/
+/* New uImage format routines */
+/*****************************************************************************/
+#ifndef USE_HOSTCC
+static int fit_parse_spec (const char *spec, char sepc, ulong addr_curr,
+		ulong *addr, const char **name)
+{
+	const char *sep;
+
+	*addr = addr_curr;
+	*name = NULL;
+
+	sep = strchr (spec, sepc);
+	if (sep) {
+		if (sep - spec > 0)
+			*addr = simple_strtoul (spec, NULL, 16);
+
+		*name = sep + 1;
+		return 1;
+	}
+
+	return 0;
+}
+
+/**
+ * fit_parse_conf - parse FIT configuration spec
+ * @spec: input string, containing configuration spec
+ * @add_curr: current image address (to be used as a possible default)
+ * @addr: pointer to a ulong variable, will hold FIT image address of a given
+ * configuration
+ * @conf_name double pointer to a char, will hold pointer to a configuration
+ * unit name
+ *
+ * fit_parse_conf() expects configuration spec in the for of [<addr>]#<conf>,
+ * where <addr> is a FIT image address that contains configuration
+ * with a <conf> unit name.
+ *
+ * Address part is optional, and if omitted default add_curr will
+ * be used instead.
+ *
+ * returns:
+ *     1 if spec is a valid configuration string,
+ *     addr and conf_name are set accordingly
+ *     0 otherwise
+ */
+inline int fit_parse_conf (const char *spec, ulong addr_curr,
+		ulong *addr, const char **conf_name)
+{
+	return fit_parse_spec (spec, '#', addr_curr, addr, conf_name);
+}
+
+/**
+ * fit_parse_subimage - parse FIT subimage spec
+ * @spec: input string, containing subimage spec
+ * @add_curr: current image address (to be used as a possible default)
+ * @addr: pointer to a ulong variable, will hold FIT image address of a given
+ * subimage
+ * @image_name: double pointer to a char, will hold pointer to a subimage name
+ *
+ * fit_parse_subimage() expects subimage spec in the for of
+ * [<addr>]:<subimage>, where <addr> is a FIT image address that contains
+ * subimage with a <subimg> unit name.
+ *
+ * Address part is optional, and if omitted default add_curr will
+ * be used instead.
+ *
+ * returns:
+ *     1 if spec is a valid subimage string,
+ *     addr and image_name are set accordingly
+ *     0 otherwise
+ */
+inline int fit_parse_subimage (const char *spec, ulong addr_curr,
+		ulong *addr, const char **image_name)
+{
+	return fit_parse_spec (spec, ':', addr_curr, addr, image_name);
+}
+#endif /* !USE_HOSTCC */
+
+static void fit_get_debug (const void *fit, int noffset,
+		char *prop_name, int err)
+{
+	debug ("Can't get '%s' property from FIT 0x%08lx, "
+		"node: offset %d, name %s (%s)\n",
+		prop_name, (ulong)fit, noffset,
+		fit_get_name (fit, noffset, NULL),
+		fdt_strerror (err));
+}
+
+/**
+ * fit_print_contents - prints out the contents of the FIT format image
+ * @fit: pointer to the FIT format image header
+ * @p: pointer to prefix string
+ *
+ * fit_print_contents() formats a multi line FIT image contents description.
+ * The routine prints out FIT image properties (root node level) follwed by
+ * the details of each component image.
+ *
+ * returns:
+ *     no returned results
+ */
+void fit_print_contents (const void *fit)
+{
+	char *desc;
+	char *uname;
+	int images_noffset;
+	int confs_noffset;
+	int noffset;
+	int ndepth;
+	int count = 0;
+	int ret;
+	const char *p;
+#if defined(CONFIG_TIMESTAMP) || defined(CONFIG_CMD_DATE) || defined(USE_HOSTCC)
+	time_t timestamp;
+#endif
+
+#ifdef USE_HOSTCC
+	p = "";
+#else
+	p = "   ";
+#endif
+
+	/* Root node properties */
+	ret = fit_get_desc (fit, 0, &desc);
+	printf ("%sFIT description: ", p);
+	if (ret)
+		printf ("unavailable\n");
+	else
+		printf ("%s\n", desc);
+
+#if defined(CONFIG_TIMESTAMP) || defined(CONFIG_CMD_DATE) || defined(USE_HOSTCC)
+	ret = fit_get_timestamp (fit, 0, &timestamp);
+	printf ("%sCreated:         ", p);
+	if (ret)
+		printf ("unavailable\n");
+	else
+		genimg_print_time (timestamp);
+#endif
+
+	/* Find images parent node offset */
+	images_noffset = fdt_path_offset (fit, FIT_IMAGES_PATH);
+	if (images_noffset < 0) {
+		printf ("Can't find images parent node '%s' (%s)\n",
+			FIT_IMAGES_PATH, fdt_strerror (images_noffset));
+		return;
+	}
+
+	/* Process its subnodes, print out component images details */
+	for (ndepth = 0, count = 0, noffset = fdt_next_node (fit, images_noffset, &ndepth);
+	     (noffset >= 0) && (ndepth > 0);
+	     noffset = fdt_next_node (fit, noffset, &ndepth)) {
+		if (ndepth == 1) {
+			/*
+			 * Direct child node of the images parent node,
+			 * i.e. component image node.
+			 */
+			printf ("%s Image %u (%s)\n", p, count++,
+					fit_get_name(fit, noffset, NULL));
+
+			fit_image_print (fit, noffset, p);
+		}
+	}
+
+	/* Find configurations parent node offset */
+	confs_noffset = fdt_path_offset (fit, FIT_CONFS_PATH);
+	if (confs_noffset < 0) {
+		debug ("Can't get configurations parent node '%s' (%s)\n",
+			FIT_CONFS_PATH, fdt_strerror (confs_noffset));
+		return;
+	}
+
+	/* get default configuration unit name from default property */
+	uname = (char *)fdt_getprop (fit, noffset, FIT_DEFAULT_PROP, NULL);
+	if (uname)
+		printf ("%s Default Configuration: '%s'\n", p, uname);
+
+	/* Process its subnodes, print out configurations details */
+	for (ndepth = 0, count = 0, noffset = fdt_next_node (fit, confs_noffset, &ndepth);
+	     (noffset >= 0) && (ndepth > 0);
+	     noffset = fdt_next_node (fit, noffset, &ndepth)) {
+		if (ndepth == 1) {
+			/*
+			 * Direct child node of the configurations parent node,
+			 * i.e. configuration node.
+			 */
+			printf ("%s Configuration %u (%s)\n", p, count++,
+					fit_get_name(fit, noffset, NULL));
+
+			fit_conf_print (fit, noffset, p);
+		}
+	}
+}
+
+/**
+ * fit_image_print - prints out the FIT component image details
+ * @fit: pointer to the FIT format image header
+ * @image_noffset: offset of the component image node
+ * @p: pointer to prefix string
+ *
+ * fit_image_print() lists all mandatory properies for the processed component
+ * image. If present, hash nodes are printed out as well.
+ *
+ * returns:
+ *     no returned results
+ */
+void fit_image_print (const void *fit, int image_noffset, const char *p)
+{
+	char *desc;
+	uint8_t type, arch, os, comp;
+	size_t size;
+	ulong load, entry;
+	const void *data;
+	int noffset;
+	int ndepth;
+	int ret;
+
+	/* Mandatory properties */
+	ret = fit_get_desc (fit, image_noffset, &desc);
+	printf ("%s  Description:  ", p);
+	if (ret)
+		printf ("unavailable\n");
+	else
+		printf ("%s\n", desc);
+
+	fit_image_get_type (fit, image_noffset, &type);
+	printf ("%s  Type:         %s\n", p, genimg_get_type_name (type));
+
+	fit_image_get_comp (fit, image_noffset, &comp);
+	printf ("%s  Compression:  %s\n", p, genimg_get_comp_name (comp));
+
+	ret = fit_image_get_data (fit, image_noffset, &data, &size);
+
+#ifndef USE_HOSTCC
+	printf ("%s  Data Start:   ", p);
+	if (ret)
+		printf ("unavailable\n");
+	else
+		printf ("0x%08lx\n", (ulong)data);
+#endif
+
+	printf ("%s  Data Size:    ", p);
+	if (ret)
+		printf ("unavailable\n");
+	else
+		genimg_print_size (size);
+
+	/* Remaining, type dependent properties */
+	if ((type == IH_TYPE_KERNEL) || (type == IH_TYPE_STANDALONE) ||
+	    (type == IH_TYPE_RAMDISK) || (type == IH_TYPE_FIRMWARE) ||
+	    (type == IH_TYPE_FLATDT)) {
+		fit_image_get_arch (fit, image_noffset, &arch);
+		printf ("%s  Architecture: %s\n", p, genimg_get_arch_name (arch));
+	}
+
+	if (type == IH_TYPE_KERNEL) {
+		fit_image_get_os (fit, image_noffset, &os);
+		printf ("%s  OS:           %s\n", p, genimg_get_os_name (os));
+	}
+
+	if ((type == IH_TYPE_KERNEL) || (type == IH_TYPE_STANDALONE)) {
+		ret = fit_image_get_load (fit, image_noffset, &load);
+		printf ("%s  Load Address: ", p);
+		if (ret)
+			printf ("unavailable\n");
+		else
+			printf ("0x%08lx\n", load);
+
+		fit_image_get_entry (fit, image_noffset, &entry);
+		printf ("%s  Entry Point:  ", p);
+		if (ret)
+			printf ("unavailable\n");
+		else
+			printf ("0x%08lx\n", entry);
+	}
+
+	/* Process all hash subnodes of the component image node */
+	for (ndepth = 0, noffset = fdt_next_node (fit, image_noffset, &ndepth);
+	     (noffset >= 0) && (ndepth > 0);
+	     noffset = fdt_next_node (fit, noffset, &ndepth)) {
+		if (ndepth == 1) {
+			/* Direct child node of the component image node */
+			fit_image_print_hash (fit, noffset, p);
+		}
+	}
+}
+
+/**
+ * fit_image_print_hash - prints out the hash node details
+ * @fit: pointer to the FIT format image header
+ * @noffset: offset of the hash node
+ * @p: pointer to prefix string
+ *
+ * fit_image_print_hash() lists properies for the processed hash node
+ *
+ * returns:
+ *     no returned results
+ */
+void fit_image_print_hash (const void *fit, int noffset, const char *p)
+{
+	char *algo;
+	uint8_t *value;
+	int value_len;
+	int i, ret;
+
+	/*
+	 * Check subnode name, must be equal to "hash".
+	 * Multiple hash nodes require unique unit node
+	 * names, e.g. hash@1, hash@2, etc.
+	 */
+	if (strncmp (fit_get_name(fit, noffset, NULL),
+			FIT_HASH_NODENAME,
+			strlen(FIT_HASH_NODENAME)) != 0)
+		return;
+
+	debug ("%s  Hash node:    '%s'\n", p,
+			fit_get_name (fit, noffset, NULL));
+
+	printf ("%s  Hash algo:    ", p);
+	if (fit_image_hash_get_algo (fit, noffset, &algo)) {
+		printf ("invalid/unsupported\n");
+		return;
+	}
+	printf ("%s\n", algo);
+
+	ret = fit_image_hash_get_value (fit, noffset, &value,
+					&value_len);
+	printf ("%s  Hash value:   ", p);
+	if (ret) {
+		printf ("unavailable\n");
+	} else {
+		for (i = 0; i < value_len; i++)
+			printf ("%02x", value[i]);
+		printf ("\n");
+	}
+
+	debug  ("%s  Hash len:     %d\n", p, value_len);
+}
+
+/**
+ * fit_get_desc - get node description property
+ * @fit: pointer to the FIT format image header
+ * @noffset: node offset
+ * @desc: double pointer to the char, will hold pointer to the descrption
+ *
+ * fit_get_desc() reads description property from a given node, if
+ * description is found pointer to it is returened in third call argument.
+ *
+ * returns:
+ *     0, on success
+ *     -1, on failure
+ */
+int fit_get_desc (const void *fit, int noffset, char **desc)
+{
+	int len;
+
+	*desc = (char *)fdt_getprop (fit, noffset, FIT_DESC_PROP, &len);
+	if (*desc == NULL) {
+		fit_get_debug (fit, noffset, FIT_DESC_PROP, len);
+		return -1;
+	}
+
+	return 0;
+}
+
+/**
+ * fit_get_timestamp - get node timestamp property
+ * @fit: pointer to the FIT format image header
+ * @noffset: node offset
+ * @timestamp: pointer to the time_t, will hold read timestamp
+ *
+ * fit_get_timestamp() reads timestamp poperty from given node, if timestamp
+ * is found and has a correct size its value is retured in third call
+ * argument.
+ *
+ * returns:
+ *     0, on success
+ *     -1, on property read failure
+ *     -2, on wrong timestamp size
+ */
+int fit_get_timestamp (const void *fit, int noffset, time_t *timestamp)
+{
+	int len;
+	const void *data;
+
+	data = fdt_getprop (fit, noffset, FIT_TIMESTAMP_PROP, &len);
+	if (data == NULL) {
+		fit_get_debug (fit, noffset, FIT_TIMESTAMP_PROP, len);
+		return -1;
+	}
+	if (len != sizeof (uint32_t)) {
+		debug ("FIT timestamp with incorrect size of (%u)\n", len);
+		return -2;
+	}
+
+	*timestamp = uimage_to_cpu (*((uint32_t *)data));
+	return 0;
+}
+
+/**
+ * fit_image_get_node - get node offset for component image of a given unit name
+ * @fit: pointer to the FIT format image header
+ * @image_uname: component image node unit name
+ *
+ * fit_image_get_node() finds a component image (withing the '/images'
+ * node) of a provided unit name. If image is found its node offset is
+ * returned to the caller.
+ *
+ * returns:
+ *     image node offset when found (>=0)
+ *     negative number on failure (FDT_ERR_* code)
+ */
+int fit_image_get_node (const void *fit, const char *image_uname)
+{
+	int noffset, images_noffset;
+
+	images_noffset = fdt_path_offset (fit, FIT_IMAGES_PATH);
+	if (images_noffset < 0) {
+		debug ("Can't find images parent node '%s' (%s)\n",
+			FIT_IMAGES_PATH, fdt_strerror (images_noffset));
+		return images_noffset;
+	}
+
+	noffset = fdt_subnode_offset (fit, images_noffset, image_uname);
+	if (noffset < 0) {
+		debug ("Can't get node offset for image unit name: '%s' (%s)\n",
+			image_uname, fdt_strerror (noffset));
+	}
+
+	return noffset;
+}
+
+/**
+ * fit_image_get_os - get os id for a given component image node
+ * @fit: pointer to the FIT format image header
+ * @noffset: component image node offset
+ * @os: pointer to the uint8_t, will hold os numeric id
+ *
+ * fit_image_get_os() finds os property in a given component image node.
+ * If the property is found, its (string) value is translated to the numeric
+ * id which is returned to the caller.
+ *
+ * returns:
+ *     0, on success
+ *     -1, on failure
+ */
+int fit_image_get_os (const void *fit, int noffset, uint8_t *os)
+{
+	int len;
+	const void *data;
+
+	/* Get OS name from property data */
+	data = fdt_getprop (fit, noffset, FIT_OS_PROP, &len);
+	if (data == NULL) {
+		fit_get_debug (fit, noffset, FIT_OS_PROP, len);
+		*os = -1;
+		return -1;
+	}
+
+	/* Translate OS name to id */
+	*os = genimg_get_os_id (data);
+	return 0;
+}
+
+/**
+ * fit_image_get_arch - get arch id for a given component image node
+ * @fit: pointer to the FIT format image header
+ * @noffset: component image node offset
+ * @arch: pointer to the uint8_t, will hold arch numeric id
+ *
+ * fit_image_get_arch() finds arch property in a given component image node.
+ * If the property is found, its (string) value is translated to the numeric
+ * id which is returned to the caller.
+ *
+ * returns:
+ *     0, on success
+ *     -1, on failure
+ */
+int fit_image_get_arch (const void *fit, int noffset, uint8_t *arch)
+{
+	int len;
+	const void *data;
+
+	/* Get architecture name from property data */
+	data = fdt_getprop (fit, noffset, FIT_ARCH_PROP, &len);
+	if (data == NULL) {
+		fit_get_debug (fit, noffset, FIT_ARCH_PROP, len);
+		*arch = -1;
+		return -1;
+	}
+
+	/* Translate architecture name to id */
+	*arch = genimg_get_arch_id (data);
+	return 0;
+}
+
+/**
+ * fit_image_get_type - get type id for a given component image node
+ * @fit: pointer to the FIT format image header
+ * @noffset: component image node offset
+ * @type: pointer to the uint8_t, will hold type numeric id
+ *
+ * fit_image_get_type() finds type property in a given component image node.
+ * If the property is found, its (string) value is translated to the numeric
+ * id which is returned to the caller.
+ *
+ * returns:
+ *     0, on success
+ *     -1, on failure
+ */
+int fit_image_get_type (const void *fit, int noffset, uint8_t *type)
+{
+	int len;
+	const void *data;
+
+	/* Get image type name from property data */
+	data = fdt_getprop (fit, noffset, FIT_TYPE_PROP, &len);
+	if (data == NULL) {
+		fit_get_debug (fit, noffset, FIT_TYPE_PROP, len);
+		*type = -1;
+		return -1;
+	}
+
+	/* Translate image type name to id */
+	*type = genimg_get_type_id (data);
+	return 0;
+}
+
+/**
+ * fit_image_get_comp - get comp id for a given component image node
+ * @fit: pointer to the FIT format image header
+ * @noffset: component image node offset
+ * @comp: pointer to the uint8_t, will hold comp numeric id
+ *
+ * fit_image_get_comp() finds comp property in a given component image node.
+ * If the property is found, its (string) value is translated to the numeric
+ * id which is returned to the caller.
+ *
+ * returns:
+ *     0, on success
+ *     -1, on failure
+ */
+int fit_image_get_comp (const void *fit, int noffset, uint8_t *comp)
+{
+	int len;
+	const void *data;
+
+	/* Get compression name from property data */
+	data = fdt_getprop (fit, noffset, FIT_COMP_PROP, &len);
+	if (data == NULL) {
+		fit_get_debug (fit, noffset, FIT_COMP_PROP, len);
+		*comp = -1;
+		return -1;
+	}
+
+	/* Translate compression name to id */
+	*comp = genimg_get_comp_id (data);
+	return 0;
+}
+
+/**
+ * fit_image_get_load - get load address property for a given component image node
+ * @fit: pointer to the FIT format image header
+ * @noffset: component image node offset
+ * @load: pointer to the uint32_t, will hold load address
+ *
+ * fit_image_get_load() finds load address property in a given component image node.
+ * If the property is found, its value is returned to the caller.
+ *
+ * returns:
+ *     0, on success
+ *     -1, on failure
+ */
+int fit_image_get_load (const void *fit, int noffset, ulong *load)
+{
+	int len;
+	const uint32_t *data;
+
+	data = fdt_getprop (fit, noffset, FIT_LOAD_PROP, &len);
+	if (data == NULL) {
+		fit_get_debug (fit, noffset, FIT_LOAD_PROP, len);
+		return -1;
+	}
+
+	*load = uimage_to_cpu (*data);
+	return 0;
+}
+
+/**
+ * fit_image_get_entry - get entry point address property for a given component image node
+ * @fit: pointer to the FIT format image header
+ * @noffset: component image node offset
+ * @entry: pointer to the uint32_t, will hold entry point address
+ *
+ * fit_image_get_entry() finds entry point address property in a given component image node.
+ * If the property is found, its value is returned to the caller.
+ *
+ * returns:
+ *     0, on success
+ *     -1, on failure
+ */
+int fit_image_get_entry (const void *fit, int noffset, ulong *entry)
+{
+	int len;
+	const uint32_t *data;
+
+	data = fdt_getprop (fit, noffset, FIT_ENTRY_PROP, &len);
+	if (data == NULL) {
+		fit_get_debug (fit, noffset, FIT_ENTRY_PROP, len);
+		return -1;
+	}
+
+	*entry = uimage_to_cpu (*data);
+	return 0;
+}
+
+/**
+ * fit_image_get_data - get data property and its size for a given component image node
+ * @fit: pointer to the FIT format image header
+ * @noffset: component image node offset
+ * @data: double pointer to void, will hold data property's data address
+ * @size: pointer to size_t, will hold data property's data size
+ *
+ * fit_image_get_data() finds data property in a given component image node.
+ * If the property is found its data start address and size are returned to
+ * the caller.
+ *
+ * returns:
+ *     0, on success
+ *     -1, on failure
+ */
+int fit_image_get_data (const void *fit, int noffset,
+		const void **data, size_t *size)
+{
+	int len;
+
+	*data = fdt_getprop (fit, noffset, FIT_DATA_PROP, &len);
+	if (*data == NULL) {
+		fit_get_debug (fit, noffset, FIT_DATA_PROP, len);
+		*size = 0;
+		return -1;
+	}
+
+	*size = len;
+	return 0;
+}
+
+/**
+ * fit_image_hash_get_algo - get hash algorithm name
+ * @fit: pointer to the FIT format image header
+ * @noffset: hash node offset
+ * @algo: double pointer to char, will hold pointer to the algorithm name
+ *
+ * fit_image_hash_get_algo() finds hash algorithm property in a given hash node.
+ * If the property is found its data start address is returned to the caller.
+ *
+ * returns:
+ *     0, on success
+ *     -1, on failure
+ */
+int fit_image_hash_get_algo (const void *fit, int noffset, char **algo)
+{
+	int len;
+
+	*algo = (char *)fdt_getprop (fit, noffset, FIT_ALGO_PROP, &len);
+	if (*algo == NULL) {
+		fit_get_debug (fit, noffset, FIT_ALGO_PROP, len);
+		return -1;
+	}
+
+	return 0;
+}
+
+/**
+ * fit_image_hash_get_value - get hash value and length
+ * @fit: pointer to the FIT format image header
+ * @noffset: hash node offset
+ * @value: double pointer to uint8_t, will hold address of a hash value data
+ * @value_len: pointer to an int, will hold hash data length
+ *
+ * fit_image_hash_get_value() finds hash value property in a given hash node.
+ * If the property is found its data start address and size are returned to
+ * the caller.
+ *
+ * returns:
+ *     0, on success
+ *     -1, on failure
+ */
+int fit_image_hash_get_value (const void *fit, int noffset, uint8_t **value,
+				int *value_len)
+{
+	int len;
+
+	*value = (uint8_t *)fdt_getprop (fit, noffset, FIT_VALUE_PROP, &len);
+	if (*value == NULL) {
+		fit_get_debug (fit, noffset, FIT_VALUE_PROP, len);
+		*value_len = 0;
+		return -1;
+	}
+
+	*value_len = len;
+	return 0;
+}
+
+/**
+ * fit_set_timestamp - set node timestamp property
+ * @fit: pointer to the FIT format image header
+ * @noffset: node offset
+ * @timestamp: timestamp value to be set
+ *
+ * fit_set_timestamp() attempts to set timestamp property in the requested
+ * node and returns operation status to the caller.
+ *
+ * returns:
+ *     0, on success
+ *     -1, on property read failure
+ */
+int fit_set_timestamp (void *fit, int noffset, time_t timestamp)
+{
+	uint32_t t;
+	int ret;
+
+	t = cpu_to_uimage (timestamp);
+	ret = fdt_setprop (fit, noffset, FIT_TIMESTAMP_PROP, &t,
+				sizeof (uint32_t));
+	if (ret) {
+		printf ("Can't set '%s' property for '%s' node (%s)\n",
+			FIT_TIMESTAMP_PROP, fit_get_name (fit, noffset, NULL),
+			fdt_strerror (ret));
+		return -1;
+	}
+
+	return 0;
+}
+
+/**
+ * calculate_hash - calculate and return hash for provided input data
+ * @data: pointer to the input data
+ * @data_len: data length
+ * @algo: requested hash algorithm
+ * @value: pointer to the char, will hold hash value data (caller must
+ * allocate enough free space)
+ * value_len: length of the calculated hash
+ *
+ * calculate_hash() computes input data hash according to the requested algorithm.
+ * Resulting hash value is placed in caller provided 'value' buffer, length
+ * of the calculated hash is returned via value_len pointer argument.
+ *
+ * returns:
+ *     0, on success
+ *    -1, when algo is unsupported
+ */
+static int calculate_hash (const void *data, int data_len, const char *algo,
+			uint8_t *value, int *value_len)
+{
+	if (strcmp (algo, "crc32") == 0 ) {
+		*((uint32_t *)value) = crc32_wd (0, data, data_len,
+							CHUNKSZ_CRC32);
+		*((uint32_t *)value) = cpu_to_uimage (*((uint32_t *)value));
+		*value_len = 4;
+	} else if (strcmp (algo, "sha1") == 0 ) {
+		sha1_csum_wd ((unsigned char *) data, data_len,
+				(unsigned char *) value, CHUNKSZ_SHA1);
+		*value_len = 20;
+	} else if (strcmp (algo, "md5") == 0 ) {
+		md5_wd ((unsigned char *)data, data_len, value, CHUNKSZ_MD5);
+		*value_len = 16;
+	} else {
+		debug ("Unsupported hash alogrithm\n");
+		return -1;
+	}
+	return 0;
+}
+
+#ifdef USE_HOSTCC
+/**
+ * fit_set_hashes - process FIT component image nodes and calculate hashes
+ * @fit: pointer to the FIT format image header
+ *
+ * fit_set_hashes() adds hash values for all component images in the FIT blob.
+ * Hashes are calculated for all component images which have hash subnodes
+ * with algorithm property set to one of the supported hash algorithms.
+ *
+ * returns
+ *     0, on success
+ *     libfdt error code, on failure
+ */
+int fit_set_hashes (void *fit)
+{
+	int images_noffset;
+	int noffset;
+	int ndepth;
+	int ret;
+
+	/* Find images parent node offset */
+	images_noffset = fdt_path_offset (fit, FIT_IMAGES_PATH);
+	if (images_noffset < 0) {
+		printf ("Can't find images parent node '%s' (%s)\n",
+			FIT_IMAGES_PATH, fdt_strerror (images_noffset));
+		return images_noffset;
+	}
+
+	/* Process its subnodes, print out component images details */
+	for (ndepth = 0, noffset = fdt_next_node (fit, images_noffset, &ndepth);
+	     (noffset >= 0) && (ndepth > 0);
+	     noffset = fdt_next_node (fit, noffset, &ndepth)) {
+		if (ndepth == 1) {
+			/*
+			 * Direct child node of the images parent node,
+			 * i.e. component image node.
+			 */
+			ret = fit_image_set_hashes (fit, noffset);
+			if (ret)
+				return ret;
+		}
+	}
+
+	return 0;
+}
+
+/**
+ * fit_image_set_hashes - calculate/set hashes for given component image node
+ * @fit: pointer to the FIT format image header
+ * @image_noffset: requested component image node
+ *
+ * fit_image_set_hashes() adds hash values for an component image node. All
+ * existing hash subnodes are checked, if algorithm property is set to one of
+ * the supported hash algorithms, hash value is computed and corresponding
+ * hash node property is set, for example:
+ *
+ * Input component image node structure:
+ *
+ * o image@1 (at image_noffset)
+ *   | - data = [binary data]
+ *   o hash@1
+ *     |- algo = "sha1"
+ *
+ * Output component image node structure:
+ *
+ * o image@1 (at image_noffset)
+ *   | - data = [binary data]
+ *   o hash@1
+ *     |- algo = "sha1"
+ *     |- value = sha1(data)
+ *
+ * returns:
+ *     0 on sucess
+ *    <0 on failure
+ */
+int fit_image_set_hashes (void *fit, int image_noffset)
+{
+	const void *data;
+	size_t size;
+	char *algo;
+	uint8_t value[FIT_MAX_HASH_LEN];
+	int value_len;
+	int noffset;
+	int ndepth;
+
+	/* Get image data and data length */
+	if (fit_image_get_data (fit, image_noffset, &data, &size)) {
+		printf ("Can't get image data/size\n");
+		return -1;
+	}
+
+	/* Process all hash subnodes of the component image node */
+	for (ndepth = 0, noffset = fdt_next_node (fit, image_noffset, &ndepth);
+	     (noffset >= 0) && (ndepth > 0);
+	     noffset = fdt_next_node (fit, noffset, &ndepth)) {
+		if (ndepth == 1) {
+			/* Direct child node of the component image node */
+
+			/*
+			 * Check subnode name, must be equal to "hash".
+			 * Multiple hash nodes require unique unit node
+			 * names, e.g. hash@1, hash@2, etc.
+			 */
+			if (strncmp (fit_get_name(fit, noffset, NULL),
+						FIT_HASH_NODENAME,
+						strlen(FIT_HASH_NODENAME)) != 0) {
+				/* Not a hash subnode, skip it */
+				continue;
+			}
+
+			if (fit_image_hash_get_algo (fit, noffset, &algo)) {
+				printf ("Can't get hash algo property for "
+					"'%s' hash node in '%s' image node\n",
+					fit_get_name (fit, noffset, NULL),
+					fit_get_name (fit, image_noffset, NULL));
+				return -1;
+			}
+
+			if (calculate_hash (data, size, algo, value, &value_len)) {
+				printf ("Unsupported hash algorithm (%s) for "
+					"'%s' hash node in '%s' image node\n",
+					algo, fit_get_name (fit, noffset, NULL),
+					fit_get_name (fit, image_noffset, NULL));
+				return -1;
+			}
+
+			if (fit_image_hash_set_value (fit, noffset, value,
+							value_len)) {
+				printf ("Can't set hash value for "
+					"'%s' hash node in '%s' image node\n",
+					fit_get_name (fit, noffset, NULL),
+					fit_get_name (fit, image_noffset, NULL));
+				return -1;
+			}
+		}
+	}
+
+	return 0;
+}
+
+/**
+ * fit_image_hash_set_value - set hash value in requested has node
+ * @fit: pointer to the FIT format image header
+ * @noffset: hash node offset
+ * @value: hash value to be set
+ * @value_len: hash value length
+ *
+ * fit_image_hash_set_value() attempts to set hash value in a node at offset
+ * given and returns operation status to the caller.
+ *
+ * returns
+ *     0, on success
+ *     -1, on failure
+ */
+int fit_image_hash_set_value (void *fit, int noffset, uint8_t *value,
+				int value_len)
+{
+	int ret;
+
+	ret = fdt_setprop (fit, noffset, FIT_VALUE_PROP, value, value_len);
+	if (ret) {
+		printf ("Can't set hash '%s' property for '%s' node (%s)\n",
+			FIT_VALUE_PROP, fit_get_name (fit, noffset, NULL),
+			fdt_strerror (ret));
+		return -1;
+	}
+
+	return 0;
+}
+#endif /* USE_HOSTCC */
+
+/**
+ * fit_image_check_hashes - verify data intergity
+ * @fit: pointer to the FIT format image header
+ * @image_noffset: component image node offset
+ *
+ * fit_image_check_hashes() goes over component image hash nodes,
+ * re-calculates each data hash and compares with the value stored in hash
+ * node.
+ *
+ * returns:
+ *     1, if all hashes are valid
+ *     0, otherwise (or on error)
+ */
+int fit_image_check_hashes (const void *fit, int image_noffset)
+{
+	const void	*data;
+	size_t		size;
+	char		*algo;
+	uint8_t		*fit_value;
+	int		fit_value_len;
+	uint8_t		value[FIT_MAX_HASH_LEN];
+	int		value_len;
+	int		noffset;
+	int		ndepth;
+	char		*err_msg = "";
+
+	/* Get image data and data length */
+	if (fit_image_get_data (fit, image_noffset, &data, &size)) {
+		printf ("Can't get image data/size\n");
+		return 0;
+	}
+
+	/* Process all hash subnodes of the component image node */
+	for (ndepth = 0, noffset = fdt_next_node (fit, image_noffset, &ndepth);
+	     (noffset >= 0) && (ndepth > 0);
+	     noffset = fdt_next_node (fit, noffset, &ndepth)) {
+		if (ndepth == 1) {
+			/* Direct child node of the component image node */
+
+			/*
+			 * Check subnode name, must be equal to "hash".
+			 * Multiple hash nodes require unique unit node
+			 * names, e.g. hash@1, hash@2, etc.
+			 */
+			if (strncmp (fit_get_name(fit, noffset, NULL),
+					FIT_HASH_NODENAME,
+					strlen(FIT_HASH_NODENAME)) != 0)
+				continue;
+
+			if (fit_image_hash_get_algo (fit, noffset, &algo)) {
+				err_msg = "Can't get hash algo property";
+				goto error;
+			}
+			printf ("%s", algo);
+
+			if (fit_image_hash_get_value (fit, noffset, &fit_value,
+							&fit_value_len)) {
+				err_msg = "Can't get hash value property";
+				goto error;
+			}
+
+			if (calculate_hash (data, size, algo, value, &value_len)) {
+				err_msg = "Unsupported hash algorithm";
+				goto error;
+			}
+
+			if (value_len != fit_value_len) {
+				err_msg = "Bad hash value len";
+				goto error;
+			} else if (memcmp (value, fit_value, value_len) != 0) {
+				err_msg = "Bad hash value";
+				goto error;
+			}
+			printf ("+ ");
+		}
+	}
+
+	return 1;
+
+error:
+	printf ("%s for '%s' hash node in '%s' image node\n",
+			err_msg, fit_get_name (fit, noffset, NULL),
+			fit_get_name (fit, image_noffset, NULL));
+	return 0;
+}
+
+/**
+ * fit_image_check_os - check whether image node is of a given os type
+ * @fit: pointer to the FIT format image header
+ * @noffset: component image node offset
+ * @os: requested image os
+ *
+ * fit_image_check_os() reads image os property and compares its numeric
+ * id with the requested os. Comparison result is returned to the caller.
+ *
+ * returns:
+ *     1 if image is of given os type
+ *     0 otherwise (or on error)
+ */
+int fit_image_check_os (const void *fit, int noffset, uint8_t os)
+{
+	uint8_t image_os;
+
+	if (fit_image_get_os (fit, noffset, &image_os))
+		return 0;
+	return (os == image_os);
+}
+
+/**
+ * fit_image_check_arch - check whether image node is of a given arch
+ * @fit: pointer to the FIT format image header
+ * @noffset: component image node offset
+ * @arch: requested imagearch
+ *
+ * fit_image_check_arch() reads image arch property and compares its numeric
+ * id with the requested arch. Comparison result is returned to the caller.
+ *
+ * returns:
+ *     1 if image is of given arch
+ *     0 otherwise (or on error)
+ */
+int fit_image_check_arch (const void *fit, int noffset, uint8_t arch)
+{
+	uint8_t image_arch;
+
+	if (fit_image_get_arch (fit, noffset, &image_arch))
+		return 0;
+	return (arch == image_arch);
+}
+
+/**
+ * fit_image_check_type - check whether image node is of a given type
+ * @fit: pointer to the FIT format image header
+ * @noffset: component image node offset
+ * @type: requested image type
+ *
+ * fit_image_check_type() reads image type property and compares its numeric
+ * id with the requested type. Comparison result is returned to the caller.
+ *
+ * returns:
+ *     1 if image is of given type
+ *     0 otherwise (or on error)
+ */
+int fit_image_check_type (const void *fit, int noffset, uint8_t type)
+{
+	uint8_t image_type;
+
+	if (fit_image_get_type (fit, noffset, &image_type))
+		return 0;
+	return (type == image_type);
+}
+
+/**
+ * fit_image_check_comp - check whether image node uses given compression
+ * @fit: pointer to the FIT format image header
+ * @noffset: component image node offset
+ * @comp: requested image compression type
+ *
+ * fit_image_check_comp() reads image compression property and compares its
+ * numeric id with the requested compression type. Comparison result is
+ * returned to the caller.
+ *
+ * returns:
+ *     1 if image uses requested compression
+ *     0 otherwise (or on error)
+ */
+int fit_image_check_comp (const void *fit, int noffset, uint8_t comp)
+{
+	uint8_t image_comp;
+
+	if (fit_image_get_comp (fit, noffset, &image_comp))
+		return 0;
+	return (comp == image_comp);
+}
+
+/**
+ * fit_check_format - sanity check FIT image format
+ * @fit: pointer to the FIT format image header
+ *
+ * fit_check_format() runs a basic sanity FIT image verification.
+ * Routine checks for mandatory properties, nodes, etc.
+ *
+ * returns:
+ *     1, on success
+ *     0, on failure
+ */
+int fit_check_format (const void *fit)
+{
+	/* mandatory / node 'description' property */
+	if (fdt_getprop (fit, 0, FIT_DESC_PROP, NULL) == NULL) {
+		debug ("Wrong FIT format: no description\n");
+		return 0;
+	}
+
+#if defined(CONFIG_TIMESTAMP) || defined(CONFIG_CMD_DATE) || defined(USE_HOSTCC)
+	/* mandatory / node 'timestamp' property */
+	if (fdt_getprop (fit, 0, FIT_TIMESTAMP_PROP, NULL) == NULL) {
+		debug ("Wrong FIT format: no description\n");
+		return 0;
+	}
+#endif
+
+	/* mandatory subimages parent '/images' node */
+	if (fdt_path_offset (fit, FIT_IMAGES_PATH) < 0) {
+		debug ("Wrong FIT format: no images parent node\n");
+		return 0;
+	}
+
+	return 1;
+}
+
+/**
+ * fit_conf_get_node - get node offset for configuration of a given unit name
+ * @fit: pointer to the FIT format image header
+ * @conf_uname: configuration node unit name
+ *
+ * fit_conf_get_node() finds a configuration (withing the '/configurations'
+ * parant node) of a provided unit name. If configuration is found its node offset
+ * is returned to the caller.
+ *
+ * When NULL is provided in second argument fit_conf_get_node() will search
+ * for a default configuration node instead. Default configuration node unit name
+ * is retrived from FIT_DEFAULT_PROP property of the '/configurations' node.
+ *
+ * returns:
+ *     configuration node offset when found (>=0)
+ *     negative number on failure (FDT_ERR_* code)
+ */
+int fit_conf_get_node (const void *fit, const char *conf_uname)
+{
+	int noffset, confs_noffset;
+	int len;
+
+	confs_noffset = fdt_path_offset (fit, FIT_CONFS_PATH);
+	if (confs_noffset < 0) {
+		debug ("Can't find configurations parent node '%s' (%s)\n",
+			FIT_CONFS_PATH, fdt_strerror (confs_noffset));
+		return confs_noffset;
+	}
+
+	if (conf_uname == NULL) {
+		/* get configuration unit name from the default property */
+		debug ("No configuration specified, trying default...\n");
+		conf_uname = (char *)fdt_getprop (fit, confs_noffset, FIT_DEFAULT_PROP, &len);
+		if (conf_uname == NULL) {
+			fit_get_debug (fit, confs_noffset, FIT_DEFAULT_PROP, len);
+			return len;
+		}
+		debug ("Found default configuration: '%s'\n", conf_uname);
+	}
+
+	noffset = fdt_subnode_offset (fit, confs_noffset, conf_uname);
+	if (noffset < 0) {
+		debug ("Can't get node offset for configuration unit name: '%s' (%s)\n",
+			conf_uname, fdt_strerror (noffset));
+	}
+
+	return noffset;
+}
+
+static int __fit_conf_get_prop_node (const void *fit, int noffset,
+		const char *prop_name)
+{
+	char *uname;
+	int len;
+
+	/* get kernel image unit name from configuration kernel property */
+	uname = (char *)fdt_getprop (fit, noffset, prop_name, &len);
+	if (uname == NULL)
+		return len;
+
+	return fit_image_get_node (fit, uname);
+}
+
+/**
+ * fit_conf_get_kernel_node - get kernel image node offset that corresponds to
+ * a given configuration
+ * @fit: pointer to the FIT format image header
+ * @noffset: configuration node offset
+ *
+ * fit_conf_get_kernel_node() retrives kernel image node unit name from
+ * configuration FIT_KERNEL_PROP property and translates it to the node
+ * offset.
+ *
+ * returns:
+ *     image node offset when found (>=0)
+ *     negative number on failure (FDT_ERR_* code)
+ */
+int fit_conf_get_kernel_node (const void *fit, int noffset)
+{
+	return __fit_conf_get_prop_node (fit, noffset, FIT_KERNEL_PROP);
+}
+
+/**
+ * fit_conf_get_ramdisk_node - get ramdisk image node offset that corresponds to
+ * a given configuration
+ * @fit: pointer to the FIT format image header
+ * @noffset: configuration node offset
+ *
+ * fit_conf_get_ramdisk_node() retrives ramdisk image node unit name from
+ * configuration FIT_KERNEL_PROP property and translates it to the node
+ * offset.
+ *
+ * returns:
+ *     image node offset when found (>=0)
+ *     negative number on failure (FDT_ERR_* code)
+ */
+int fit_conf_get_ramdisk_node (const void *fit, int noffset)
+{
+	return __fit_conf_get_prop_node (fit, noffset, FIT_RAMDISK_PROP);
+}
+
+/**
+ * fit_conf_get_fdt_node - get fdt image node offset that corresponds to
+ * a given configuration
+ * @fit: pointer to the FIT format image header
+ * @noffset: configuration node offset
+ *
+ * fit_conf_get_fdt_node() retrives fdt image node unit name from
+ * configuration FIT_KERNEL_PROP property and translates it to the node
+ * offset.
+ *
+ * returns:
+ *     image node offset when found (>=0)
+ *     negative number on failure (FDT_ERR_* code)
+ */
+int fit_conf_get_fdt_node (const void *fit, int noffset)
+{
+	return __fit_conf_get_prop_node (fit, noffset, FIT_FDT_PROP);
+}
+
+/**
+ * fit_conf_print - prints out the FIT configuration details
+ * @fit: pointer to the FIT format image header
+ * @noffset: offset of the configuration node
+ * @p: pointer to prefix string
+ *
+ * fit_conf_print() lists all mandatory properies for the processed
+ * configuration node.
+ *
+ * returns:
+ *     no returned results
+ */
+void fit_conf_print (const void *fit, int noffset, const char *p)
+{
+	char *desc;
+	char *uname;
+	int ret;
+
+	/* Mandatory properties */
+	ret = fit_get_desc (fit, noffset, &desc);
+	printf ("%s  Description:  ", p);
+	if (ret)
+		printf ("unavailable\n");
+	else
+		printf ("%s\n", desc);
+
+	uname = (char *)fdt_getprop (fit, noffset, FIT_KERNEL_PROP, NULL);
+	printf ("%s  Kernel:       ", p);
+	if (uname == NULL)
+		printf ("unavailable\n");
+	else
+		printf ("%s\n", uname);
+
+	/* Optional properties */
+	uname = (char *)fdt_getprop (fit, noffset, FIT_RAMDISK_PROP, NULL);
+	if (uname)
+		printf ("%s  Init Ramdisk: %s\n", p, uname);
+
+	uname = (char *)fdt_getprop (fit, noffset, FIT_FDT_PROP, NULL);
+	if (uname)
+		printf ("%s  FDT:          %s\n", p, uname);
+}
+
+/**
+ * fit_check_ramdisk - verify FIT format ramdisk subimage
+ * @fit_hdr: pointer to the FIT ramdisk header
+ * @rd_noffset: ramdisk subimage node offset within FIT image
+ * @arch: requested ramdisk image architecture type
+ * @verify: data CRC verification flag
+ *
+ * fit_check_ramdisk() verifies integrity of the ramdisk subimage and from
+ * specified FIT image.
+ *
+ * returns:
+ *     1, on success
+ *     0, on failure
+ */
+#ifndef USE_HOSTCC
+static int fit_check_ramdisk (const void *fit, int rd_noffset, uint8_t arch, int verify)
+{
+	fit_image_print (fit, rd_noffset, "   ");
+
+	if (verify) {
+		puts ("   Verifying Hash Integrity ... ");
+		if (!fit_image_check_hashes (fit, rd_noffset)) {
+			puts ("Bad Data Hash\n");
+			show_boot_progress (-125);
+			return 0;
+		}
+		puts ("OK\n");
+	}
+
+	show_boot_progress (126);
+	if (!fit_image_check_os (fit, rd_noffset, IH_OS_LINUX) ||
+	    !fit_image_check_arch (fit, rd_noffset, arch) ||
+	    !fit_image_check_type (fit, rd_noffset, IH_TYPE_RAMDISK)) {
+		printf ("No Linux %s Ramdisk Image\n",
+				genimg_get_arch_name(arch));
+		show_boot_progress (-126);
+		return 0;
+	}
+
+	show_boot_progress (127);
+	return 1;
+}
+#endif /* USE_HOSTCC */
+#endif /* CONFIG_FIT */
diff -N -r -up ./u-boot-1.3.4.orig/tools/libfdt_internal.h ./u-boot-1.3.4/tools/libfdt_internal.h
--- ./u-boot-1.3.4.orig/tools/libfdt_internal.h	1970-01-01 01:00:00.000000000 +0100
+++ ./u-boot-1.3.4/tools/libfdt_internal.h	2008-08-12 16:08:38.000000000 +0200
@@ -0,0 +1,97 @@
+#ifndef _LIBFDT_INTERNAL_H
+#define _LIBFDT_INTERNAL_H
+/*
+ * libfdt - Flat Device Tree manipulation
+ * Copyright (C) 2006 David Gibson, IBM Corporation.
+ *
+ * libfdt is dual licensed: you can use it either under the terms of
+ * the GPL, or the BSD license, at your option.
+ *
+ *  a) This library is free software; you can redistribute it and/or
+ *     modify it under the terms of the GNU General Public License as
+ *     published by the Free Software Foundation; either version 2 of the
+ *     License, or (at your option) any later version.
+ *
+ *     This library is distributed in the hope that it will be useful,
+ *     but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *     GNU General Public License for more details.
+ *
+ *     You should have received a copy of the GNU General Public
+ *     License along with this library; if not, write to the Free
+ *     Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
+ *     MA 02110-1301 USA
+ *
+ * Alternatively,
+ *
+ *  b) Redistribution and use in source and binary forms, with or
+ *     without modification, are permitted provided that the following
+ *     conditions are met:
+ *
+ *     1. Redistributions of source code must retain the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer.
+ *     2. Redistributions in binary form must reproduce the above
+ *        copyright notice, this list of conditions and the following
+ *        disclaimer in the documentation and/or other materials
+ *        provided with the distribution.
+ *
+ *     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND
+ *     CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES,
+ *     INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ *     MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
+ *     DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
+ *     CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ *     SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ *     NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ *     LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ *     HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ *     CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
+ *     OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
+ *     EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#include <fdt.h>
+
+#define ALIGN(x, a)	(((x) + (a) - 1) & ~((a) - 1))
+#define PALIGN(p, a)	((void *)ALIGN((unsigned long)(p), (a)))
+
+#define memeq(p, q, n)	(memcmp((p), (q), (n)) == 0)
+#define streq(p, q)	(strcmp((p), (q)) == 0)
+
+#define CHECK_HEADER(fdt) \
+	{ \
+		int err; \
+		if ((err = fdt_check_header(fdt)) != 0) \
+			return err; \
+	}
+
+uint32_t _fdt_next_tag(const void *fdt, int startoffset, int *nextoffset);
+int _fdt_check_node_offset(const void *fdt, int offset);
+const char *_fdt_find_string(const char *strtab, int tabsize, const char *s);
+int _fdt_node_end_offset(void *fdt, int nodeoffset);
+
+static inline const void *_fdt_offset_ptr(const void *fdt, int offset)
+{
+	return fdt + fdt_off_dt_struct(fdt) + offset;
+}
+
+static inline void *_fdt_offset_ptr_w(void *fdt, int offset)
+{
+	return (void *)_fdt_offset_ptr(fdt, offset);
+}
+
+static inline const struct fdt_reserve_entry *_fdt_mem_rsv(const void *fdt, int n)
+{
+	const struct fdt_reserve_entry *rsv_table =
+		fdt + fdt_off_mem_rsvmap(fdt);
+
+	return rsv_table + n;
+}
+static inline struct fdt_reserve_entry *_fdt_mem_rsv_w(void *fdt, int n)
+{
+	return (void *)_fdt_mem_rsv(fdt, n);
+}
+
+#define SW_MAGIC		(~FDT_MAGIC)
+
+#endif /* _LIBFDT_INTERNAL_H */
diff -N -r -up ./u-boot-1.3.4.orig/tools/md5.c ./u-boot-1.3.4/tools/md5.c
--- ./u-boot-1.3.4.orig/tools/md5.c	1970-01-01 01:00:00.000000000 +0100
+++ ./u-boot-1.3.4/tools/md5.c	2008-08-12 16:08:38.000000000 +0200
@@ -0,0 +1,316 @@
+/*
+ * This file was transplanted with slight modifications from Linux sources
+ * (fs/cifs/md5.c) into U-Boot by Bartlomiej Sieka <tur@semihalf.com>.
+ */
+
+/*
+ * This code implements the MD5 message-digest algorithm.
+ * The algorithm is due to Ron Rivest.  This code was
+ * written by Colin Plumb in 1993, no copyright is claimed.
+ * This code is in the public domain; do with it what you wish.
+ *
+ * Equivalent code is available from RSA Data Security, Inc.
+ * This code has been tested against that, and is equivalent,
+ * except that you don't need to include two pages of legalese
+ * with every copy.
+ *
+ * To compute the message digest of a chunk of bytes, declare an
+ * MD5Context structure, pass it to MD5Init, call MD5Update as
+ * needed on buffers full of bytes, and then call MD5Final, which
+ * will fill a supplied 16-byte array with the digest.
+ */
+
+/* This code slightly modified to fit into Samba by
+   abartlet@samba.org Jun 2001
+   and to fit the cifs vfs by
+   Steve French sfrench@us.ibm.com */
+
+#ifndef USE_HOSTCC
+#include <common.h>
+#include <linux/string.h>
+#else
+#include <string.h>
+#endif /* USE_HOSTCC */
+#include <watchdog.h>
+#include <linux/types.h>
+#include <u-boot/md5.h>
+
+static void
+MD5Transform(__u32 buf[4], __u32 const in[16]);
+
+/*
+ * Note: this code is harmless on little-endian machines.
+ */
+static void
+byteReverse(unsigned char *buf, unsigned longs)
+{
+	__u32 t;
+	do {
+		t = (__u32) ((unsigned) buf[3] << 8 | buf[2]) << 16 |
+		    ((unsigned) buf[1] << 8 | buf[0]);
+		*(__u32 *) buf = t;
+		buf += 4;
+	} while (--longs);
+}
+
+/*
+ * Start MD5 accumulation.  Set bit count to 0 and buffer to mysterious
+ * initialization constants.
+ */
+static void
+MD5Init(struct MD5Context *ctx)
+{
+	ctx->buf[0] = 0x67452301;
+	ctx->buf[1] = 0xefcdab89;
+	ctx->buf[2] = 0x98badcfe;
+	ctx->buf[3] = 0x10325476;
+
+	ctx->bits[0] = 0;
+	ctx->bits[1] = 0;
+}
+
+/*
+ * Update context to reflect the concatenation of another buffer full
+ * of bytes.
+ */
+static void
+MD5Update(struct MD5Context *ctx, unsigned char const *buf, unsigned len)
+{
+	register __u32 t;
+
+	/* Update bitcount */
+
+	t = ctx->bits[0];
+	if ((ctx->bits[0] = t + ((__u32) len << 3)) < t)
+		ctx->bits[1]++;	/* Carry from low to high */
+	ctx->bits[1] += len >> 29;
+
+	t = (t >> 3) & 0x3f;	/* Bytes already in shsInfo->data */
+
+	/* Handle any leading odd-sized chunks */
+
+	if (t) {
+		unsigned char *p = (unsigned char *) ctx->in + t;
+
+		t = 64 - t;
+		if (len < t) {
+			memmove(p, buf, len);
+			return;
+		}
+		memmove(p, buf, t);
+		byteReverse(ctx->in, 16);
+		MD5Transform(ctx->buf, (__u32 *) ctx->in);
+		buf += t;
+		len -= t;
+	}
+	/* Process data in 64-byte chunks */
+
+	while (len >= 64) {
+		memmove(ctx->in, buf, 64);
+		byteReverse(ctx->in, 16);
+		MD5Transform(ctx->buf, (__u32 *) ctx->in);
+		buf += 64;
+		len -= 64;
+	}
+
+	/* Handle any remaining bytes of data. */
+
+	memmove(ctx->in, buf, len);
+}
+
+/*
+ * Final wrapup - pad to 64-byte boundary with the bit pattern
+ * 1 0* (64-bit count of bits processed, MSB-first)
+ */
+static void
+MD5Final(unsigned char digest[16], struct MD5Context *ctx)
+{
+	unsigned int count;
+	unsigned char *p;
+
+	/* Compute number of bytes mod 64 */
+	count = (ctx->bits[0] >> 3) & 0x3F;
+
+	/* Set the first char of padding to 0x80.  This is safe since there is
+	   always at least one byte free */
+	p = ctx->in + count;
+	*p++ = 0x80;
+
+	/* Bytes of padding needed to make 64 bytes */
+	count = 64 - 1 - count;
+
+	/* Pad out to 56 mod 64 */
+	if (count < 8) {
+		/* Two lots of padding:  Pad the first block to 64 bytes */
+		memset(p, 0, count);
+		byteReverse(ctx->in, 16);
+		MD5Transform(ctx->buf, (__u32 *) ctx->in);
+
+		/* Now fill the next block with 56 bytes */
+		memset(ctx->in, 0, 56);
+	} else {
+		/* Pad block to 56 bytes */
+		memset(p, 0, count - 8);
+	}
+	byteReverse(ctx->in, 14);
+
+	/* Append length in bits and transform */
+	((__u32 *) ctx->in)[14] = ctx->bits[0];
+	((__u32 *) ctx->in)[15] = ctx->bits[1];
+
+	MD5Transform(ctx->buf, (__u32 *) ctx->in);
+	byteReverse((unsigned char *) ctx->buf, 4);
+	memmove(digest, ctx->buf, 16);
+	memset(ctx, 0, sizeof(*ctx));	/* In case it's sensitive */
+}
+
+/* The four core functions - F1 is optimized somewhat */
+
+/* #define F1(x, y, z) (x & y | ~x & z) */
+#define F1(x, y, z) (z ^ (x & (y ^ z)))
+#define F2(x, y, z) F1(z, x, y)
+#define F3(x, y, z) (x ^ y ^ z)
+#define F4(x, y, z) (y ^ (x | ~z))
+
+/* This is the central step in the MD5 algorithm. */
+#define MD5STEP(f, w, x, y, z, data, s) \
+	( w += f(x, y, z) + data,  w = w<<s | w>>(32-s),  w += x )
+
+/*
+ * The core of the MD5 algorithm, this alters an existing MD5 hash to
+ * reflect the addition of 16 longwords of new data.  MD5Update blocks
+ * the data and converts bytes into longwords for this routine.
+ */
+static void
+MD5Transform(__u32 buf[4], __u32 const in[16])
+{
+	register __u32 a, b, c, d;
+
+	a = buf[0];
+	b = buf[1];
+	c = buf[2];
+	d = buf[3];
+
+	MD5STEP(F1, a, b, c, d, in[0] + 0xd76aa478, 7);
+	MD5STEP(F1, d, a, b, c, in[1] + 0xe8c7b756, 12);
+	MD5STEP(F1, c, d, a, b, in[2] + 0x242070db, 17);
+	MD5STEP(F1, b, c, d, a, in[3] + 0xc1bdceee, 22);
+	MD5STEP(F1, a, b, c, d, in[4] + 0xf57c0faf, 7);
+	MD5STEP(F1, d, a, b, c, in[5] + 0x4787c62a, 12);
+	MD5STEP(F1, c, d, a, b, in[6] + 0xa8304613, 17);
+	MD5STEP(F1, b, c, d, a, in[7] + 0xfd469501, 22);
+	MD5STEP(F1, a, b, c, d, in[8] + 0x698098d8, 7);
+	MD5STEP(F1, d, a, b, c, in[9] + 0x8b44f7af, 12);
+	MD5STEP(F1, c, d, a, b, in[10] + 0xffff5bb1, 17);
+	MD5STEP(F1, b, c, d, a, in[11] + 0x895cd7be, 22);
+	MD5STEP(F1, a, b, c, d, in[12] + 0x6b901122, 7);
+	MD5STEP(F1, d, a, b, c, in[13] + 0xfd987193, 12);
+	MD5STEP(F1, c, d, a, b, in[14] + 0xa679438e, 17);
+	MD5STEP(F1, b, c, d, a, in[15] + 0x49b40821, 22);
+
+	MD5STEP(F2, a, b, c, d, in[1] + 0xf61e2562, 5);
+	MD5STEP(F2, d, a, b, c, in[6] + 0xc040b340, 9);
+	MD5STEP(F2, c, d, a, b, in[11] + 0x265e5a51, 14);
+	MD5STEP(F2, b, c, d, a, in[0] + 0xe9b6c7aa, 20);
+	MD5STEP(F2, a, b, c, d, in[5] + 0xd62f105d, 5);
+	MD5STEP(F2, d, a, b, c, in[10] + 0x02441453, 9);
+	MD5STEP(F2, c, d, a, b, in[15] + 0xd8a1e681, 14);
+	MD5STEP(F2, b, c, d, a, in[4] + 0xe7d3fbc8, 20);
+	MD5STEP(F2, a, b, c, d, in[9] + 0x21e1cde6, 5);
+	MD5STEP(F2, d, a, b, c, in[14] + 0xc33707d6, 9);
+	MD5STEP(F2, c, d, a, b, in[3] + 0xf4d50d87, 14);
+	MD5STEP(F2, b, c, d, a, in[8] + 0x455a14ed, 20);
+	MD5STEP(F2, a, b, c, d, in[13] + 0xa9e3e905, 5);
+	MD5STEP(F2, d, a, b, c, in[2] + 0xfcefa3f8, 9);
+	MD5STEP(F2, c, d, a, b, in[7] + 0x676f02d9, 14);
+	MD5STEP(F2, b, c, d, a, in[12] + 0x8d2a4c8a, 20);
+
+	MD5STEP(F3, a, b, c, d, in[5] + 0xfffa3942, 4);
+	MD5STEP(F3, d, a, b, c, in[8] + 0x8771f681, 11);
+	MD5STEP(F3, c, d, a, b, in[11] + 0x6d9d6122, 16);
+	MD5STEP(F3, b, c, d, a, in[14] + 0xfde5380c, 23);
+	MD5STEP(F3, a, b, c, d, in[1] + 0xa4beea44, 4);
+	MD5STEP(F3, d, a, b, c, in[4] + 0x4bdecfa9, 11);
+	MD5STEP(F3, c, d, a, b, in[7] + 0xf6bb4b60, 16);
+	MD5STEP(F3, b, c, d, a, in[10] + 0xbebfbc70, 23);
+	MD5STEP(F3, a, b, c, d, in[13] + 0x289b7ec6, 4);
+	MD5STEP(F3, d, a, b, c, in[0] + 0xeaa127fa, 11);
+	MD5STEP(F3, c, d, a, b, in[3] + 0xd4ef3085, 16);
+	MD5STEP(F3, b, c, d, a, in[6] + 0x04881d05, 23);
+	MD5STEP(F3, a, b, c, d, in[9] + 0xd9d4d039, 4);
+	MD5STEP(F3, d, a, b, c, in[12] + 0xe6db99e5, 11);
+	MD5STEP(F3, c, d, a, b, in[15] + 0x1fa27cf8, 16);
+	MD5STEP(F3, b, c, d, a, in[2] + 0xc4ac5665, 23);
+
+	MD5STEP(F4, a, b, c, d, in[0] + 0xf4292244, 6);
+	MD5STEP(F4, d, a, b, c, in[7] + 0x432aff97, 10);
+	MD5STEP(F4, c, d, a, b, in[14] + 0xab9423a7, 15);
+	MD5STEP(F4, b, c, d, a, in[5] + 0xfc93a039, 21);
+	MD5STEP(F4, a, b, c, d, in[12] + 0x655b59c3, 6);
+	MD5STEP(F4, d, a, b, c, in[3] + 0x8f0ccc92, 10);
+	MD5STEP(F4, c, d, a, b, in[10] + 0xffeff47d, 15);
+	MD5STEP(F4, b, c, d, a, in[1] + 0x85845dd1, 21);
+	MD5STEP(F4, a, b, c, d, in[8] + 0x6fa87e4f, 6);
+	MD5STEP(F4, d, a, b, c, in[15] + 0xfe2ce6e0, 10);
+	MD5STEP(F4, c, d, a, b, in[6] + 0xa3014314, 15);
+	MD5STEP(F4, b, c, d, a, in[13] + 0x4e0811a1, 21);
+	MD5STEP(F4, a, b, c, d, in[4] + 0xf7537e82, 6);
+	MD5STEP(F4, d, a, b, c, in[11] + 0xbd3af235, 10);
+	MD5STEP(F4, c, d, a, b, in[2] + 0x2ad7d2bb, 15);
+	MD5STEP(F4, b, c, d, a, in[9] + 0xeb86d391, 21);
+
+	buf[0] += a;
+	buf[1] += b;
+	buf[2] += c;
+	buf[3] += d;
+}
+
+/*
+ * Calculate and store in 'output' the MD5 digest of 'len' bytes at
+ * 'input'. 'output' must have enough space to hold 16 bytes.
+ */
+void
+md5 (unsigned char *input, int len, unsigned char output[16])
+{
+	struct MD5Context context;
+
+	MD5Init(&context);
+	MD5Update(&context, input, len);
+	MD5Final(output, &context);
+}
+
+
+/*
+ * Calculate and store in 'output' the MD5 digest of 'len' bytes at 'input'.
+ * 'output' must have enough space to hold 16 bytes. If 'chunk' Trigger the
+ * watchdog every 'chunk_sz' bytes of input processed.
+ */
+void
+md5_wd (unsigned char *input, int len, unsigned char output[16],
+	unsigned int chunk_sz)
+{
+	struct MD5Context context;
+#if defined(CONFIG_HW_WATCHDOG) || defined(CONFIG_WATCHDOG)
+	unsigned char *end, *curr;
+	int chunk;
+#endif
+
+	MD5Init(&context);
+
+#if defined(CONFIG_HW_WATCHDOG) || defined(CONFIG_WATCHDOG)
+	curr = input;
+	end = input + len;
+	while (curr < end) {
+		chunk = end - curr;
+		if (chunk > chunk_sz)
+			chunk = chunk_sz;
+		MD5Update(&context, curr, chunk);
+		curr += chunk;
+		WATCHDOG_RESET ();
+	}
+#else
+	MD5Update(&context, input, len);
+#endif
+
+	MD5Final(output, &context);
+}
diff -N -r -up ./u-boot-1.3.4.orig/tools/sha1.c ./u-boot-1.3.4/tools/sha1.c
--- ./u-boot-1.3.4.orig/tools/sha1.c	1970-01-01 01:00:00.000000000 +0100
+++ ./u-boot-1.3.4/tools/sha1.c	2008-08-12 16:08:38.000000000 +0200
@@ -0,0 +1,452 @@
+/*
+ *  Heiko Schocher, DENX Software Engineering, hs@denx.de.
+ *  based on:
+ *  FIPS-180-1 compliant SHA-1 implementation
+ *
+ *  Copyright (C) 2003-2006  Christophe Devine
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Lesser General Public
+ *  License, version 2.1 as published by the Free Software Foundation.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Lesser General Public License for more details.
+ *
+ *  You should have received a copy of the GNU Lesser General Public
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ *  MA  02110-1301  USA
+ */
+/*
+ *  The SHA-1 standard was published by NIST in 1993.
+ *
+ *  http://www.itl.nist.gov/fipspubs/fip180-1.htm
+ */
+
+#ifndef _CRT_SECURE_NO_DEPRECATE
+#define _CRT_SECURE_NO_DEPRECATE 1
+#endif
+
+#ifndef USE_HOSTCC
+#include <common.h>
+#include <linux/string.h>
+#else
+#include <string.h>
+#endif /* USE_HOSTCC */
+#include <watchdog.h>
+#include "sha1.h"
+
+/*
+ * 32-bit integer manipulation macros (big endian)
+ */
+#ifndef GET_UINT32_BE
+#define GET_UINT32_BE(n,b,i) {				\
+	(n) = ( (unsigned long) (b)[(i)    ] << 24 )	\
+	    | ( (unsigned long) (b)[(i) + 1] << 16 )	\
+	    | ( (unsigned long) (b)[(i) + 2] <<  8 )	\
+	    | ( (unsigned long) (b)[(i) + 3]       );	\
+}
+#endif
+#ifndef PUT_UINT32_BE
+#define PUT_UINT32_BE(n,b,i) {				\
+	(b)[(i)    ] = (unsigned char) ( (n) >> 24 );	\
+	(b)[(i) + 1] = (unsigned char) ( (n) >> 16 );	\
+	(b)[(i) + 2] = (unsigned char) ( (n) >>  8 );	\
+	(b)[(i) + 3] = (unsigned char) ( (n)       );	\
+}
+#endif
+
+/*
+ * SHA-1 context setup
+ */
+void sha1_starts (sha1_context * ctx)
+{
+	ctx->total[0] = 0;
+	ctx->total[1] = 0;
+
+	ctx->state[0] = 0x67452301;
+	ctx->state[1] = 0xEFCDAB89;
+	ctx->state[2] = 0x98BADCFE;
+	ctx->state[3] = 0x10325476;
+	ctx->state[4] = 0xC3D2E1F0;
+}
+
+static void sha1_process (sha1_context * ctx, unsigned char data[64])
+{
+	unsigned long temp, W[16], A, B, C, D, E;
+
+	GET_UINT32_BE (W[0], data, 0);
+	GET_UINT32_BE (W[1], data, 4);
+	GET_UINT32_BE (W[2], data, 8);
+	GET_UINT32_BE (W[3], data, 12);
+	GET_UINT32_BE (W[4], data, 16);
+	GET_UINT32_BE (W[5], data, 20);
+	GET_UINT32_BE (W[6], data, 24);
+	GET_UINT32_BE (W[7], data, 28);
+	GET_UINT32_BE (W[8], data, 32);
+	GET_UINT32_BE (W[9], data, 36);
+	GET_UINT32_BE (W[10], data, 40);
+	GET_UINT32_BE (W[11], data, 44);
+	GET_UINT32_BE (W[12], data, 48);
+	GET_UINT32_BE (W[13], data, 52);
+	GET_UINT32_BE (W[14], data, 56);
+	GET_UINT32_BE (W[15], data, 60);
+
+#define S(x,n)	((x << n) | ((x & 0xFFFFFFFF) >> (32 - n)))
+
+#define R(t) (						\
+	temp = W[(t -  3) & 0x0F] ^ W[(t - 8) & 0x0F] ^	\
+	       W[(t - 14) & 0x0F] ^ W[ t      & 0x0F],	\
+	( W[t & 0x0F] = S(temp,1) )			\
+)
+
+#define P(a,b,c,d,e,x)	{				\
+	e += S(a,5) + F(b,c,d) + K + x; b = S(b,30);	\
+}
+
+	A = ctx->state[0];
+	B = ctx->state[1];
+	C = ctx->state[2];
+	D = ctx->state[3];
+	E = ctx->state[4];
+
+#define F(x,y,z) (z ^ (x & (y ^ z)))
+#define K 0x5A827999
+
+	P (A, B, C, D, E, W[0]);
+	P (E, A, B, C, D, W[1]);
+	P (D, E, A, B, C, W[2]);
+	P (C, D, E, A, B, W[3]);
+	P (B, C, D, E, A, W[4]);
+	P (A, B, C, D, E, W[5]);
+	P (E, A, B, C, D, W[6]);
+	P (D, E, A, B, C, W[7]);
+	P (C, D, E, A, B, W[8]);
+	P (B, C, D, E, A, W[9]);
+	P (A, B, C, D, E, W[10]);
+	P (E, A, B, C, D, W[11]);
+	P (D, E, A, B, C, W[12]);
+	P (C, D, E, A, B, W[13]);
+	P (B, C, D, E, A, W[14]);
+	P (A, B, C, D, E, W[15]);
+	P (E, A, B, C, D, R (16));
+	P (D, E, A, B, C, R (17));
+	P (C, D, E, A, B, R (18));
+	P (B, C, D, E, A, R (19));
+
+#undef K
+#undef F
+
+#define F(x,y,z) (x ^ y ^ z)
+#define K 0x6ED9EBA1
+
+	P (A, B, C, D, E, R (20));
+	P (E, A, B, C, D, R (21));
+	P (D, E, A, B, C, R (22));
+	P (C, D, E, A, B, R (23));
+	P (B, C, D, E, A, R (24));
+	P (A, B, C, D, E, R (25));
+	P (E, A, B, C, D, R (26));
+	P (D, E, A, B, C, R (27));
+	P (C, D, E, A, B, R (28));
+	P (B, C, D, E, A, R (29));
+	P (A, B, C, D, E, R (30));
+	P (E, A, B, C, D, R (31));
+	P (D, E, A, B, C, R (32));
+	P (C, D, E, A, B, R (33));
+	P (B, C, D, E, A, R (34));
+	P (A, B, C, D, E, R (35));
+	P (E, A, B, C, D, R (36));
+	P (D, E, A, B, C, R (37));
+	P (C, D, E, A, B, R (38));
+	P (B, C, D, E, A, R (39));
+
+#undef K
+#undef F
+
+#define F(x,y,z) ((x & y) | (z & (x | y)))
+#define K 0x8F1BBCDC
+
+	P (A, B, C, D, E, R (40));
+	P (E, A, B, C, D, R (41));
+	P (D, E, A, B, C, R (42));
+	P (C, D, E, A, B, R (43));
+	P (B, C, D, E, A, R (44));
+	P (A, B, C, D, E, R (45));
+	P (E, A, B, C, D, R (46));
+	P (D, E, A, B, C, R (47));
+	P (C, D, E, A, B, R (48));
+	P (B, C, D, E, A, R (49));
+	P (A, B, C, D, E, R (50));
+	P (E, A, B, C, D, R (51));
+	P (D, E, A, B, C, R (52));
+	P (C, D, E, A, B, R (53));
+	P (B, C, D, E, A, R (54));
+	P (A, B, C, D, E, R (55));
+	P (E, A, B, C, D, R (56));
+	P (D, E, A, B, C, R (57));
+	P (C, D, E, A, B, R (58));
+	P (B, C, D, E, A, R (59));
+
+#undef K
+#undef F
+
+#define F(x,y,z) (x ^ y ^ z)
+#define K 0xCA62C1D6
+
+	P (A, B, C, D, E, R (60));
+	P (E, A, B, C, D, R (61));
+	P (D, E, A, B, C, R (62));
+	P (C, D, E, A, B, R (63));
+	P (B, C, D, E, A, R (64));
+	P (A, B, C, D, E, R (65));
+	P (E, A, B, C, D, R (66));
+	P (D, E, A, B, C, R (67));
+	P (C, D, E, A, B, R (68));
+	P (B, C, D, E, A, R (69));
+	P (A, B, C, D, E, R (70));
+	P (E, A, B, C, D, R (71));
+	P (D, E, A, B, C, R (72));
+	P (C, D, E, A, B, R (73));
+	P (B, C, D, E, A, R (74));
+	P (A, B, C, D, E, R (75));
+	P (E, A, B, C, D, R (76));
+	P (D, E, A, B, C, R (77));
+	P (C, D, E, A, B, R (78));
+	P (B, C, D, E, A, R (79));
+
+#undef K
+#undef F
+
+	ctx->state[0] += A;
+	ctx->state[1] += B;
+	ctx->state[2] += C;
+	ctx->state[3] += D;
+	ctx->state[4] += E;
+}
+
+/*
+ * SHA-1 process buffer
+ */
+void sha1_update (sha1_context * ctx, unsigned char *input, int ilen)
+{
+	int fill;
+	unsigned long left;
+
+	if (ilen <= 0)
+		return;
+
+	left = ctx->total[0] & 0x3F;
+	fill = 64 - left;
+
+	ctx->total[0] += ilen;
+	ctx->total[0] &= 0xFFFFFFFF;
+
+	if (ctx->total[0] < (unsigned long) ilen)
+		ctx->total[1]++;
+
+	if (left && ilen >= fill) {
+		memcpy ((void *) (ctx->buffer + left), (void *) input, fill);
+		sha1_process (ctx, ctx->buffer);
+		input += fill;
+		ilen -= fill;
+		left = 0;
+	}
+
+	while (ilen >= 64) {
+		sha1_process (ctx, input);
+		input += 64;
+		ilen -= 64;
+	}
+
+	if (ilen > 0) {
+		memcpy ((void *) (ctx->buffer + left), (void *) input, ilen);
+	}
+}
+
+static const unsigned char sha1_padding[64] = {
+	0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
+};
+
+/*
+ * SHA-1 final digest
+ */
+void sha1_finish (sha1_context * ctx, unsigned char output[20])
+{
+	unsigned long last, padn;
+	unsigned long high, low;
+	unsigned char msglen[8];
+
+	high = (ctx->total[0] >> 29)
+		| (ctx->total[1] << 3);
+	low = (ctx->total[0] << 3);
+
+	PUT_UINT32_BE (high, msglen, 0);
+	PUT_UINT32_BE (low, msglen, 4);
+
+	last = ctx->total[0] & 0x3F;
+	padn = (last < 56) ? (56 - last) : (120 - last);
+
+	sha1_update (ctx, (unsigned char *) sha1_padding, padn);
+	sha1_update (ctx, msglen, 8);
+
+	PUT_UINT32_BE (ctx->state[0], output, 0);
+	PUT_UINT32_BE (ctx->state[1], output, 4);
+	PUT_UINT32_BE (ctx->state[2], output, 8);
+	PUT_UINT32_BE (ctx->state[3], output, 12);
+	PUT_UINT32_BE (ctx->state[4], output, 16);
+}
+
+/*
+ * Output = SHA-1( input buffer )
+ */
+void sha1_csum (unsigned char *input, int ilen, unsigned char output[20])
+{
+	sha1_context ctx;
+
+	sha1_starts (&ctx);
+	sha1_update (&ctx, input, ilen);
+	sha1_finish (&ctx, output);
+}
+
+/*
+ * Output = SHA-1( input buffer ). Trigger the watchdog every 'chunk_sz'
+ * bytes of input processed.
+ */
+void sha1_csum_wd (unsigned char *input, int ilen, unsigned char output[20],
+			unsigned int chunk_sz)
+{
+	sha1_context ctx;
+#if defined(CONFIG_HW_WATCHDOG) || defined(CONFIG_WATCHDOG)
+	unsigned char *end, *curr;
+	int chunk;
+#endif
+
+	sha1_starts (&ctx);
+
+#if defined(CONFIG_HW_WATCHDOG) || defined(CONFIG_WATCHDOG)
+	curr = input;
+	end = input + ilen;
+	while (curr < end) {
+		chunk = end - curr;
+		if (chunk > chunk_sz)
+			chunk = chunk_sz;
+		sha1_update (&ctx, curr, chunk);
+		curr += chunk;
+		WATCHDOG_RESET ();
+	}
+#else
+	sha1_update (&ctx, input, ilen);
+#endif
+
+	sha1_finish (&ctx, output);
+}
+
+/*
+ * Output = HMAC-SHA-1( input buffer, hmac key )
+ */
+void sha1_hmac (unsigned char *key, int keylen,
+		unsigned char *input, int ilen, unsigned char output[20])
+{
+	int i;
+	sha1_context ctx;
+	unsigned char k_ipad[64];
+	unsigned char k_opad[64];
+	unsigned char tmpbuf[20];
+
+	memset (k_ipad, 0x36, 64);
+	memset (k_opad, 0x5C, 64);
+
+	for (i = 0; i < keylen; i++) {
+		if (i >= 64)
+			break;
+
+		k_ipad[i] ^= key[i];
+		k_opad[i] ^= key[i];
+	}
+
+	sha1_starts (&ctx);
+	sha1_update (&ctx, k_ipad, 64);
+	sha1_update (&ctx, input, ilen);
+	sha1_finish (&ctx, tmpbuf);
+
+	sha1_starts (&ctx);
+	sha1_update (&ctx, k_opad, 64);
+	sha1_update (&ctx, tmpbuf, 20);
+	sha1_finish (&ctx, output);
+
+	memset (k_ipad, 0, 64);
+	memset (k_opad, 0, 64);
+	memset (tmpbuf, 0, 20);
+	memset (&ctx, 0, sizeof (sha1_context));
+}
+
+static const char _sha1_src[] = "_sha1_src";
+
+#ifdef SELF_TEST
+/*
+ * FIPS-180-1 test vectors
+ */
+static const char sha1_test_str[3][57] = {
+	{"abc"},
+	{"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq"},
+	{""}
+};
+
+static const unsigned char sha1_test_sum[3][20] = {
+	{0xA9, 0x99, 0x3E, 0x36, 0x47, 0x06, 0x81, 0x6A, 0xBA, 0x3E,
+	 0x25, 0x71, 0x78, 0x50, 0xC2, 0x6C, 0x9C, 0xD0, 0xD8, 0x9D},
+	{0x84, 0x98, 0x3E, 0x44, 0x1C, 0x3B, 0xD2, 0x6E, 0xBA, 0xAE,
+	 0x4A, 0xA1, 0xF9, 0x51, 0x29, 0xE5, 0xE5, 0x46, 0x70, 0xF1},
+	{0x34, 0xAA, 0x97, 0x3C, 0xD4, 0xC4, 0xDA, 0xA4, 0xF6, 0x1E,
+	 0xEB, 0x2B, 0xDB, 0xAD, 0x27, 0x31, 0x65, 0x34, 0x01, 0x6F}
+};
+
+/*
+ * Checkup routine
+ */
+int sha1_self_test (void)
+{
+	int i, j;
+	unsigned char buf[1000];
+	unsigned char sha1sum[20];
+	sha1_context ctx;
+
+	for (i = 0; i < 3; i++) {
+		printf ("  SHA-1 test #%d: ", i + 1);
+
+		sha1_starts (&ctx);
+
+		if (i < 2)
+			sha1_update (&ctx, (unsigned char *) sha1_test_str[i],
+				     strlen (sha1_test_str[i]));
+		else {
+			memset (buf, 'a', 1000);
+			for (j = 0; j < 1000; j++)
+				sha1_update (&ctx, buf, 1000);
+		}
+
+		sha1_finish (&ctx, sha1sum);
+
+		if (memcmp (sha1sum, sha1_test_sum[i], 20) != 0) {
+			printf ("failed\n");
+			return (1);
+		}
+
+		printf ("passed\n");
+	}
+
+	printf ("\n");
+	return (0);
+}
+#else
+int sha1_self_test (void)
+{
+	return (0);
+}
+#endif
diff -N -r -up ./u-boot-1.3.4.orig/tools/zlib.h ./u-boot-1.3.4/tools/zlib.h
--- ./u-boot-1.3.4.orig/tools/zlib.h	1970-01-01 01:00:00.000000000 +0100
+++ ./u-boot-1.3.4/tools/zlib.h	2008-08-12 16:08:38.000000000 +0200
@@ -0,0 +1,434 @@
+/*
+ * This file is derived from zlib.h and zconf.h from the zlib-0.95
+ * distribution by Jean-loup Gailly and Mark Adler, with some additions
+ * by Paul Mackerras to aid in implementing Deflate compression and
+ * decompression for PPP packets.
+ */
+
+/*
+ *  ==FILEVERSION 960122==
+ *
+ * This marker is used by the Linux installation script to determine
+ * whether an up-to-date version of this file is already installed.
+ */
+
+/* zlib.h -- interface of the 'zlib' general purpose compression library
+  version 0.95, Aug 16th, 1995.
+
+  Copyright (C) 1995 Jean-loup Gailly and Mark Adler
+
+  This software is provided 'as-is', without any express or implied
+  warranty.  In no event will the authors be held liable for any damages
+  arising from the use of this software.
+
+  Permission is granted to anyone to use this software for any purpose,
+  including commercial applications, and to alter it and redistribute it
+  freely, subject to the following restrictions:
+
+  1. The origin of this software must not be misrepresented; you must not
+     claim that you wrote the original software. If you use this software
+     in a product, an acknowledgment in the product documentation would be
+     appreciated but is not required.
+  2. Altered source versions must be plainly marked as such, and must not be
+     misrepresented as being the original software.
+  3. This notice may not be removed or altered from any source distribution.
+
+  Jean-loup Gailly        Mark Adler
+  gzip@prep.ai.mit.edu    madler@alumni.caltech.edu
+ */
+
+#ifndef _ZLIB_H
+#define _ZLIB_H
+
+/* #include "zconf.h" */	/* included directly here */
+
+/* zconf.h -- configuration of the zlib compression library
+ * Copyright (C) 1995 Jean-loup Gailly.
+ * For conditions of distribution and use, see copyright notice in zlib.h
+ */
+
+/* From: zconf.h,v 1.12 1995/05/03 17:27:12 jloup Exp */
+
+/*
+     The library does not install any signal handler. It is recommended to
+  add at least a handler for SIGSEGV when decompressing; the library checks
+  the consistency of the input data whenever possible but may go nuts
+  for some forms of corrupted input.
+ */
+
+/*
+ * Compile with -DMAXSEG_64K if the alloc function cannot allocate more
+ * than 64k bytes at a time (needed on systems with 16-bit int).
+ * Compile with -DUNALIGNED_OK if it is OK to access shorts or ints
+ * at addresses which are not a multiple of their size.
+ * Under DOS, -DFAR=far or -DFAR=__far may be needed.
+ */
+
+#ifndef STDC
+#  if defined(MSDOS) || defined(__STDC__) || defined(__cplusplus)
+#    define STDC
+#  endif
+#endif
+
+#ifdef	__MWERKS__ /* Metrowerks CodeWarrior declares fileno() in unix.h */
+#  include <unix.h>
+#endif
+
+/* Maximum value for memLevel in deflateInit2 */
+#ifndef MAX_MEM_LEVEL
+#  ifdef MAXSEG_64K
+#    define MAX_MEM_LEVEL 8
+#  else
+#    define MAX_MEM_LEVEL 9
+#  endif
+#endif
+
+#ifndef FAR
+#  define FAR
+#endif
+
+/* Maximum value for windowBits in deflateInit2 and inflateInit2 */
+#ifndef MAX_WBITS
+#  define MAX_WBITS   15 /* 32K LZ77 window */
+#endif
+
+/* The memory requirements for deflate are (in bytes):
+	    1 << (windowBits+2)   +  1 << (memLevel+9)
+ that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)
+ plus a few kilobytes for small objects. For example, if you want to reduce
+ the default memory requirements from 256K to 128K, compile with
+     make CFLAGS="-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7"
+ Of course this will generally degrade compression (there's no free lunch).
+
+   The memory requirements for inflate are (in bytes) 1 << windowBits
+ that is, 32K for windowBits=15 (default value) plus a few kilobytes
+ for small objects.
+*/
+
+			/* Type declarations */
+
+#ifndef OF /* function prototypes */
+#  ifdef STDC
+#    define OF(args)  args
+#  else
+#    define OF(args)  ()
+#  endif
+#endif
+
+typedef unsigned char  Byte;  /* 8 bits */
+typedef unsigned int   uInt;  /* 16 bits or more */
+typedef unsigned long  uLong; /* 32 bits or more */
+
+typedef Byte FAR Bytef;
+typedef char FAR charf;
+typedef int FAR intf;
+typedef uInt FAR uIntf;
+typedef uLong FAR uLongf;
+
+#ifdef STDC
+   typedef void FAR *voidpf;
+   typedef void     *voidp;
+#else
+   typedef Byte FAR *voidpf;
+   typedef Byte     *voidp;
+#endif
+
+/* end of original zconf.h */
+
+#define ZLIB_VERSION "0.95P"
+
+/*
+     The 'zlib' compression library provides in-memory compression and
+  decompression functions, including integrity checks of the uncompressed
+  data.  This version of the library supports only one compression method
+  (deflation) but other algorithms may be added later and will have the same
+  stream interface.
+
+     For compression the application must provide the output buffer and
+  may optionally provide the input buffer for optimization. For decompression,
+  the application must provide the input buffer and may optionally provide
+  the output buffer for optimization.
+
+     Compression can be done in a single step if the buffers are large
+  enough (for example if an input file is mmap'ed), or can be done by
+  repeated calls of the compression function.  In the latter case, the
+  application must provide more input and/or consume the output
+  (providing more output space) before each call.
+*/
+
+typedef voidpf (*alloc_func) OF((voidpf opaque, uInt items, uInt size));
+typedef void   (*free_func)  OF((voidpf opaque, voidpf address, uInt nbytes));
+
+typedef void   (*cb_func)    OF((Bytef *buf, uInt len));
+
+struct internal_state;
+
+typedef struct z_stream_s {
+    Bytef    *next_in;  /* next input byte */
+    uInt     avail_in;  /* number of bytes available at next_in */
+    uLong    total_in;  /* total nb of input bytes read so far */
+
+    Bytef    *next_out; /* next output byte should be put there */
+    uInt     avail_out; /* remaining free space at next_out */
+    uLong    total_out; /* total nb of bytes output so far */
+
+    char     *msg;      /* last error message, NULL if no error */
+    struct internal_state FAR *state; /* not visible by applications */
+
+    alloc_func zalloc;  /* used to allocate the internal state */
+    free_func  zfree;   /* used to free the internal state */
+    voidp      opaque;  /* private data object passed to zalloc and zfree */
+
+    Byte     data_type; /* best guess about the data type: ascii or binary */
+
+    cb_func  outcb;	/* called regularly just before blocks of output */
+
+} z_stream;
+
+/*
+   The application must update next_in and avail_in when avail_in has
+   dropped to zero. It must update next_out and avail_out when avail_out
+   has dropped to zero. The application must initialize zalloc, zfree and
+   opaque before calling the init function. All other fields are set by the
+   compression library and must not be updated by the application.
+
+   The opaque value provided by the application will be passed as the first
+   parameter for calls of zalloc and zfree. This can be useful for custom
+   memory management. The compression library attaches no meaning to the
+   opaque value.
+
+   zalloc must return Z_NULL if there is not enough memory for the object.
+   On 16-bit systems, the functions zalloc and zfree must be able to allocate
+   exactly 65536 bytes, but will not be required to allocate more than this
+   if the symbol MAXSEG_64K is defined (see zconf.h). WARNING: On MSDOS,
+   pointers returned by zalloc for objects of exactly 65536 bytes *must*
+   have their offset normalized to zero. The default allocation function
+   provided by this library ensures this (see zutil.c). To reduce memory
+   requirements and avoid any allocation of 64K objects, at the expense of
+   compression ratio, compile the library with -DMAX_WBITS=14 (see zconf.h).
+
+   The fields total_in and total_out can be used for statistics or
+   progress reports. After compression, total_in holds the total size of
+   the uncompressed data and may be saved for use in the decompressor
+   (particularly if the decompressor wants to decompress everything in
+   a single step).
+*/
+
+			/* constants */
+
+#define Z_NO_FLUSH      0
+#define Z_PARTIAL_FLUSH 1
+#define Z_FULL_FLUSH    2
+#define Z_SYNC_FLUSH    3 /* experimental: partial_flush + byte align */
+#define Z_FINISH        4
+#define Z_PACKET_FLUSH	5
+/* See deflate() below for the usage of these constants */
+
+#define Z_OK            0
+#define Z_STREAM_END    1
+#define Z_ERRNO        (-1)
+#define Z_STREAM_ERROR (-2)
+#define Z_DATA_ERROR   (-3)
+#define Z_MEM_ERROR    (-4)
+#define Z_BUF_ERROR    (-5)
+/* error codes for the compression/decompression functions */
+
+#define Z_BEST_SPEED             1
+#define Z_BEST_COMPRESSION       9
+#define Z_DEFAULT_COMPRESSION  (-1)
+/* compression levels */
+
+#define Z_FILTERED            1
+#define Z_HUFFMAN_ONLY        2
+#define Z_DEFAULT_STRATEGY    0
+
+#define Z_BINARY   0
+#define Z_ASCII    1
+#define Z_UNKNOWN  2
+/* Used to set the data_type field */
+
+#define Z_NULL  0  /* for initializing zalloc, zfree, opaque */
+
+extern char *zlib_version;
+/* The application can compare zlib_version and ZLIB_VERSION for consistency.
+   If the first character differs, the library code actually used is
+   not compatible with the zlib.h header file used by the application.
+ */
+
+			/* basic functions */
+
+extern int inflateInit OF((z_stream *strm));
+/*
+     Initializes the internal stream state for decompression. The fields
+   zalloc and zfree must be initialized before by the caller.  If zalloc and
+   zfree are set to Z_NULL, inflateInit updates them to use default allocation
+   functions.
+
+     inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not
+   enough memory.  msg is set to null if there is no error message.
+   inflateInit does not perform any decompression: this will be done by
+   inflate().
+*/
+
+
+extern int inflate OF((z_stream *strm, int flush));
+/*
+  Performs one or both of the following actions:
+
+  - Decompress more input starting at next_in and update next_in and avail_in
+    accordingly. If not all input can be processed (because there is not
+    enough room in the output buffer), next_in is updated and processing
+    will resume at this point for the next call of inflate().
+
+  - Provide more output starting at next_out and update next_out and avail_out
+    accordingly.  inflate() always provides as much output as possible
+    (until there is no more input data or no more space in the output buffer).
+
+  Before the call of inflate(), the application should ensure that at least
+  one of the actions is possible, by providing more input and/or consuming
+  more output, and updating the next_* and avail_* values accordingly.
+  The application can consume the uncompressed output when it wants, for
+  example when the output buffer is full (avail_out == 0), or after each
+  call of inflate().
+
+    If the parameter flush is set to Z_PARTIAL_FLUSH or Z_PACKET_FLUSH,
+  inflate flushes as much output as possible to the output buffer. The
+  flushing behavior of inflate is not specified for values of the flush
+  parameter other than Z_PARTIAL_FLUSH, Z_PACKET_FLUSH or Z_FINISH, but the
+  current implementation actually flushes as much output as possible
+  anyway.  For Z_PACKET_FLUSH, inflate checks that once all the input data
+  has been consumed, it is expecting to see the length field of a stored
+  block; if not, it returns Z_DATA_ERROR.
+
+    inflate() should normally be called until it returns Z_STREAM_END or an
+  error. However if all decompression is to be performed in a single step
+  (a single call of inflate), the parameter flush should be set to
+  Z_FINISH. In this case all pending input is processed and all pending
+  output is flushed; avail_out must be large enough to hold all the
+  uncompressed data. (The size of the uncompressed data may have been saved
+  by the compressor for this purpose.) The next operation on this stream must
+  be inflateEnd to deallocate the decompression state. The use of Z_FINISH
+  is never required, but can be used to inform inflate that a faster routine
+  may be used for the single inflate() call.
+
+    inflate() returns Z_OK if some progress has been made (more input
+  processed or more output produced), Z_STREAM_END if the end of the
+  compressed data has been reached and all uncompressed output has been
+  produced, Z_DATA_ERROR if the input data was corrupted, Z_STREAM_ERROR if
+  the stream structure was inconsistent (for example if next_in or next_out
+  was NULL), Z_MEM_ERROR if there was not enough memory, Z_BUF_ERROR if no
+  progress is possible or if there was not enough room in the output buffer
+  when Z_FINISH is used. In the Z_DATA_ERROR case, the application may then
+  call inflateSync to look for a good compression block.  */
+
+
+extern int inflateEnd OF((z_stream *strm));
+/*
+     All dynamically allocated data structures for this stream are freed.
+   This function discards any unprocessed input and does not flush any
+   pending output.
+
+     inflateEnd returns Z_OK if success, Z_STREAM_ERROR if the stream state
+   was inconsistent. In the error case, msg may be set but then points to a
+   static string (which must not be deallocated).
+*/
+
+			/* advanced functions */
+
+extern int inflateInit2 OF((z_stream *strm,
+			    int  windowBits));
+/*
+     This is another version of inflateInit with more compression options. The
+   fields next_out, zalloc and zfree must be initialized before by the caller.
+
+     The windowBits parameter is the base two logarithm of the maximum window
+   size (the size of the history buffer).  It should be in the range 8..15 for
+   this version of the library (the value 16 will be allowed soon). The
+   default value is 15 if inflateInit is used instead. If a compressed stream
+   with a larger window size is given as input, inflate() will return with
+   the error code Z_DATA_ERROR instead of trying to allocate a larger window.
+
+     If next_out is not null, the library will use this buffer for the history
+   buffer; the buffer must either be large enough to hold the entire output
+   data, or have at least 1<<windowBits bytes.  If next_out is null, the
+   library will allocate its own buffer (and leave next_out null). next_in
+   need not be provided here but must be provided by the application for the
+   next call of inflate().
+
+     If the history buffer is provided by the application, next_out must
+   never be changed by the application since the decompressor maintains
+   history information inside this buffer from call to call; the application
+   can only reset next_out to the beginning of the history buffer when
+   avail_out is zero and all output has been consumed.
+
+      inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was
+   not enough memory, Z_STREAM_ERROR if a parameter is invalid (such as
+   windowBits < 8). msg is set to null if there is no error message.
+   inflateInit2 does not perform any decompression: this will be done by
+   inflate().
+*/
+
+extern int inflateSync OF((z_stream *strm));
+/*
+    Skips invalid compressed data until the special marker (see deflate()
+  above) can be found, or until all available input is skipped. No output
+  is provided.
+
+    inflateSync returns Z_OK if the special marker has been found, Z_BUF_ERROR
+  if no more input was provided, Z_DATA_ERROR if no marker has been found,
+  or Z_STREAM_ERROR if the stream structure was inconsistent. In the success
+  case, the application may save the current current value of total_in which
+  indicates where valid compressed data was found. In the error case, the
+  application may repeatedly call inflateSync, providing more input each time,
+  until success or end of the input data.
+*/
+
+extern int inflateReset OF((z_stream *strm));
+/*
+     This function is equivalent to inflateEnd followed by inflateInit,
+   but does not free and reallocate all the internal decompression state.
+   The stream will keep attributes that may have been set by inflateInit2.
+
+      inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
+   stream state was inconsistent (such as zalloc or state being NULL).
+*/
+
+extern int inflateIncomp OF((z_stream *strm));
+/*
+     This function adds the data at next_in (avail_in bytes) to the output
+   history without performing any output.  There must be no pending output,
+   and the decompressor must be expecting to see the start of a block.
+   Calling this function is equivalent to decompressing a stored block
+   containing the data at next_in (except that the data is not output).
+*/
+
+			/* checksum functions */
+
+/*
+     This function is not related to compression but is exported
+   anyway because it might be useful in applications using the
+   compression library.
+*/
+
+extern uLong adler32 OF((uLong adler, Bytef *buf, uInt len));
+
+/*
+     Update a running Adler-32 checksum with the bytes buf[0..len-1] and
+   return the updated checksum. If buf is NULL, this function returns
+   the required initial value for the checksum.
+   An Adler-32 checksum is almost as reliable as a CRC32 but can be computed
+   much faster. Usage example:
+
+     uLong adler = adler32(0L, Z_NULL, 0);
+
+     while (read_buffer(buffer, length) != EOF) {
+       adler = adler32(adler, buffer, length);
+     }
+     if (adler != original_adler) error();
+*/
+
+#ifndef _Z_UTIL_H
+    struct internal_state {int dummy;}; /* hack for buggy compilers */
+#endif
+
+#endif /* _ZLIB_H */
