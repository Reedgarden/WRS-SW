From 6030391bcaf141b80f76ea3abb4ab37b70ede9af Mon Sep 17 00:00:00 2001
From: Alessandro Rubini <rubini@unipv.it>
Date: Wed, 27 May 2009 00:44:01 +0200
Subject: [PATCH 05/11] arm fiq: allow modules to exploit the fiq mechanism

This patch exports "fiq_userptr" so that a module can hook to the fiq
handler. This mechanism is used by my "fiq-engine" external package
found in gnudd.com.

To prevent data aborts in vmalloc areas during fiq-mode, vmalloc.c is
modified to update the virtual memory of all processes in map_vm_area().
Without this patch such updates happen on demand, but page faults can't
be managed in fiq mode. Unfortunately, it's #fidef CONFIG_ARM in vmalloc.c

We had conflicts in porting from v2.6.39, here:

	arch/arm/kernel/armksyms.c
	arch/arm/kernel/entry-armv.S

But they turned out to be easily solvable stuff. Let's see, we may
not need this any more (it is only used on older hw), but the patch
is still applying by now. I hope it works too.

Signed-off-by: Alessandro Rubini <rubini@gnudd.com>
---
 arch/arm/kernel/armksyms.c   |    6 ++++++
 arch/arm/kernel/entry-armv.S |   23 +++++++++++++++++++++++
 mm/vmalloc.c                 |   37 +++++++++++++++++++++++++++++++++++++
 3 files changed, 66 insertions(+), 0 deletions(-)

diff --git a/arch/arm/kernel/armksyms.c b/arch/arm/kernel/armksyms.c
index 85e664b..659b60a7 100644
--- a/arch/arm/kernel/armksyms.c
+++ b/arch/arm/kernel/armksyms.c
@@ -50,6 +50,12 @@ extern void __aeabi_ulcmp(void);
 
 extern void fpundefinstr(void);
 
+/*
+ * for fiq support (code in entry-armv.S -- ARub)
+ */
+extern void (*fiq_userptr)(void);
+EXPORT_SYMBOL(fiq_userptr);
+
 	/* platform dependent support */
 EXPORT_SYMBOL(arm_delay_ops);
 
diff --git a/arch/arm/kernel/entry-armv.S b/arch/arm/kernel/entry-armv.S
index 1879e8d..5aa39c9 100644
--- a/arch/arm/kernel/entry-armv.S
+++ b/arch/arm/kernel/entry-armv.S
@@ -1123,8 +1123,31 @@ vector_addrexcptn:
  * other mode than FIQ...  Ok you can switch to another mode, but you can't
  * get out of that mode without clobbering one register.
  */
+/* ARub: try to use it instead (we won't leave FIQ mode anyway) */
 vector_fiq:
+	ldr	r9,	1f
+	ldr	r9,	[r9]
+	movs	r9,	r9
+	beq	fiq_ret
+	mov	r8,	lr
+	mov	lr,	pc
+	mov	pc,	r9	/* jump to userptr */
+	mov	lr,	r8
+fiq_ret:
 	subs	pc, lr, #4
+fiq_savemm:
+	.long	0
+
+
+
+1:	.long	fiq_userptr
+
+.section .text /* can't live here... */
+.globl	fiq_userptr
+fiq_userptr:
+	.long	0		/* This must save r0..r8 inclusive */
+.previous
+
 
 	.globl	vector_fiq_offset
 	.equ	vector_fiq_offset, vector_fiq
diff --git a/mm/vmalloc.c b/mm/vmalloc.c
index 0fdf968..571af847 100644
--- a/mm/vmalloc.c
+++ b/mm/vmalloc.c
@@ -1273,6 +1273,43 @@ int map_vm_area(struct vm_struct *area, pgprot_t prot, struct page ***pages)
 		err = 0;
 	}
 
+/*
+ * In order to support installation of a non-trivial FIQ handler, on ARM
+ * we need to replicate kernel virtual memory to all processes (so it
+ * can be accessed from fiq state irrespective of what current process is).
+ * The code comes from do_translation_fault, and is arm-specific.
+ */
+#ifdef CONFIG_ARM
+	if (!err) {
+		struct task_struct *p;
+		for_each_process(p) {
+			task_lock(p);
+			if (!p->mm)
+				goto next_process;
+			if (p->mm == &init_mm)
+				goto next_process;
+			for (addr = (unsigned long)area->addr;
+			     addr < end; addr += PAGE_SIZE) {
+				/* "+= PMD_SIZE" may be faster... */
+				unsigned int index;
+				pgd_t *pgd, *pgd_k;
+				pmd_t *pmd, *pmd_k;
+				/*  from do_translation_fault() */
+				index = pgd_index(addr);
+				pgd = p->mm->pgd + index;
+				pgd_k = init_mm.pgd + index;
+				if (!pgd_present(*pgd))
+					set_pgd(pgd, *pgd_k);
+				pmd_k = pmd_offset(pgd_k, addr);
+				pmd   = pmd_offset(pgd, addr);
+				copy_pmd(pmd, pmd_k);
+			}
+		next_process:
+			task_unlock(p);
+		}
+	}
+#endif
+
 	return err;
 }
 EXPORT_SYMBOL_GPL(map_vm_area);
-- 
1.7.7.2

